{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview \u00b6 Datamol is a python library to work with molecules. It's a layer built on top of RDKit and aims to be as light as possible. \ud83d\udc0d Simple pythonic API \u2697\ufe0f RDKit first: all you manipulate are rdkit.Chem.Mol objects. \u2705 Manipulating molecules often rely on many options; Datamol provides good defaults by design. \ud83e\udde0 Performance matters: built-in efficient parallelization when possible with optional progress bar. \ud83d\udd79\ufe0f Modern IO: out-of-the-box support for remote paths using fsspec to read and write multiple formats (sdf, xlsx, csv, etc). Visit our website at https://datamol.io . Installation \u00b6 Use conda: mamba install -c conda-forge datamol Tips: You can replace mamba by conda . Note: We highly recommend using a Conda Python distribution to install Datamol. The package is also pip installable if you need it: pip install datamol . Quick API Tour \u00b6 import datamol as dm # Common functions mol = dm . to_mol ( \"O=C(C)Oc1ccccc1C(=O)O\" , sanitize = True ) fp = dm . to_fp ( mol ) selfies = dm . to_selfies ( mol ) inchi = dm . to_inchi ( mol ) # Standardize and sanitize mol = dm . to_mol ( \"O=C(C)Oc1ccccc1C(=O)O\" ) mol = dm . fix_mol ( mol ) mol = dm . sanitize_mol ( mol ) mol = dm . standardize_mol ( mol ) # Dataframe manipulation df = dm . data . freesolv () mols = dm . from_df ( df ) # 2D viz legends = [ dm . to_smiles ( mol ) for mol in mols [: 10 ]] dm . viz . to_image ( mols [: 10 ], legends = legends ) # Generate conformers smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm . to_mol ( smiles ) mol_with_conformers = dm . conformers . generate ( mol ) # 3D viz (using nglview) dm . viz . conformers ( mol , n_confs = 10 ) # Compute SASA from conformers sasa = dm . conformers . sasa ( mol_with_conformers ) # Easy IO mols = dm . read_sdf ( \"s3://my-awesome-data-lake/smiles.sdf\" , as_df = False ) dm . to_sdf ( mols , \"gs://data-bucket/smiles.sdf\" ) How to cite \u00b6 Please cite Datamol if you use it in your research: . Compatibilities \u00b6 Version compatibilities are an essential topic for production-software stacks. We are cautious about documenting compatibility between datamol , python and rdkit . See below the associated versions of Python and RDKit, for which a minor version of Datamol has been tested during its whole lifecycle. datamol python rdkit 0.7 [3.8, 3.9] [2021.09, 2022.03] 0.6 [3.8, 3.9] [2021.09] 0.5 [3.8, 3.9] [2021.03, 2021.09] 0.4 [3.8, 3.9] [2020.09, 2021.03] 0.3 [3.8, 3.9] [2020.09, 2021.03]","title":"Overview"},{"location":"index.html#overview","text":"Datamol is a python library to work with molecules. It's a layer built on top of RDKit and aims to be as light as possible. \ud83d\udc0d Simple pythonic API \u2697\ufe0f RDKit first: all you manipulate are rdkit.Chem.Mol objects. \u2705 Manipulating molecules often rely on many options; Datamol provides good defaults by design. \ud83e\udde0 Performance matters: built-in efficient parallelization when possible with optional progress bar. \ud83d\udd79\ufe0f Modern IO: out-of-the-box support for remote paths using fsspec to read and write multiple formats (sdf, xlsx, csv, etc). Visit our website at https://datamol.io .","title":"Overview"},{"location":"index.html#installation","text":"Use conda: mamba install -c conda-forge datamol Tips: You can replace mamba by conda . Note: We highly recommend using a Conda Python distribution to install Datamol. The package is also pip installable if you need it: pip install datamol .","title":"Installation"},{"location":"index.html#quick-api-tour","text":"import datamol as dm # Common functions mol = dm . to_mol ( \"O=C(C)Oc1ccccc1C(=O)O\" , sanitize = True ) fp = dm . to_fp ( mol ) selfies = dm . to_selfies ( mol ) inchi = dm . to_inchi ( mol ) # Standardize and sanitize mol = dm . to_mol ( \"O=C(C)Oc1ccccc1C(=O)O\" ) mol = dm . fix_mol ( mol ) mol = dm . sanitize_mol ( mol ) mol = dm . standardize_mol ( mol ) # Dataframe manipulation df = dm . data . freesolv () mols = dm . from_df ( df ) # 2D viz legends = [ dm . to_smiles ( mol ) for mol in mols [: 10 ]] dm . viz . to_image ( mols [: 10 ], legends = legends ) # Generate conformers smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm . to_mol ( smiles ) mol_with_conformers = dm . conformers . generate ( mol ) # 3D viz (using nglview) dm . viz . conformers ( mol , n_confs = 10 ) # Compute SASA from conformers sasa = dm . conformers . sasa ( mol_with_conformers ) # Easy IO mols = dm . read_sdf ( \"s3://my-awesome-data-lake/smiles.sdf\" , as_df = False ) dm . to_sdf ( mols , \"gs://data-bucket/smiles.sdf\" )","title":"Quick API Tour"},{"location":"index.html#how-to-cite","text":"Please cite Datamol if you use it in your research: .","title":"How to cite"},{"location":"index.html#compatibilities","text":"Version compatibilities are an essential topic for production-software stacks. We are cautious about documenting compatibility between datamol , python and rdkit . See below the associated versions of Python and RDKit, for which a minor version of Datamol has been tested during its whole lifecycle. datamol python rdkit 0.7 [3.8, 3.9] [2021.09, 2022.03] 0.6 [3.8, 3.9] [2021.09] 0.5 [3.8, 3.9] [2021.03, 2021.09] 0.4 [3.8, 3.9] [2020.09, 2021.03] 0.3 [3.8, 3.9] [2020.09, 2021.03]","title":"Compatibilities"},{"location":"contribute.html","text":"Contribute \u00b6 The below documents the development lifecycle of Datamol. Setup a dev environment \u00b6 mamba env create -n datamol -f env.yml conda activate datamol pip install -e . Setup a dev environment with dev container \u00b6 This repository is setup to use dev container . You can use it locally with VSCode or any editor supporting dev containers as well as on GitHub Codespaces. The env is based on the Micromamba Docker image. Continuous Integration \u00b6 Datamol uses Github Actions to: Build and test datamol . Multiple combinations of OS, Python and RDKit versions are tested. Check the code: Formatting with black . Static type check with mypy . Documentation : build and deploy the documentation on main and for every new git tag. Run tests \u00b6 pytest Build the documentation \u00b6 You can build and serve the documentation locally with: # Build and serve the doc mike serve Multi-versionning \u00b6 The doc is built for eash push on main and every git tags using mike . Everything is automated using Github Actions. Please refer to the official mike's documentation for the details. Release a new version \u00b6 Run check: rever check . Bump and release new version: rever VERSION_NUMBER . Releasing a new version will do the following things in that order: Update AUTHORS.rst . Update CHANGELOG.rst . Bump the version number in setup.py and _version.py . Add a git tag. Push the git tag. Add a new release on the GH repo associated with the git tag.","title":"Contribute"},{"location":"contribute.html#contribute","text":"The below documents the development lifecycle of Datamol.","title":"Contribute"},{"location":"contribute.html#setup-a-dev-environment","text":"mamba env create -n datamol -f env.yml conda activate datamol pip install -e .","title":"Setup a dev environment"},{"location":"contribute.html#setup-a-dev-environment-with-dev-container","text":"This repository is setup to use dev container . You can use it locally with VSCode or any editor supporting dev containers as well as on GitHub Codespaces. The env is based on the Micromamba Docker image.","title":"Setup a dev environment with dev container"},{"location":"contribute.html#continuous-integration","text":"Datamol uses Github Actions to: Build and test datamol . Multiple combinations of OS, Python and RDKit versions are tested. Check the code: Formatting with black . Static type check with mypy . Documentation : build and deploy the documentation on main and for every new git tag.","title":"Continuous Integration"},{"location":"contribute.html#run-tests","text":"pytest","title":"Run tests"},{"location":"contribute.html#build-the-documentation","text":"You can build and serve the documentation locally with: # Build and serve the doc mike serve","title":"Build the documentation"},{"location":"contribute.html#multi-versionning","text":"The doc is built for eash push on main and every git tags using mike . Everything is automated using Github Actions. Please refer to the official mike's documentation for the details.","title":"Multi-versionning"},{"location":"contribute.html#release-a-new-version","text":"Run check: rever check . Bump and release new version: rever VERSION_NUMBER . Releasing a new version will do the following things in that order: Update AUTHORS.rst . Update CHANGELOG.rst . Bump the version number in setup.py and _version.py . Add a git tag. Push the git tag. Add a new release on the GH repo associated with the git tag.","title":"Release a new version"},{"location":"license.html","text":"{!LICENSE!}","title":"License"},{"location":"usage.html","text":"Usage \u00b6 Datamol has been designed to be used with a single import: import datamol as dm All datamol functions are available under dm . Available modules \u00b6 dm : top-level module that contains common functions. dm.actions : functions to edit molecules. dm.conformers : generate and perform computation on conformers. dm.data : get some common data (mainly for dev purposes). dm.fragment : fragment molecules in a list of fragments. dm.reactions : functions to work with reactions. dm.scaffold : get representative scaffolds from a list of molecules. dm.viz : 2D/3D visualization functions.","title":"Usage"},{"location":"usage.html#usage","text":"Datamol has been designed to be used with a single import: import datamol as dm All datamol functions are available under dm .","title":"Usage"},{"location":"usage.html#available-modules","text":"dm : top-level module that contains common functions. dm.actions : functions to edit molecules. dm.conformers : generate and perform computation on conformers. dm.data : get some common data (mainly for dev purposes). dm.fragment : fragment molecules in a list of fragments. dm.reactions : functions to work with reactions. dm.scaffold : get representative scaffolds from a list of molecules. dm.viz : 2D/3D visualization functions.","title":"Available modules"},{"location":"api/datamol.align.html","text":"datamol.align \u00b6 align \u00b6 auto_align_many ( mols , partition_method = 'anon-scaffold' , copy = True , cluster_cutoff = 0.7 , allow_r_groups = True , ** kwargs ) \u00b6 Partition a list of molecules into clusters sharing common scaffold of common core, then align the molecules to that common core. This function will compute the list of smiles/smarts representative of each cluster first. The returned molecules will have two properties associated to them: dm.auto_align_many.cluster_id : the cluster id of the molecule. dm.auto_align_many.core : the smiles/smarts of the core of the cluster. Parameters: Name Type Description Default mols Union [ Sequence [ Mol ], pd . Series ] A list of molecules to auto align. required partition_method str Partition method to use: 'scaffold': Cluster molecules by Murcko scaffold. 'strip-scaffold': Cluster molecules by Murcko scaffold, but remove all atoms not in the core. 'anon-scaffold': Cluster molecules by Murcko scaffold, but making it generic including the bonds. 'anongraph-scaffold': Cluster molecules by Murcko scaffold, but making it generic but keeping the bond order informations. 'cluster': Cluster the molecules using Butina frm RDKit with dm.cluster_mols . Cautious as the method 'cluster' is very sensitive to the cutoff. 'anon-scaffold' copy bool Whether to copy the molecules before aligning them. True cluster_cutoff float Optional cluster cutoff. 0.7 allow_r_groups bool Optional, if True, terminal dummy atoms in the reference are ignored if they match an implicit hydrogen in the molecule, and a constrained depiction is still attempted True **kwargs Any Additional arguments to pass to clustering method {} Source code in datamol/align.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def auto_align_many ( mols : Union [ Sequence [ Mol ], pd . Series ], partition_method : str = \"anon-scaffold\" , copy : bool = True , cluster_cutoff : float = 0.7 , allow_r_groups : bool = True , ** kwargs : Any , ): \"\"\"Partition a list of molecules into clusters sharing common scaffold of common core, then align the molecules to that common core. This function will compute the list of smiles/smarts representative of each cluster first. The returned molecules will have two properties associated to them: - `dm.auto_align_many.cluster_id`: the cluster id of the molecule. - `dm.auto_align_many.core`: the smiles/smarts of the core of the cluster. Args: mols: A list of molecules to auto align. partition_method: Partition method to use: - 'scaffold': Cluster molecules by Murcko scaffold. - 'strip-scaffold': Cluster molecules by Murcko scaffold, but remove all atoms not in the core. - 'anon-scaffold': Cluster molecules by Murcko scaffold, but making it generic including the bonds. - 'anongraph-scaffold': Cluster molecules by Murcko scaffold, but making it generic but keeping the bond order informations. - 'cluster': Cluster the molecules using Butina frm RDKit with `dm.cluster_mols`. Cautious as the method 'cluster' is very sensitive to the cutoff. copy: Whether to copy the molecules before aligning them. cluster_cutoff: Optional cluster cutoff. allow_r_groups: Optional, if True, terminal dummy atoms in the reference are ignored if they match an implicit hydrogen in the molecule, and a constrained depiction is still attempted **kwargs: Additional arguments to pass to clustering method \"\"\" if copy : mols = [ dm . copy_mol ( mol ) for mol in mols ] mol_groups = ddict ( list ) # map scaffold index to list of unique molecules scaffold_mols = {} if partition_method . endswith ( \"scaffold\" ): scaffolds = [ dm . to_scaffold_murcko ( m ) for m in mols ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] if partition_method . startswith ( \"strip-\" ): scaffolds = [ dm . strip_mol_to_core ( x ) for x in scaffolds ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] elif partition_method . startswith ( \"anongraph-\" ): scaffolds = [ dm . make_scaffold_generic ( s , include_bonds = True ) for s in scaffolds ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] elif partition_method . startswith ( \"anon-\" ): scaffolds = [ dm . make_scaffold_generic ( s , include_bonds = False ) for s in scaffolds ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] for i , s in enumerate ( scaffolds_ids ): mol_groups [ s ] . append ( i ) scaffolds [ i ] = compute_2d_coords ( scaffolds [ i ]) scaffold_mols [ s ] = scaffolds [ i ] elif partition_method == \"cluster\" : # partition is cluster, first compute molecule clusters clusters , mol_clusters = dm . cluster_mols ( mols , cutoff = cluster_cutoff , ** kwargs ) # now compute the mcs for each clusters cluster_mcs = [ ( dm . find_mcs ( mol_cluster ) if len ( mol_cluster ) > 1 else dm . to_smiles ( mol_cluster [ 0 ])) for mol_cluster in mol_clusters ] scaffolds_ids = [ cluster_mcs [ cluster_id ] for cluster_id , _ in enumerate ( clusters )] for i , s in enumerate ( scaffolds_ids ): mol_groups [ s ] . extend ( clusters [ i ]) for x in scaffolds_ids : core = None if x is not None : core = dm . from_smarts ( x ) core = compute_2d_coords ( core ) scaffold_mols [ x ] = core else : raise ValueError ( f \"Unknown partition method: { partition_method } \" ) # now we match each molecule to the scaffold and align them # note that the molecule object will be modified in place in the list for cluster_id , ( core , mols_ids ) in enumerate ( mol_groups . items ()): core_mol = scaffold_mols [ core ] for mol_id in mols_ids : mol = mols [ mol_id ] if core_mol is not None : # Only pass allowRGroups if current # rdkit version is >= 2021_03_1 # ref https://github.com/rdkit/rdkit/pull/3811 allowRGroups = ( { \"allowRGroups\" : allow_r_groups } if version . parse ( rdkit . __version__ ) >= version . parse ( \"2021.03.1\" ) else {} ) rdDepictor . GenerateDepictionMatching2DStructure ( mol , reference = core_mol , acceptFailure = True , ** allowRGroups , ) # Add some props to the mol so the user can retrieve the groups from # it later. props = {} props [ \"dm.auto_align_many.cluster_id\" ] = cluster_id props [ \"dm.auto_align_many.core\" ] = core dm . set_mol_props ( mol , props ) # EN: you can discard the mol_groups (or keep it and match the values # to molecular line notation, so you will not have to reocompute the above) # and convert the mols into cxsmiles if you want # return mols, mol_groups return mols compute_2d_coords ( mol , copy = True , verbose = False ) \u00b6 Compute 2D coordinates for a molecule. Parameters: Name Type Description Default mol Mol A molecule. required copy bool Whether to copy the molecule. True Source code in datamol/align.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def compute_2d_coords ( mol : Mol , copy : bool = True , verbose : bool = False ) -> Mol : \"\"\"Compute 2D coordinates for a molecule. Args: mol: A molecule. copy: Whether to copy the molecule. \"\"\" if copy : mol = dm . copy_mol ( mol ) with dm . without_rdkit_log ( enable = not verbose ): rdDepictor . Compute2DCoords ( mol ) return mol template_align ( mol , template = None , copy = True , use_depiction = True , remove_confs = True , auto_select_coord_gen = False ) \u00b6 Align an input molecule to a template. If the template is not provided then the input molecule is returned. Parameters: Name Type Description Default mol Union [ str , Mol ] A molecule. required template Optional [ Union [ str , Mol ]] Template to align to. None copy bool whether to copy the molecule before aligning it. True use_depiction bool Whether to use the depiction API or use MolAlign The main difference is around how 3D information is handled, but also, because the depiction API will emphasize the atoms that do not match, whereas AlignMol will not. True remove_confs bool Whether to remove all conformation in the input molecule first. You can set this to true when not using depiction True auto_select_coord_gen bool Whether to automatically select the coordinate generation method. False Returns: Name Type Description mol Optional [ Mol ] aligned molecule (dm.Mol). None if initial mol argument is undefined or invalid. Source code in datamol/align.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def template_align ( mol : Union [ str , Mol ], template : Optional [ Union [ str , Mol ]] = None , copy : bool = True , use_depiction : bool = True , remove_confs : bool = True , auto_select_coord_gen : bool = False , ) -> Optional [ Mol ]: \"\"\"Align an input molecule to a template. If the template is not provided then the input molecule is returned. Args: mol: A molecule. template: Template to align to. copy: whether to copy the molecule before aligning it. use_depiction: Whether to use the depiction API or use MolAlign The main difference is around how 3D information is handled, but also, because the depiction API will emphasize the atoms that do not match, whereas AlignMol will not. remove_confs: Whether to remove all conformation in the input molecule first. You can set this to true when not using depiction auto_select_coord_gen: Whether to automatically select the coordinate generation method. Returns: mol: aligned molecule (dm.Mol). None if initial mol argument is undefined or invalid. \"\"\" if isinstance ( mol , str ): _mol = dm . to_mol ( mol ) elif copy : _mol = dm . copy_mol ( mol ) else : _mol = mol if _mol is None : return None if isinstance ( template , str ): _template = dm . to_mol ( template ) elif copy : _template = dm . copy_mol ( template ) else : _template = template if _template is None : return _mol if remove_confs : _mol . RemoveAllConformers () # EN: to make this more general and robust, we need to first check whether the template # has 2D coordinates or not. If it does not, we need to compute them. # This is a very rare edge case if requests are comming from the UI, but better to check than not xD if _template . GetNumConformers () == 0 : _template = compute_2d_coords ( _template ) # EN: now we can align the molecule to the template # but first, we should avoid MCS as much as possible, because it's expensive # so if the template is a subgraph of the molecule, no need to perform any MCS # Another reason for this, is to avoid inconsistency in alignment between molecules that are # supergraph of the template vs molecules that are subgraph of the template. pattern = _template if not _mol . HasSubstructMatch ( _template ): pattern = None mcs_smarts = dm . find_mcs ([ _mol , _template ]) if mcs_smarts is not None : pattern = dm . from_smarts ( mcs_smarts ) if pattern is not None : if auto_select_coord_gen : rdDepictor . SetPreferCoordGen ( use_depiction ) # we would need to compute 2d coordinates for the molecules if it doesn't have any if _mol . GetNumConformers () == 0 : _mol = compute_2d_coords ( _mol ) if use_depiction : rdDepictor . GenerateDepictionMatching2DStructure ( _mol , reference = _template , refPatt = pattern , acceptFailure = True , allowRGroups = True , ) else : query_match = _mol . GetSubstructMatch ( pattern ) template_match = _template . GetSubstructMatch ( pattern ) rdMolAlign . AlignMol ( _mol , _template , atomMap = list ( zip ( query_match , template_match ))) return _mol","title":"datamol.align"},{"location":"api/datamol.align.html#datamolalign","text":"","title":"datamol.align"},{"location":"api/datamol.align.html#datamol.align","text":"","title":"align"},{"location":"api/datamol.align.html#datamol.align.auto_align_many","text":"Partition a list of molecules into clusters sharing common scaffold of common core, then align the molecules to that common core. This function will compute the list of smiles/smarts representative of each cluster first. The returned molecules will have two properties associated to them: dm.auto_align_many.cluster_id : the cluster id of the molecule. dm.auto_align_many.core : the smiles/smarts of the core of the cluster. Parameters: Name Type Description Default mols Union [ Sequence [ Mol ], pd . Series ] A list of molecules to auto align. required partition_method str Partition method to use: 'scaffold': Cluster molecules by Murcko scaffold. 'strip-scaffold': Cluster molecules by Murcko scaffold, but remove all atoms not in the core. 'anon-scaffold': Cluster molecules by Murcko scaffold, but making it generic including the bonds. 'anongraph-scaffold': Cluster molecules by Murcko scaffold, but making it generic but keeping the bond order informations. 'cluster': Cluster the molecules using Butina frm RDKit with dm.cluster_mols . Cautious as the method 'cluster' is very sensitive to the cutoff. 'anon-scaffold' copy bool Whether to copy the molecules before aligning them. True cluster_cutoff float Optional cluster cutoff. 0.7 allow_r_groups bool Optional, if True, terminal dummy atoms in the reference are ignored if they match an implicit hydrogen in the molecule, and a constrained depiction is still attempted True **kwargs Any Additional arguments to pass to clustering method {} Source code in datamol/align.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def auto_align_many ( mols : Union [ Sequence [ Mol ], pd . Series ], partition_method : str = \"anon-scaffold\" , copy : bool = True , cluster_cutoff : float = 0.7 , allow_r_groups : bool = True , ** kwargs : Any , ): \"\"\"Partition a list of molecules into clusters sharing common scaffold of common core, then align the molecules to that common core. This function will compute the list of smiles/smarts representative of each cluster first. The returned molecules will have two properties associated to them: - `dm.auto_align_many.cluster_id`: the cluster id of the molecule. - `dm.auto_align_many.core`: the smiles/smarts of the core of the cluster. Args: mols: A list of molecules to auto align. partition_method: Partition method to use: - 'scaffold': Cluster molecules by Murcko scaffold. - 'strip-scaffold': Cluster molecules by Murcko scaffold, but remove all atoms not in the core. - 'anon-scaffold': Cluster molecules by Murcko scaffold, but making it generic including the bonds. - 'anongraph-scaffold': Cluster molecules by Murcko scaffold, but making it generic but keeping the bond order informations. - 'cluster': Cluster the molecules using Butina frm RDKit with `dm.cluster_mols`. Cautious as the method 'cluster' is very sensitive to the cutoff. copy: Whether to copy the molecules before aligning them. cluster_cutoff: Optional cluster cutoff. allow_r_groups: Optional, if True, terminal dummy atoms in the reference are ignored if they match an implicit hydrogen in the molecule, and a constrained depiction is still attempted **kwargs: Additional arguments to pass to clustering method \"\"\" if copy : mols = [ dm . copy_mol ( mol ) for mol in mols ] mol_groups = ddict ( list ) # map scaffold index to list of unique molecules scaffold_mols = {} if partition_method . endswith ( \"scaffold\" ): scaffolds = [ dm . to_scaffold_murcko ( m ) for m in mols ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] if partition_method . startswith ( \"strip-\" ): scaffolds = [ dm . strip_mol_to_core ( x ) for x in scaffolds ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] elif partition_method . startswith ( \"anongraph-\" ): scaffolds = [ dm . make_scaffold_generic ( s , include_bonds = True ) for s in scaffolds ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] elif partition_method . startswith ( \"anon-\" ): scaffolds = [ dm . make_scaffold_generic ( s , include_bonds = False ) for s in scaffolds ] scaffolds_ids = [ dm . to_smiles ( x ) for x in scaffolds ] for i , s in enumerate ( scaffolds_ids ): mol_groups [ s ] . append ( i ) scaffolds [ i ] = compute_2d_coords ( scaffolds [ i ]) scaffold_mols [ s ] = scaffolds [ i ] elif partition_method == \"cluster\" : # partition is cluster, first compute molecule clusters clusters , mol_clusters = dm . cluster_mols ( mols , cutoff = cluster_cutoff , ** kwargs ) # now compute the mcs for each clusters cluster_mcs = [ ( dm . find_mcs ( mol_cluster ) if len ( mol_cluster ) > 1 else dm . to_smiles ( mol_cluster [ 0 ])) for mol_cluster in mol_clusters ] scaffolds_ids = [ cluster_mcs [ cluster_id ] for cluster_id , _ in enumerate ( clusters )] for i , s in enumerate ( scaffolds_ids ): mol_groups [ s ] . extend ( clusters [ i ]) for x in scaffolds_ids : core = None if x is not None : core = dm . from_smarts ( x ) core = compute_2d_coords ( core ) scaffold_mols [ x ] = core else : raise ValueError ( f \"Unknown partition method: { partition_method } \" ) # now we match each molecule to the scaffold and align them # note that the molecule object will be modified in place in the list for cluster_id , ( core , mols_ids ) in enumerate ( mol_groups . items ()): core_mol = scaffold_mols [ core ] for mol_id in mols_ids : mol = mols [ mol_id ] if core_mol is not None : # Only pass allowRGroups if current # rdkit version is >= 2021_03_1 # ref https://github.com/rdkit/rdkit/pull/3811 allowRGroups = ( { \"allowRGroups\" : allow_r_groups } if version . parse ( rdkit . __version__ ) >= version . parse ( \"2021.03.1\" ) else {} ) rdDepictor . GenerateDepictionMatching2DStructure ( mol , reference = core_mol , acceptFailure = True , ** allowRGroups , ) # Add some props to the mol so the user can retrieve the groups from # it later. props = {} props [ \"dm.auto_align_many.cluster_id\" ] = cluster_id props [ \"dm.auto_align_many.core\" ] = core dm . set_mol_props ( mol , props ) # EN: you can discard the mol_groups (or keep it and match the values # to molecular line notation, so you will not have to reocompute the above) # and convert the mols into cxsmiles if you want # return mols, mol_groups return mols","title":"auto_align_many()"},{"location":"api/datamol.align.html#datamol.align.compute_2d_coords","text":"Compute 2D coordinates for a molecule. Parameters: Name Type Description Default mol Mol A molecule. required copy bool Whether to copy the molecule. True Source code in datamol/align.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def compute_2d_coords ( mol : Mol , copy : bool = True , verbose : bool = False ) -> Mol : \"\"\"Compute 2D coordinates for a molecule. Args: mol: A molecule. copy: Whether to copy the molecule. \"\"\" if copy : mol = dm . copy_mol ( mol ) with dm . without_rdkit_log ( enable = not verbose ): rdDepictor . Compute2DCoords ( mol ) return mol","title":"compute_2d_coords()"},{"location":"api/datamol.align.html#datamol.align.template_align","text":"Align an input molecule to a template. If the template is not provided then the input molecule is returned. Parameters: Name Type Description Default mol Union [ str , Mol ] A molecule. required template Optional [ Union [ str , Mol ]] Template to align to. None copy bool whether to copy the molecule before aligning it. True use_depiction bool Whether to use the depiction API or use MolAlign The main difference is around how 3D information is handled, but also, because the depiction API will emphasize the atoms that do not match, whereas AlignMol will not. True remove_confs bool Whether to remove all conformation in the input molecule first. You can set this to true when not using depiction True auto_select_coord_gen bool Whether to automatically select the coordinate generation method. False Returns: Name Type Description mol Optional [ Mol ] aligned molecule (dm.Mol). None if initial mol argument is undefined or invalid. Source code in datamol/align.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def template_align ( mol : Union [ str , Mol ], template : Optional [ Union [ str , Mol ]] = None , copy : bool = True , use_depiction : bool = True , remove_confs : bool = True , auto_select_coord_gen : bool = False , ) -> Optional [ Mol ]: \"\"\"Align an input molecule to a template. If the template is not provided then the input molecule is returned. Args: mol: A molecule. template: Template to align to. copy: whether to copy the molecule before aligning it. use_depiction: Whether to use the depiction API or use MolAlign The main difference is around how 3D information is handled, but also, because the depiction API will emphasize the atoms that do not match, whereas AlignMol will not. remove_confs: Whether to remove all conformation in the input molecule first. You can set this to true when not using depiction auto_select_coord_gen: Whether to automatically select the coordinate generation method. Returns: mol: aligned molecule (dm.Mol). None if initial mol argument is undefined or invalid. \"\"\" if isinstance ( mol , str ): _mol = dm . to_mol ( mol ) elif copy : _mol = dm . copy_mol ( mol ) else : _mol = mol if _mol is None : return None if isinstance ( template , str ): _template = dm . to_mol ( template ) elif copy : _template = dm . copy_mol ( template ) else : _template = template if _template is None : return _mol if remove_confs : _mol . RemoveAllConformers () # EN: to make this more general and robust, we need to first check whether the template # has 2D coordinates or not. If it does not, we need to compute them. # This is a very rare edge case if requests are comming from the UI, but better to check than not xD if _template . GetNumConformers () == 0 : _template = compute_2d_coords ( _template ) # EN: now we can align the molecule to the template # but first, we should avoid MCS as much as possible, because it's expensive # so if the template is a subgraph of the molecule, no need to perform any MCS # Another reason for this, is to avoid inconsistency in alignment between molecules that are # supergraph of the template vs molecules that are subgraph of the template. pattern = _template if not _mol . HasSubstructMatch ( _template ): pattern = None mcs_smarts = dm . find_mcs ([ _mol , _template ]) if mcs_smarts is not None : pattern = dm . from_smarts ( mcs_smarts ) if pattern is not None : if auto_select_coord_gen : rdDepictor . SetPreferCoordGen ( use_depiction ) # we would need to compute 2d coordinates for the molecules if it doesn't have any if _mol . GetNumConformers () == 0 : _mol = compute_2d_coords ( _mol ) if use_depiction : rdDepictor . GenerateDepictionMatching2DStructure ( _mol , reference = _template , refPatt = pattern , acceptFailure = True , allowRGroups = True , ) else : query_match = _mol . GetSubstructMatch ( pattern ) template_match = _template . GetSubstructMatch ( pattern ) rdMolAlign . AlignMol ( _mol , _template , atomMap = list ( zip ( query_match , template_match ))) return _mol","title":"template_align()"},{"location":"api/datamol.conformers.html","text":"datamol.conformers \u00b6 _conformers \u00b6 align_conformers ( mols , ref_id = 0 , copy = True , conformer_id =- 1 , backend = 'crippenO3A' ) \u00b6 Align a list of molecules to a reference molecule. Note that using the O3A backend, hydrogens will be added at the beginning of the procedure and removed at the end of the procedure. Parameters: Name Type Description Default mols List [ Mol ] List of molecules to align. All the molecules must have a conformer. required ref_id int Index of the reference molecule. By default, the first molecule in the list will be used as reference. 0 copy bool Whether to copy the molecules before performing the alignement. True conformer_id int Conformer id to use. -1 backend str Backend to use to compute the alignment from crippenO3A , O3A . 'crippenO3A' Returns: Name Type Description mols list The aligned molecules. scores list The score of the alignement. Source code in datamol/conformers/_conformers.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def align_conformers ( mols : List [ Mol ], ref_id : int = 0 , copy : bool = True , conformer_id : int = - 1 , backend : str = \"crippenO3A\" , ) -> Tuple [ list , list ]: \"\"\"Align a list of molecules to a reference molecule. Note that using the `O3A` backend, hydrogens will be added at the beginning of the procedure and removed at the end of the procedure. Args: mols: List of molecules to align. All the molecules must have a conformer. ref_id: Index of the reference molecule. By default, the first molecule in the list will be used as reference. copy: Whether to copy the molecules before performing the alignement. conformer_id: Conformer id to use. backend: Backend to use to compute the alignment from `crippenO3A`, `O3A`. Returns: mols: The aligned molecules. scores: The score of the alignement. \"\"\" allowed_backends = [ \"crippenO3A\" , \"O3A\" ] if backend not in allowed_backends : raise ValueError ( f \"The backend ' { backend } ' is not supported. Choose from: { allowed_backends } \" ) # Check all input molecules has a conformer if not all ([ mol . GetNumConformers () >= 1 for mol in mols ]): raise ValueError ( \"One or more input molecules is missing a conformer.\" ) # Make a copy of the molecules since they are going to be modified if copy : mols = [ dm_mol . copy_mol ( mol ) for mol in mols ] # Split ref and probe mols mol_ref = mols [ ref_id ] mol_probes = mols if backend == \"crippenO3A\" : # Compute Crippen contributions for every atoms and molecules crippen_contribs = [ rdMolDescriptors . _CalcCrippenContribs ( mol ) for mol in mol_probes ] crippen_contrib_ref = crippen_contribs [ ref_id ] crippen_contrib_probes = crippen_contribs # Loop and align # NOTE(hadim): we could eventually parallelize this if that's needed. scores = [] for i , mol in enumerate ( mol_probes ): crippenO3A = rdMolAlign . GetCrippenO3A ( prbMol = mol , refMol = mol_ref , prbCrippenContribs = crippen_contrib_probes [ i ], refCrippenContribs = crippen_contrib_ref , prbCid = conformer_id , refCid = conformer_id , maxIters = 50 , ) crippenO3A . Align () scores . append ( crippenO3A . Score ()) elif backend == \"O3A\" : # Add hydrogens first mol_probes = [ dm_mol . add_hs ( mol , add_coords = True ) for mol in mol_probes ] mol_ref = dm_mol . add_hs ( mol_ref , add_coords = True ) # Compute MMFF params for every molecules mmff_params = [ rdForceFieldHelpers . MMFFGetMoleculeProperties ( mol ) for mol in mol_probes ] # Split reference and probe molecules mmff_params_ref = mmff_params [ ref_id ] mmff_params_probes = mmff_params # Loop and align # NOTE(hadim): we could eventually parallelize this if that's needed. scores = [] for i , mol in enumerate ( mol_probes ): pyO3A = rdMolAlign . GetO3A ( prbMol = mol , refMol = mol_ref , prbPyMMFFMolProperties = mmff_params_probes [ i ], refPyMMFFMolProperties = mmff_params_ref , prbCid = conformer_id , refCid = conformer_id , maxIters = 50 , ) pyO3A . Align () scores . append ( pyO3A . Score ()) # Remove the hydrogens mol_probes = [ dm_mol . remove_hs ( mol ) for mol in mol_probes ] else : raise ValueError ( f \"Backend { backend } not supported.\" ) scores = np . array ( scores ) return mol_probes , scores cluster ( mol , rms_cutoff = 1 , already_aligned = False , centroids = True ) \u00b6 Cluster the conformers of a molecule according to an RMS threshold in Angstrom. Parameters: Name Type Description Default mol Mol a molecule required rms_cutoff float The RMS cutoff in Angstrom. 1 already_aligned bool Whether or not the conformers are aligned. If False, they will be aligmned furing the RMS computation. False centroids bool If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. Defaults to True. True Source code in datamol/conformers/_conformers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def cluster ( mol : Mol , rms_cutoff : float = 1 , already_aligned : bool = False , centroids : bool = True , ): \"\"\"Cluster the conformers of a molecule according to an RMS threshold in Angstrom. Args: mol: a molecule rms_cutoff: The RMS cutoff in Angstrom. already_aligned: Whether or not the conformers are aligned. If False, they will be aligmned furing the RMS computation. centroids: If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. Defaults to True. \"\"\" # Clone molecule mol = copy . deepcopy ( mol ) # Compute RMS dmat = AllChem . GetConformerRMSMatrix ( mol , prealigned = already_aligned ) # Cluster conf_clusters = Butina . ClusterData ( dmat , nPts = mol . GetNumConformers (), distThresh = rms_cutoff , isDistData = True , reordering = False , ) return return_centroids ( mol , conf_clusters , centroids = centroids ) generate ( mol , n_confs = None , use_random_coords = True , enforce_chirality = True , num_threads = 1 , rms_cutoff = None , clear_existing = True , align_conformers = True , minimize_energy = False , sort_by_energy = True , method = None , forcefield = 'UFF' , ewindow = np . inf , eratio = np . inf , energy_iterations = 200 , warning_not_converged = 0 , random_seed = 19 , add_hs = True , ignore_failure = False , embed_params = None , verbose = False ) \u00b6 Compute conformers of a molecule. Example: import datamol as dm smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm . to_mol ( smiles ) mol = dm . conformers . generate ( mol ) # Get all conformers as a list conformers = mol . GetConformers () # Get the 3D atom positions of the first conformer positions = mol . GetConformer ( 0 ) . GetPositions () # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol . GetConformer ( 1 ) props = conf . GetPropsAsDict () print ( props ) # {'rdkit_UFF_energy': 35.64074017773132,'rdkit_UFF_delta_energy': 0.24682258222552633} Parameters: Name Type Description Default mol Mol a molecule required n_confs Optional [ int ] Number of conformers to generate. Depends on the number of rotatable bonds by default: 50 for <8, 200 for <12 and 300 for >12. None use_random_coords bool Start the embedding from random coordinates instead of using eigenvalues of the distance matrix. True enforce_chirality bool Enforce correct chirilaty if chiral centers are present. True num_threads int Number of threads to use when embedding multiple conformations. 1 rms_cutoff Optional [ float ] The minimum RMS value in Angstrom at which two conformers are considered redundant and one is deleted. If None, all conformers are kept. This step is done after an eventual minimization step. None clear_existing bool Whether to overwrite existing conformers for the molecule. True align_conformers bool Whether to align the conformers. True minimize_energy bool Whether to minimize conformer's energies using MMFF94s. Disable to generate conformers much faster. False sort_by_energy bool Sort conformers by energy when minimizing is turned to False. True method Optional [ str ] RDKit method to use for embedding. Choose among [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]. If None, \"ETKDGv3\" is used. None forcefield str molecular forcefield to use, one of ['UFF','MMFF94S','MMFF94s_noEstat'] 'UFF' ewindow float maximum energy above minimum energy conformer to output np.inf eratio float max delta-energy divided by rotatable bonds for conformers np.inf energy_iterations int Maximum number of iterations during the energy minimization procedure. It corresponds to the maxIters argument in RDKit. 200 warning_not_converged int Wether to log a warning when the number of not converged conformers during the minimization is higher than warning_not_converged . Only works when verbose is set to True. Disable with 0. Defaults to 10. 0 random_seed int Set to None or -1 to disable. 19 add_hs bool Whether to add hydrogens to the mol before embedding. If set to True, the hydrogens are removed in the returned molecule. Warning: explicit hydrogens won't be conserved. It is strongly recommended to let the default value to True. The RDKit documentation says: \"To get good 3D conformations, it's almost always a good idea to add hydrogens to the molecule first.\" True ignore_failure bool It set to True, this will avoid raising an error when the embedding fails and return None instead. False embed_params Optional [ dict ] Allows the user to specify arbitrary embedding parameters for the conformers. This will override any other default settings. See https://www.rdkit.org/docs/source/rdkit.Chem.rdDistGeom.html#rdkit.Chem.rdDistGeom.EmbedParameters for more details. None verbose bool Wether to enable logs during the process. False Returns: Name Type Description mol Mol the molecule with the conformers. Source code in datamol/conformers/_conformers.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def generate ( mol : Mol , n_confs : Optional [ int ] = None , use_random_coords : bool = True , enforce_chirality : bool = True , num_threads : int = 1 , rms_cutoff : Optional [ float ] = None , clear_existing : bool = True , align_conformers : bool = True , minimize_energy : bool = False , sort_by_energy : bool = True , method : Optional [ str ] = None , forcefield : str = \"UFF\" , ewindow : float = np . inf , eratio : float = np . inf , energy_iterations : int = 200 , warning_not_converged : int = 0 , random_seed : int = 19 , add_hs : bool = True , ignore_failure : bool = False , embed_params : Optional [ dict ] = None , verbose : bool = False , ) -> Mol : \"\"\"Compute conformers of a molecule. Example: ```python import datamol as dm smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm.to_mol(smiles) mol = dm.conformers.generate(mol) # Get all conformers as a list conformers = mol.GetConformers() # Get the 3D atom positions of the first conformer positions = mol.GetConformer(0).GetPositions() # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol.GetConformer(1) props = conf.GetPropsAsDict() print(props) # {'rdkit_UFF_energy': 35.64074017773132,'rdkit_UFF_delta_energy': 0.24682258222552633} ``` Args: mol: a molecule n_confs: Number of conformers to generate. Depends on the number of rotatable bonds by default: 50 for <8, 200 for <12 and 300 for >12. use_random_coords: Start the embedding from random coordinates instead of using eigenvalues of the distance matrix. enforce_chirality: Enforce correct chirilaty if chiral centers are present. num_threads: Number of threads to use when embedding multiple conformations. rms_cutoff: The minimum RMS value in Angstrom at which two conformers are considered redundant and one is deleted. If None, all conformers are kept. This step is done after an eventual minimization step. clear_existing: Whether to overwrite existing conformers for the molecule. align_conformers: Whether to align the conformers. minimize_energy: Whether to minimize conformer's energies using MMFF94s. Disable to generate conformers much faster. sort_by_energy: Sort conformers by energy when minimizing is turned to False. method: RDKit method to use for embedding. Choose among [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]. If None, \"ETKDGv3\" is used. forcefield: molecular forcefield to use, one of ['UFF','MMFF94S','MMFF94s_noEstat'] ewindow: maximum energy above minimum energy conformer to output eratio: max delta-energy divided by rotatable bonds for conformers energy_iterations: Maximum number of iterations during the energy minimization procedure. It corresponds to the `maxIters` argument in RDKit. warning_not_converged: Wether to log a warning when the number of not converged conformers during the minimization is higher than `warning_not_converged`. Only works when `verbose` is set to True. Disable with 0. Defaults to 10. random_seed: Set to None or -1 to disable. add_hs: Whether to add hydrogens to the mol before embedding. If set to True, the hydrogens are removed in the returned molecule. Warning: explicit hydrogens won't be conserved. It is strongly recommended to let the default value to True. The RDKit documentation says: \"To get good 3D conformations, it's almost always a good idea to add hydrogens to the molecule first.\" ignore_failure: It set to True, this will avoid raising an error when the embedding fails and return None instead. embed_params: Allows the user to specify arbitrary embedding parameters for the conformers. This will override any other default settings. See https://www.rdkit.org/docs/source/rdkit.Chem.rdDistGeom.html#rdkit.Chem.rdDistGeom.EmbedParameters for more details. verbose: Wether to enable logs during the process. Returns: mol: the molecule with the conformers. \"\"\" AVAILABLE_METHODS = [ \"ETDG\" , \"ETKDG\" , \"ETKDGv2\" , \"ETKDGv3\" ] if method is None : method = \"ETKDGv3\" if method not in AVAILABLE_METHODS : raise ValueError ( f \"The method { method } is not supported. Use from { AVAILABLE_METHODS } \" ) # Random seed if random_seed is None : random_seed = - 1 # Clone molecule mol = copy . deepcopy ( mol ) # Remove existing conformers if clear_existing : mol . RemoveAllConformers () # Add hydrogens if add_hs : mol = dm_mol . add_hs ( mol ) rotatable_bonds = descriptors . n_rotatable_bonds ( mol ) if not n_confs : # Set the number of conformers depends on # the number of rotatable bonds. if rotatable_bonds < 8 : n_confs = 50 elif rotatable_bonds < 12 : n_confs = 200 else : n_confs = 300 # Setup the parameters for the embedding params = getattr ( rdDistGeom , method )() params . randomSeed = random_seed params . enforceChirality = enforce_chirality params . useRandomCoords = use_random_coords params . numThreads = num_threads if embed_params is not None : for k , v in embed_params . items (): setattr ( params , k , v ) # Embed conformers confs = rdDistGeom . EmbedMultipleConfs ( mol , numConfs = n_confs , params = params ) if len ( confs ) == 0 : if ignore_failure : if verbose : logger . warning ( f \"Conformers embedding failed for { convert . to_smiles ( mol ) } . Returning None because ignore_failure is set.\" ) return None raise ValueError ( f \"Conformers embedding failed for { convert . to_smiles ( mol ) } \" ) energies = None # Minimize energy if minimize_energy : # Minimize conformer's energy using MMFF ff = _get_ff ( mol , forcefield ) results = rdForceFieldHelpers . OptimizeMoleculeConfs ( mol , ff , maxIters = energy_iterations , numThreads = num_threads ) energies = [ energy for _ , energy in results ] # Some conformers might not have converged during minimization. not_converged = sum ([ not_converged for not_converged , _ in results if not_converged ]) if warning_not_converged != 0 and not_converged > warning_not_converged and verbose : logger . warning ( f \" { not_converged } / { len ( results ) } conformers have not converged for { convert . to_smiles ( mol ) } \" ) elif sort_by_energy : energies = [] for conf in mol . GetConformers (): ff = _get_ff ( mol , forcefield , conf_id = conf . GetId ()) energies . append ( ff . CalcEnergy ()) energies = np . array ( energies ) if energies is not None : minE = np . min ( energies ) # Add the energy as a property to each conformers [ ( conf . SetDoubleProp ( f \"rdkit_ { forcefield } _energy\" , energy ), conf . SetDoubleProp ( f \"rdkit_ { forcefield } _delta_energy\" , energy - minE ), ) for energy , conf in zip ( energies , mol . GetConformers ()) ] # Now we reorder conformers according to their energies, # so the lowest energies conformers are first. eliminate conformers that exceed ewindow, eratio mol_clone = copy . deepcopy ( mol ) ordered_conformers = [ conf for E , conf in sorted ( zip ( energies , mol_clone . GetConformers ()), key = lambda x : x [ 0 ]) if E - minE <= ewindow and ( E - minE ) / rotatable_bonds <= eratio ] mol . RemoveAllConformers () [ mol . AddConformer ( conf , assignId = True ) for conf in ordered_conformers ] # Align conformers to each others if align_conformers : rdMolAlign . AlignMolConformers ( mol ) if rms_cutoff is not None : mol = cluster ( mol , rms_cutoff = rms_cutoff , already_aligned = align_conformers , centroids = True , ) # type: ignore if add_hs : mol = dm_mol . remove_hs ( mol ) return mol return_centroids ( mol , conf_clusters , centroids = True ) \u00b6 Given a list of cluster indices, return one single molecule with only the centroid of the clusters of a list of molecules per cluster. Parameters: Name Type Description Default mol Mol a molecule. required conf_clusters Sequence [ Sequence [ int ]] list of cluster indices. required centroids bool If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. True Source code in datamol/conformers/_conformers.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def return_centroids ( mol : Mol , conf_clusters : Sequence [ Sequence [ int ]], centroids : bool = True , ) -> Union [ List [ Mol ], Mol ]: \"\"\"Given a list of cluster indices, return one single molecule with only the centroid of the clusters of a list of molecules per cluster. Args: mol: a molecule. conf_clusters: list of cluster indices. centroids: If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. \"\"\" if centroids : # Collect centroid of each cluster (first element of the list) centroid_list = [ indices [ 0 ] for indices in conf_clusters ] # Keep only centroid conformers mol_clone = copy . deepcopy ( mol ) confs = [ mol_clone . GetConformers ()[ i ] for i in centroid_list ] mol . RemoveAllConformers () [ mol . AddConformer ( conf , assignId = True ) for conf in confs ] return mol else : # Create a new molecule for each cluster and add conformers to it. mols = [] for cluster in conf_clusters : m = copy . deepcopy ( mol ) m . RemoveAllConformers () [ m . AddConformer ( mol . GetConformer ( c ), assignId = True ) for c in cluster ] mols . append ( m ) return mols rmsd ( mol ) \u00b6 Compute the RMSD between all the conformers of a molecule. Parameters: Name Type Description Default mol Mol a molecule required Source code in datamol/conformers/_conformers.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def rmsd ( mol : Mol ) -> np . ndarray : \"\"\"Compute the RMSD between all the conformers of a molecule. Args: mol: a molecule \"\"\" if mol . GetNumConformers () <= 1 : raise ValueError ( \"The molecule has 0 or 1 conformer. You can generate conformers with `dm.conformers.generate(mol)`.\" ) n_confs = mol . GetNumConformers () rmsds = [] for i in range ( n_confs ): for j in range ( n_confs ): rmsd = rdMolAlign . AlignMol ( prbMol = mol , refMol = mol , prbCid = i , refCid = j ) rmsds . append ( rmsd ) return np . array ( rmsds ) . reshape ( n_confs , n_confs ) translate ( mol , new_centroid , conf_id =- 1 ) \u00b6 Move a given conformer of a molecule to a new position. The transformation is performed in place. Parameters: Name Type Description Default mol Mol the molecule. required new_centroid Union [ np . ndarray , List [ int ]] the new position to move to of shape [x, y, z] required conf_id int id of the conformer. -1 Source code in datamol/conformers/_conformers.py 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def translate ( mol : Mol , new_centroid : Union [ np . ndarray , List [ int ]], conf_id : int = - 1 ): \"\"\"Move a given conformer of a molecule to a new position. The transformation is performed in place. Args: mol: the molecule. new_centroid: the new position to move to of shape [x, y, z] conf_id: id of the conformer. \"\"\" # Get conformer conf = mol . GetConformer ( conf_id ) # Compute the vector for translation mol_center = rdMolTransforms . ComputeCentroid ( conf ) mol_center = np . array ([ mol_center . x , mol_center . y , mol_center . z ]) # Make the transformation matrix T = np . eye ( 4 ) T [: 3 , 3 ] = new_centroid - mol_center # Transform rdMolTransforms . TransformConformer ( conf , T ) _features \u00b6 center_of_mass ( mol , use_atoms = True , digits = None , conf_id =- 1 ) \u00b6 Compute the center of mass of a conformer of a molecule. Parameters: Name Type Description Default mol Mol a molecule required use_atoms bool Whether to compute the true center of mass or the geometrical center. True digits Optional [ int ] Number of digits to round to. None conf_id int the conformer id. -1 Returns cm: Center of mass or geometrical center Source code in datamol/conformers/_features.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def center_of_mass ( mol : Mol , use_atoms : bool = True , digits : Optional [ int ] = None , conf_id : int = - 1 , ) -> np . ndarray : \"\"\"Compute the center of mass of a conformer of a molecule. Args: mol: a molecule use_atoms: Whether to compute the true center of mass or the geometrical center. digits: Number of digits to round to. conf_id: the conformer id. Returns cm: Center of mass or geometrical center \"\"\" coords = get_coords ( mol , conf_id = conf_id ) atom_weight = np . ones (( coords . shape [ 0 ])) if use_atoms : atom_weight = np . array ([ atom . GetMass () for atom in mol . GetAtoms ()]) atom_weight = atom_weight [:, None ] atom_weight /= atom_weight . sum () center = ( coords * atom_weight ) . sum ( axis = 0 ) if digits is not None : center = center . round ( digits ) return center get_coords ( mol , conf_id =- 1 ) \u00b6 Get the coordinate of a conformer of a molecule. Parameters: Name Type Description Default mol Mol a molecule. required conf_id int a conformer id. -1 Source code in datamol/conformers/_features.py 86 87 88 89 90 91 92 93 94 95 96 97 98 def get_coords ( mol : Mol , conf_id : int = - 1 ): \"\"\"Get the coordinate of a conformer of a molecule. Args: mol: a molecule. conf_id: a conformer id. \"\"\" if mol . GetNumConformers () == 0 : raise ValueError ( \"Molecule does not have any conformers.\" ) conf = mol . GetConformer ( id = conf_id ) return conf . GetPositions () keep_conformers ( mol , indices_to_keep =- 1 , assign_id = True , copy = True ) \u00b6 Keep on the specified conformer(s) in indices_to_keep . Parameters: Name Type Description Default mol Mol A molecule. required indices_to_keep Union [ int , List [ int ]] A indice or a least of indices of conformers to keep. -1 assign_id bool Whether to assign the kept conformers an id or keep the original one. True copy bool Whether to copy the molecule or not. True Source code in datamol/conformers/_features.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def keep_conformers ( mol : Mol , indices_to_keep : Union [ int , List [ int ]] = - 1 , assign_id : bool = True , copy : bool = True , ): \"\"\"Keep on the specified conformer(s) in `indices_to_keep`. Args: mol: A molecule. indices_to_keep: A indice or a least of indices of conformers to keep. assign_id: Whether to assign the kept conformers an id or keep the original one. copy: Whether to copy the molecule or not. \"\"\" if copy : mol = copy_mol ( mol ) if not isinstance ( indices_to_keep , list ): indices_to_keep = [ indices_to_keep ] # Extract conformers to keep confs_to_keep = [ mol . GetConformer ( conf_id ) for conf_id in indices_to_keep ] # Copy current mol and remove all conformers mol2 = copy_mol ( mol ) mol2 . RemoveAllConformers () # Add conformers _ = [ mol2 . AddConformer ( conf , assignId = assign_id ) for conf in confs_to_keep ] # Cleanup mol = mol2 return mol sasa ( mol , conf_id = None , n_jobs = 1 ) \u00b6 Compute Solvent Accessible Surface Area of all the conformers using FreeSASA ( https://freesasa.github.io/ ). Values are returned as an array and also stored within each conformer as a property called rdkit_free_sasa . Example: smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm . to_mol ( smiles ) mol = dm . conformers . generate ( mol ) # Compute SASA for all the conformers without parallelization sasa_values = dm . conformers . sasa ( mol , conf_id = None , n_jobs = 1 ) # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol . GetConformer ( 0 ) props = conf . GetPropsAsDict () print ( props ) # {'rdkit_uff_energy': 1.7649408317784008} Parameters: Name Type Description Default mol Mol a molecule required conf_id Optional [ Union [ int , List [ int ]]] Id of the conformers to compute. If None, compute all. None n_jobs int Number of jobs for parallelization. Set to 1 to disable and -1 to use all cores. 1 Returns: Name Type Description mol np . ndarray the molecule with the conformers. Source code in datamol/conformers/_features.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @decorators . disable_on_os ( \"win\" ) def sasa ( mol : Mol , conf_id : Optional [ Union [ int , List [ int ]]] = None , n_jobs : int = 1 , ) -> np . ndarray : \"\"\"Compute Solvent Accessible Surface Area of all the conformers using FreeSASA (https://freesasa.github.io/). Values are returned as an array and also stored within each conformer as a property called `rdkit_free_sasa`. Example: ```python smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm.to_mol(smiles) mol = dm.conformers.generate(mol) # Compute SASA for all the conformers without parallelization sasa_values = dm.conformers.sasa(mol, conf_id=None, n_jobs=1) # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol.GetConformer(0) props = conf.GetPropsAsDict() print(props) # {'rdkit_uff_energy': 1.7649408317784008} ``` Args: mol: a molecule conf_id: Id of the conformers to compute. If None, compute all. n_jobs: Number of jobs for parallelization. Set to 1 to disable and -1 to use all cores. Returns: mol: the molecule with the conformers. \"\"\" from rdkit.Chem import rdFreeSASA if mol . GetNumConformers () == 0 : raise ValueError ( \"The molecule has 0 conformers. You can generate conformers with `dm.conformers.generate(mol)`.\" ) # Get Van der Waals radii (angstrom) radii = [ PERIODIC_TABLE . GetRvdw ( atom . GetAtomicNum ()) for atom in mol . GetAtoms ()] # Which conformers to compute conf_ids = [] if conf_id is None : # If None compute for all the conformers conf_ids = list ( range ( mol . GetNumConformers ())) # type: ignore elif isinstance ( conf_id , int ): conf_ids = [ conf_id ] else : conf_ids = conf_id # Compute solvent accessible surface area def _get_sasa ( i ): conf = mol . GetConformer ( i ) sasa = rdFreeSASA . CalcSASA ( mol , radii , confIdx = conf . GetId ()) conf . SetDoubleProp ( \"rdkit_free_sasa\" , sasa ) return sasa runner = JobRunner ( n_jobs = n_jobs ) sasa_values = runner ( _get_sasa , conf_ids ) return np . array ( sasa_values )","title":"datamol.conformers"},{"location":"api/datamol.conformers.html#datamolconformers","text":"","title":"datamol.conformers"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers","text":"","title":"_conformers"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.align_conformers","text":"Align a list of molecules to a reference molecule. Note that using the O3A backend, hydrogens will be added at the beginning of the procedure and removed at the end of the procedure. Parameters: Name Type Description Default mols List [ Mol ] List of molecules to align. All the molecules must have a conformer. required ref_id int Index of the reference molecule. By default, the first molecule in the list will be used as reference. 0 copy bool Whether to copy the molecules before performing the alignement. True conformer_id int Conformer id to use. -1 backend str Backend to use to compute the alignment from crippenO3A , O3A . 'crippenO3A' Returns: Name Type Description mols list The aligned molecules. scores list The score of the alignement. Source code in datamol/conformers/_conformers.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def align_conformers ( mols : List [ Mol ], ref_id : int = 0 , copy : bool = True , conformer_id : int = - 1 , backend : str = \"crippenO3A\" , ) -> Tuple [ list , list ]: \"\"\"Align a list of molecules to a reference molecule. Note that using the `O3A` backend, hydrogens will be added at the beginning of the procedure and removed at the end of the procedure. Args: mols: List of molecules to align. All the molecules must have a conformer. ref_id: Index of the reference molecule. By default, the first molecule in the list will be used as reference. copy: Whether to copy the molecules before performing the alignement. conformer_id: Conformer id to use. backend: Backend to use to compute the alignment from `crippenO3A`, `O3A`. Returns: mols: The aligned molecules. scores: The score of the alignement. \"\"\" allowed_backends = [ \"crippenO3A\" , \"O3A\" ] if backend not in allowed_backends : raise ValueError ( f \"The backend ' { backend } ' is not supported. Choose from: { allowed_backends } \" ) # Check all input molecules has a conformer if not all ([ mol . GetNumConformers () >= 1 for mol in mols ]): raise ValueError ( \"One or more input molecules is missing a conformer.\" ) # Make a copy of the molecules since they are going to be modified if copy : mols = [ dm_mol . copy_mol ( mol ) for mol in mols ] # Split ref and probe mols mol_ref = mols [ ref_id ] mol_probes = mols if backend == \"crippenO3A\" : # Compute Crippen contributions for every atoms and molecules crippen_contribs = [ rdMolDescriptors . _CalcCrippenContribs ( mol ) for mol in mol_probes ] crippen_contrib_ref = crippen_contribs [ ref_id ] crippen_contrib_probes = crippen_contribs # Loop and align # NOTE(hadim): we could eventually parallelize this if that's needed. scores = [] for i , mol in enumerate ( mol_probes ): crippenO3A = rdMolAlign . GetCrippenO3A ( prbMol = mol , refMol = mol_ref , prbCrippenContribs = crippen_contrib_probes [ i ], refCrippenContribs = crippen_contrib_ref , prbCid = conformer_id , refCid = conformer_id , maxIters = 50 , ) crippenO3A . Align () scores . append ( crippenO3A . Score ()) elif backend == \"O3A\" : # Add hydrogens first mol_probes = [ dm_mol . add_hs ( mol , add_coords = True ) for mol in mol_probes ] mol_ref = dm_mol . add_hs ( mol_ref , add_coords = True ) # Compute MMFF params for every molecules mmff_params = [ rdForceFieldHelpers . MMFFGetMoleculeProperties ( mol ) for mol in mol_probes ] # Split reference and probe molecules mmff_params_ref = mmff_params [ ref_id ] mmff_params_probes = mmff_params # Loop and align # NOTE(hadim): we could eventually parallelize this if that's needed. scores = [] for i , mol in enumerate ( mol_probes ): pyO3A = rdMolAlign . GetO3A ( prbMol = mol , refMol = mol_ref , prbPyMMFFMolProperties = mmff_params_probes [ i ], refPyMMFFMolProperties = mmff_params_ref , prbCid = conformer_id , refCid = conformer_id , maxIters = 50 , ) pyO3A . Align () scores . append ( pyO3A . Score ()) # Remove the hydrogens mol_probes = [ dm_mol . remove_hs ( mol ) for mol in mol_probes ] else : raise ValueError ( f \"Backend { backend } not supported.\" ) scores = np . array ( scores ) return mol_probes , scores","title":"align_conformers()"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.cluster","text":"Cluster the conformers of a molecule according to an RMS threshold in Angstrom. Parameters: Name Type Description Default mol Mol a molecule required rms_cutoff float The RMS cutoff in Angstrom. 1 already_aligned bool Whether or not the conformers are aligned. If False, they will be aligmned furing the RMS computation. False centroids bool If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. Defaults to True. True Source code in datamol/conformers/_conformers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def cluster ( mol : Mol , rms_cutoff : float = 1 , already_aligned : bool = False , centroids : bool = True , ): \"\"\"Cluster the conformers of a molecule according to an RMS threshold in Angstrom. Args: mol: a molecule rms_cutoff: The RMS cutoff in Angstrom. already_aligned: Whether or not the conformers are aligned. If False, they will be aligmned furing the RMS computation. centroids: If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. Defaults to True. \"\"\" # Clone molecule mol = copy . deepcopy ( mol ) # Compute RMS dmat = AllChem . GetConformerRMSMatrix ( mol , prealigned = already_aligned ) # Cluster conf_clusters = Butina . ClusterData ( dmat , nPts = mol . GetNumConformers (), distThresh = rms_cutoff , isDistData = True , reordering = False , ) return return_centroids ( mol , conf_clusters , centroids = centroids )","title":"cluster()"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.generate","text":"Compute conformers of a molecule. Example: import datamol as dm smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm . to_mol ( smiles ) mol = dm . conformers . generate ( mol ) # Get all conformers as a list conformers = mol . GetConformers () # Get the 3D atom positions of the first conformer positions = mol . GetConformer ( 0 ) . GetPositions () # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol . GetConformer ( 1 ) props = conf . GetPropsAsDict () print ( props ) # {'rdkit_UFF_energy': 35.64074017773132,'rdkit_UFF_delta_energy': 0.24682258222552633} Parameters: Name Type Description Default mol Mol a molecule required n_confs Optional [ int ] Number of conformers to generate. Depends on the number of rotatable bonds by default: 50 for <8, 200 for <12 and 300 for >12. None use_random_coords bool Start the embedding from random coordinates instead of using eigenvalues of the distance matrix. True enforce_chirality bool Enforce correct chirilaty if chiral centers are present. True num_threads int Number of threads to use when embedding multiple conformations. 1 rms_cutoff Optional [ float ] The minimum RMS value in Angstrom at which two conformers are considered redundant and one is deleted. If None, all conformers are kept. This step is done after an eventual minimization step. None clear_existing bool Whether to overwrite existing conformers for the molecule. True align_conformers bool Whether to align the conformers. True minimize_energy bool Whether to minimize conformer's energies using MMFF94s. Disable to generate conformers much faster. False sort_by_energy bool Sort conformers by energy when minimizing is turned to False. True method Optional [ str ] RDKit method to use for embedding. Choose among [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]. If None, \"ETKDGv3\" is used. None forcefield str molecular forcefield to use, one of ['UFF','MMFF94S','MMFF94s_noEstat'] 'UFF' ewindow float maximum energy above minimum energy conformer to output np.inf eratio float max delta-energy divided by rotatable bonds for conformers np.inf energy_iterations int Maximum number of iterations during the energy minimization procedure. It corresponds to the maxIters argument in RDKit. 200 warning_not_converged int Wether to log a warning when the number of not converged conformers during the minimization is higher than warning_not_converged . Only works when verbose is set to True. Disable with 0. Defaults to 10. 0 random_seed int Set to None or -1 to disable. 19 add_hs bool Whether to add hydrogens to the mol before embedding. If set to True, the hydrogens are removed in the returned molecule. Warning: explicit hydrogens won't be conserved. It is strongly recommended to let the default value to True. The RDKit documentation says: \"To get good 3D conformations, it's almost always a good idea to add hydrogens to the molecule first.\" True ignore_failure bool It set to True, this will avoid raising an error when the embedding fails and return None instead. False embed_params Optional [ dict ] Allows the user to specify arbitrary embedding parameters for the conformers. This will override any other default settings. See https://www.rdkit.org/docs/source/rdkit.Chem.rdDistGeom.html#rdkit.Chem.rdDistGeom.EmbedParameters for more details. None verbose bool Wether to enable logs during the process. False Returns: Name Type Description mol Mol the molecule with the conformers. Source code in datamol/conformers/_conformers.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def generate ( mol : Mol , n_confs : Optional [ int ] = None , use_random_coords : bool = True , enforce_chirality : bool = True , num_threads : int = 1 , rms_cutoff : Optional [ float ] = None , clear_existing : bool = True , align_conformers : bool = True , minimize_energy : bool = False , sort_by_energy : bool = True , method : Optional [ str ] = None , forcefield : str = \"UFF\" , ewindow : float = np . inf , eratio : float = np . inf , energy_iterations : int = 200 , warning_not_converged : int = 0 , random_seed : int = 19 , add_hs : bool = True , ignore_failure : bool = False , embed_params : Optional [ dict ] = None , verbose : bool = False , ) -> Mol : \"\"\"Compute conformers of a molecule. Example: ```python import datamol as dm smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm.to_mol(smiles) mol = dm.conformers.generate(mol) # Get all conformers as a list conformers = mol.GetConformers() # Get the 3D atom positions of the first conformer positions = mol.GetConformer(0).GetPositions() # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol.GetConformer(1) props = conf.GetPropsAsDict() print(props) # {'rdkit_UFF_energy': 35.64074017773132,'rdkit_UFF_delta_energy': 0.24682258222552633} ``` Args: mol: a molecule n_confs: Number of conformers to generate. Depends on the number of rotatable bonds by default: 50 for <8, 200 for <12 and 300 for >12. use_random_coords: Start the embedding from random coordinates instead of using eigenvalues of the distance matrix. enforce_chirality: Enforce correct chirilaty if chiral centers are present. num_threads: Number of threads to use when embedding multiple conformations. rms_cutoff: The minimum RMS value in Angstrom at which two conformers are considered redundant and one is deleted. If None, all conformers are kept. This step is done after an eventual minimization step. clear_existing: Whether to overwrite existing conformers for the molecule. align_conformers: Whether to align the conformers. minimize_energy: Whether to minimize conformer's energies using MMFF94s. Disable to generate conformers much faster. sort_by_energy: Sort conformers by energy when minimizing is turned to False. method: RDKit method to use for embedding. Choose among [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]. If None, \"ETKDGv3\" is used. forcefield: molecular forcefield to use, one of ['UFF','MMFF94S','MMFF94s_noEstat'] ewindow: maximum energy above minimum energy conformer to output eratio: max delta-energy divided by rotatable bonds for conformers energy_iterations: Maximum number of iterations during the energy minimization procedure. It corresponds to the `maxIters` argument in RDKit. warning_not_converged: Wether to log a warning when the number of not converged conformers during the minimization is higher than `warning_not_converged`. Only works when `verbose` is set to True. Disable with 0. Defaults to 10. random_seed: Set to None or -1 to disable. add_hs: Whether to add hydrogens to the mol before embedding. If set to True, the hydrogens are removed in the returned molecule. Warning: explicit hydrogens won't be conserved. It is strongly recommended to let the default value to True. The RDKit documentation says: \"To get good 3D conformations, it's almost always a good idea to add hydrogens to the molecule first.\" ignore_failure: It set to True, this will avoid raising an error when the embedding fails and return None instead. embed_params: Allows the user to specify arbitrary embedding parameters for the conformers. This will override any other default settings. See https://www.rdkit.org/docs/source/rdkit.Chem.rdDistGeom.html#rdkit.Chem.rdDistGeom.EmbedParameters for more details. verbose: Wether to enable logs during the process. Returns: mol: the molecule with the conformers. \"\"\" AVAILABLE_METHODS = [ \"ETDG\" , \"ETKDG\" , \"ETKDGv2\" , \"ETKDGv3\" ] if method is None : method = \"ETKDGv3\" if method not in AVAILABLE_METHODS : raise ValueError ( f \"The method { method } is not supported. Use from { AVAILABLE_METHODS } \" ) # Random seed if random_seed is None : random_seed = - 1 # Clone molecule mol = copy . deepcopy ( mol ) # Remove existing conformers if clear_existing : mol . RemoveAllConformers () # Add hydrogens if add_hs : mol = dm_mol . add_hs ( mol ) rotatable_bonds = descriptors . n_rotatable_bonds ( mol ) if not n_confs : # Set the number of conformers depends on # the number of rotatable bonds. if rotatable_bonds < 8 : n_confs = 50 elif rotatable_bonds < 12 : n_confs = 200 else : n_confs = 300 # Setup the parameters for the embedding params = getattr ( rdDistGeom , method )() params . randomSeed = random_seed params . enforceChirality = enforce_chirality params . useRandomCoords = use_random_coords params . numThreads = num_threads if embed_params is not None : for k , v in embed_params . items (): setattr ( params , k , v ) # Embed conformers confs = rdDistGeom . EmbedMultipleConfs ( mol , numConfs = n_confs , params = params ) if len ( confs ) == 0 : if ignore_failure : if verbose : logger . warning ( f \"Conformers embedding failed for { convert . to_smiles ( mol ) } . Returning None because ignore_failure is set.\" ) return None raise ValueError ( f \"Conformers embedding failed for { convert . to_smiles ( mol ) } \" ) energies = None # Minimize energy if minimize_energy : # Minimize conformer's energy using MMFF ff = _get_ff ( mol , forcefield ) results = rdForceFieldHelpers . OptimizeMoleculeConfs ( mol , ff , maxIters = energy_iterations , numThreads = num_threads ) energies = [ energy for _ , energy in results ] # Some conformers might not have converged during minimization. not_converged = sum ([ not_converged for not_converged , _ in results if not_converged ]) if warning_not_converged != 0 and not_converged > warning_not_converged and verbose : logger . warning ( f \" { not_converged } / { len ( results ) } conformers have not converged for { convert . to_smiles ( mol ) } \" ) elif sort_by_energy : energies = [] for conf in mol . GetConformers (): ff = _get_ff ( mol , forcefield , conf_id = conf . GetId ()) energies . append ( ff . CalcEnergy ()) energies = np . array ( energies ) if energies is not None : minE = np . min ( energies ) # Add the energy as a property to each conformers [ ( conf . SetDoubleProp ( f \"rdkit_ { forcefield } _energy\" , energy ), conf . SetDoubleProp ( f \"rdkit_ { forcefield } _delta_energy\" , energy - minE ), ) for energy , conf in zip ( energies , mol . GetConformers ()) ] # Now we reorder conformers according to their energies, # so the lowest energies conformers are first. eliminate conformers that exceed ewindow, eratio mol_clone = copy . deepcopy ( mol ) ordered_conformers = [ conf for E , conf in sorted ( zip ( energies , mol_clone . GetConformers ()), key = lambda x : x [ 0 ]) if E - minE <= ewindow and ( E - minE ) / rotatable_bonds <= eratio ] mol . RemoveAllConformers () [ mol . AddConformer ( conf , assignId = True ) for conf in ordered_conformers ] # Align conformers to each others if align_conformers : rdMolAlign . AlignMolConformers ( mol ) if rms_cutoff is not None : mol = cluster ( mol , rms_cutoff = rms_cutoff , already_aligned = align_conformers , centroids = True , ) # type: ignore if add_hs : mol = dm_mol . remove_hs ( mol ) return mol","title":"generate()"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.return_centroids","text":"Given a list of cluster indices, return one single molecule with only the centroid of the clusters of a list of molecules per cluster. Parameters: Name Type Description Default mol Mol a molecule. required conf_clusters Sequence [ Sequence [ int ]] list of cluster indices. required centroids bool If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. True Source code in datamol/conformers/_conformers.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def return_centroids ( mol : Mol , conf_clusters : Sequence [ Sequence [ int ]], centroids : bool = True , ) -> Union [ List [ Mol ], Mol ]: \"\"\"Given a list of cluster indices, return one single molecule with only the centroid of the clusters of a list of molecules per cluster. Args: mol: a molecule. conf_clusters: list of cluster indices. centroids: If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. \"\"\" if centroids : # Collect centroid of each cluster (first element of the list) centroid_list = [ indices [ 0 ] for indices in conf_clusters ] # Keep only centroid conformers mol_clone = copy . deepcopy ( mol ) confs = [ mol_clone . GetConformers ()[ i ] for i in centroid_list ] mol . RemoveAllConformers () [ mol . AddConformer ( conf , assignId = True ) for conf in confs ] return mol else : # Create a new molecule for each cluster and add conformers to it. mols = [] for cluster in conf_clusters : m = copy . deepcopy ( mol ) m . RemoveAllConformers () [ m . AddConformer ( mol . GetConformer ( c ), assignId = True ) for c in cluster ] mols . append ( m ) return mols","title":"return_centroids()"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.rmsd","text":"Compute the RMSD between all the conformers of a molecule. Parameters: Name Type Description Default mol Mol a molecule required Source code in datamol/conformers/_conformers.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def rmsd ( mol : Mol ) -> np . ndarray : \"\"\"Compute the RMSD between all the conformers of a molecule. Args: mol: a molecule \"\"\" if mol . GetNumConformers () <= 1 : raise ValueError ( \"The molecule has 0 or 1 conformer. You can generate conformers with `dm.conformers.generate(mol)`.\" ) n_confs = mol . GetNumConformers () rmsds = [] for i in range ( n_confs ): for j in range ( n_confs ): rmsd = rdMolAlign . AlignMol ( prbMol = mol , refMol = mol , prbCid = i , refCid = j ) rmsds . append ( rmsd ) return np . array ( rmsds ) . reshape ( n_confs , n_confs )","title":"rmsd()"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.translate","text":"Move a given conformer of a molecule to a new position. The transformation is performed in place. Parameters: Name Type Description Default mol Mol the molecule. required new_centroid Union [ np . ndarray , List [ int ]] the new position to move to of shape [x, y, z] required conf_id int id of the conformer. -1 Source code in datamol/conformers/_conformers.py 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def translate ( mol : Mol , new_centroid : Union [ np . ndarray , List [ int ]], conf_id : int = - 1 ): \"\"\"Move a given conformer of a molecule to a new position. The transformation is performed in place. Args: mol: the molecule. new_centroid: the new position to move to of shape [x, y, z] conf_id: id of the conformer. \"\"\" # Get conformer conf = mol . GetConformer ( conf_id ) # Compute the vector for translation mol_center = rdMolTransforms . ComputeCentroid ( conf ) mol_center = np . array ([ mol_center . x , mol_center . y , mol_center . z ]) # Make the transformation matrix T = np . eye ( 4 ) T [: 3 , 3 ] = new_centroid - mol_center # Transform rdMolTransforms . TransformConformer ( conf , T )","title":"translate()"},{"location":"api/datamol.conformers.html#datamol.conformers._features","text":"","title":"_features"},{"location":"api/datamol.conformers.html#datamol.conformers._features.center_of_mass","text":"Compute the center of mass of a conformer of a molecule. Parameters: Name Type Description Default mol Mol a molecule required use_atoms bool Whether to compute the true center of mass or the geometrical center. True digits Optional [ int ] Number of digits to round to. None conf_id int the conformer id. -1 Returns cm: Center of mass or geometrical center Source code in datamol/conformers/_features.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def center_of_mass ( mol : Mol , use_atoms : bool = True , digits : Optional [ int ] = None , conf_id : int = - 1 , ) -> np . ndarray : \"\"\"Compute the center of mass of a conformer of a molecule. Args: mol: a molecule use_atoms: Whether to compute the true center of mass or the geometrical center. digits: Number of digits to round to. conf_id: the conformer id. Returns cm: Center of mass or geometrical center \"\"\" coords = get_coords ( mol , conf_id = conf_id ) atom_weight = np . ones (( coords . shape [ 0 ])) if use_atoms : atom_weight = np . array ([ atom . GetMass () for atom in mol . GetAtoms ()]) atom_weight = atom_weight [:, None ] atom_weight /= atom_weight . sum () center = ( coords * atom_weight ) . sum ( axis = 0 ) if digits is not None : center = center . round ( digits ) return center","title":"center_of_mass()"},{"location":"api/datamol.conformers.html#datamol.conformers._features.get_coords","text":"Get the coordinate of a conformer of a molecule. Parameters: Name Type Description Default mol Mol a molecule. required conf_id int a conformer id. -1 Source code in datamol/conformers/_features.py 86 87 88 89 90 91 92 93 94 95 96 97 98 def get_coords ( mol : Mol , conf_id : int = - 1 ): \"\"\"Get the coordinate of a conformer of a molecule. Args: mol: a molecule. conf_id: a conformer id. \"\"\" if mol . GetNumConformers () == 0 : raise ValueError ( \"Molecule does not have any conformers.\" ) conf = mol . GetConformer ( id = conf_id ) return conf . GetPositions ()","title":"get_coords()"},{"location":"api/datamol.conformers.html#datamol.conformers._features.keep_conformers","text":"Keep on the specified conformer(s) in indices_to_keep . Parameters: Name Type Description Default mol Mol A molecule. required indices_to_keep Union [ int , List [ int ]] A indice or a least of indices of conformers to keep. -1 assign_id bool Whether to assign the kept conformers an id or keep the original one. True copy bool Whether to copy the molecule or not. True Source code in datamol/conformers/_features.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def keep_conformers ( mol : Mol , indices_to_keep : Union [ int , List [ int ]] = - 1 , assign_id : bool = True , copy : bool = True , ): \"\"\"Keep on the specified conformer(s) in `indices_to_keep`. Args: mol: A molecule. indices_to_keep: A indice or a least of indices of conformers to keep. assign_id: Whether to assign the kept conformers an id or keep the original one. copy: Whether to copy the molecule or not. \"\"\" if copy : mol = copy_mol ( mol ) if not isinstance ( indices_to_keep , list ): indices_to_keep = [ indices_to_keep ] # Extract conformers to keep confs_to_keep = [ mol . GetConformer ( conf_id ) for conf_id in indices_to_keep ] # Copy current mol and remove all conformers mol2 = copy_mol ( mol ) mol2 . RemoveAllConformers () # Add conformers _ = [ mol2 . AddConformer ( conf , assignId = assign_id ) for conf in confs_to_keep ] # Cleanup mol = mol2 return mol","title":"keep_conformers()"},{"location":"api/datamol.conformers.html#datamol.conformers._features.sasa","text":"Compute Solvent Accessible Surface Area of all the conformers using FreeSASA ( https://freesasa.github.io/ ). Values are returned as an array and also stored within each conformer as a property called rdkit_free_sasa . Example: smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm . to_mol ( smiles ) mol = dm . conformers . generate ( mol ) # Compute SASA for all the conformers without parallelization sasa_values = dm . conformers . sasa ( mol , conf_id = None , n_jobs = 1 ) # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol . GetConformer ( 0 ) props = conf . GetPropsAsDict () print ( props ) # {'rdkit_uff_energy': 1.7649408317784008} Parameters: Name Type Description Default mol Mol a molecule required conf_id Optional [ Union [ int , List [ int ]]] Id of the conformers to compute. If None, compute all. None n_jobs int Number of jobs for parallelization. Set to 1 to disable and -1 to use all cores. 1 Returns: Name Type Description mol np . ndarray the molecule with the conformers. Source code in datamol/conformers/_features.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @decorators . disable_on_os ( \"win\" ) def sasa ( mol : Mol , conf_id : Optional [ Union [ int , List [ int ]]] = None , n_jobs : int = 1 , ) -> np . ndarray : \"\"\"Compute Solvent Accessible Surface Area of all the conformers using FreeSASA (https://freesasa.github.io/). Values are returned as an array and also stored within each conformer as a property called `rdkit_free_sasa`. Example: ```python smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm.to_mol(smiles) mol = dm.conformers.generate(mol) # Compute SASA for all the conformers without parallelization sasa_values = dm.conformers.sasa(mol, conf_id=None, n_jobs=1) # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol.GetConformer(0) props = conf.GetPropsAsDict() print(props) # {'rdkit_uff_energy': 1.7649408317784008} ``` Args: mol: a molecule conf_id: Id of the conformers to compute. If None, compute all. n_jobs: Number of jobs for parallelization. Set to 1 to disable and -1 to use all cores. Returns: mol: the molecule with the conformers. \"\"\" from rdkit.Chem import rdFreeSASA if mol . GetNumConformers () == 0 : raise ValueError ( \"The molecule has 0 conformers. You can generate conformers with `dm.conformers.generate(mol)`.\" ) # Get Van der Waals radii (angstrom) radii = [ PERIODIC_TABLE . GetRvdw ( atom . GetAtomicNum ()) for atom in mol . GetAtoms ()] # Which conformers to compute conf_ids = [] if conf_id is None : # If None compute for all the conformers conf_ids = list ( range ( mol . GetNumConformers ())) # type: ignore elif isinstance ( conf_id , int ): conf_ids = [ conf_id ] else : conf_ids = conf_id # Compute solvent accessible surface area def _get_sasa ( i ): conf = mol . GetConformer ( i ) sasa = rdFreeSASA . CalcSASA ( mol , radii , confIdx = conf . GetId ()) conf . SetDoubleProp ( \"rdkit_free_sasa\" , sasa ) return sasa runner = JobRunner ( n_jobs = n_jobs ) sasa_values = runner ( _get_sasa , conf_ids ) return np . array ( sasa_values )","title":"sasa()"},{"location":"api/datamol.descriptors.html","text":"datamol.descriptors \u00b6 descriptors \u00b6 n_aromatic_atoms ( mol ) \u00b6 Calculate the number of aromatic atoms. Source code in datamol/descriptors/descriptors.py 81 82 83 84 def n_aromatic_atoms ( mol : Mol ) -> int : \"\"\"Calculate the number of aromatic atoms.\"\"\" matches = mol . GetSubstructMatches ( _AROMATIC_QUERY ) return len ( matches ) n_aromatic_atoms_proportion ( mol ) \u00b6 Calculate the aromatic proportion: # aromatic atoms/#atoms total. Parameters: Name Type Description Default mol Mol A molecule. required Only heavy atoms are considered. Source code in datamol/descriptors/descriptors.py 87 88 89 90 91 92 93 94 95 def n_aromatic_atoms_proportion ( mol : Mol ) -> int : \"\"\"Calculate the aromatic proportion: # aromatic atoms/#atoms total. Args: mol: A molecule. Only heavy atoms are considered. \"\"\" return n_aromatic_atoms ( mol ) / mol . GetNumHeavyAtoms () n_charged_atoms ( mol ) \u00b6 Compute the number of charged atoms in a molecule. Parameters: Name Type Description Default mol Mol A molecule. required Returns: Name Type Description n_charged_atoms int number of charged atoms in the molecule Source code in datamol/descriptors/descriptors.py 116 117 118 119 120 121 122 123 124 125 def n_charged_atoms ( mol : Mol ) -> int : \"\"\"Compute the number of charged atoms in a molecule. Args: mol: A molecule. Returns: n_charged_atoms: number of charged atoms in the molecule \"\"\" return sum ([ at . GetFormalCharge () != 0 for at in mol . GetAtoms ()]) n_rigid_bonds ( mol ) \u00b6 Compute the number of rigid bonds in a molecule. Rigid bonds are bonds that are not single and not in rings. Parameters: Name Type Description Default mol Mol A molecule. required Returns: Name Type Description n_rigid_bonds int number of rigid bonds in the molecule Source code in datamol/descriptors/descriptors.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def n_rigid_bonds ( mol : Mol ) -> int : \"\"\"Compute the number of rigid bonds in a molecule. Rigid bonds are bonds that are not single and not in rings. Args: mol: A molecule. Returns: n_rigid_bonds: number of rigid bonds in the molecule \"\"\" non_rigid_bonds_count = from_smarts ( \"*-&!@*\" ) n_rigid_bonds = mol . GetNumBonds () - len ( mol . GetSubstructMatches ( non_rigid_bonds_count )) return n_rigid_bonds n_stereo_centers ( mol ) \u00b6 Compute the number of stereocenters in a molecule. Parameters: Name Type Description Default mol Mol A molecule. required Returns: Name Type Description n_stero_center int number of stereocenters in the molecule Source code in datamol/descriptors/descriptors.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def n_stereo_centers ( mol : Mol ) -> int : \"\"\"Compute the number of stereocenters in a molecule. Args: mol: A molecule. Returns: n_stero_center: number of stereocenters in the molecule \"\"\" n = 0 try : rdmolops . FindPotentialStereo ( mol , cleanIt = False ) n = rdMolDescriptors . CalcNumAtomStereoCenters ( mol ) except : pass return n compute \u00b6 any_rdkit_descriptor ( name ) \u00b6 Return a descriptor function by name either from rdkit.Chem import Descriptors or rdkit.Chem.rdMolDescriptors . Parameters: Name Type Description Default name str Descriptor name. required Source code in datamol/descriptors/compute.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def any_rdkit_descriptor ( name : str ) -> Callable : \"\"\"Return a descriptor function by name either from `rdkit.Chem import Descriptors` or `rdkit.Chem.rdMolDescriptors`. Args: name: Descriptor name. \"\"\" fn = getattr ( Descriptors , name , None ) if fn is None : fn = getattr ( rdMolDescriptors , name , None ) if fn is None : raise ValueError ( f \"Descriptor { name } not found.\" ) return fn batch_compute_many_descriptors ( mols , properties_fn = None , add_properties = True , n_jobs = 1 , batch_size = None , progress = False , progress_leave = True ) \u00b6 Compute a list of opiniated molecular properties on a list of molecules. Parameters: Name Type Description Default mols List [ Mol ] A list of molecules. required properties_fn Optional [ Dict [ str , Union [ Callable , str ]]] A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, dm.descriptors.any_descriptor() is used to retrieve the descriptor function. None add_properties bool Whether to add the computed properties to the default list. True Returns: Type Description pd . DataFrame A dataframe of computed properties with one row per input molecules. Source code in datamol/descriptors/compute.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def batch_compute_many_descriptors ( mols : List [ Mol ], properties_fn : Optional [ Dict [ str , Union [ Callable , str ]]] = None , add_properties : bool = True , n_jobs : int = 1 , batch_size : Optional [ int ] = None , progress : bool = False , progress_leave : bool = True , ) -> pd . DataFrame : \"\"\"Compute a list of opiniated molecular properties on a list of molecules. Args: mols: A list of molecules. properties_fn: A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, `dm.descriptors.any_descriptor()` is used to retrieve the descriptor function. add_properties: Whether to add the computed properties to the default list. Returns: A dataframe of computed properties with one row per input molecules. \"\"\" compute_fn = functools . partial ( compute_many_descriptors , properties_fn = properties_fn , add_properties = add_properties , ) props = parallelized ( compute_fn , mols , batch_size = batch_size , progress = progress , n_jobs = n_jobs , tqdm_kwargs = dict ( leave = progress_leave ), ) return pd . DataFrame ( props ) compute_many_descriptors ( mol , properties_fn = None , add_properties = True ) \u00b6 Compute a list of opiniated molecular properties. Parameters: Name Type Description Default mol Mol A molecule. required properties_fn Optional [ Dict [ str , Union [ Callable , str ]]] A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, dm.descriptors.any_descriptor() is used to retrieve the descriptor function. None add_properties bool Whether to add the computed properties to the default list. True Returns: Type Description dict Computed properties as a dict. Source code in datamol/descriptors/compute.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def compute_many_descriptors ( mol : Mol , properties_fn : Optional [ Dict [ str , Union [ Callable , str ]]] = None , add_properties : bool = True , ) -> dict : \"\"\"Compute a list of opiniated molecular properties. Args: mol: A molecule. properties_fn: A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, `dm.descriptors.any_descriptor()` is used to retrieve the descriptor function. add_properties: Whether to add the computed properties to the default list. Returns: Computed properties as a dict. \"\"\" if properties_fn is None : properties_fn = _DEFAULT_PROPERTIES_FN elif add_properties : [ properties_fn . setdefault ( k , v ) for k , v in _DEFAULT_PROPERTIES_FN . items ()] props = {} for k , v in properties_fn . items (): if isinstance ( v , str ): v = any_rdkit_descriptor ( v ) props [ k ] = v ( mol ) return props","title":"datamol.descriptors"},{"location":"api/datamol.descriptors.html#datamoldescriptors","text":"","title":"datamol.descriptors"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors","text":"","title":"descriptors"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_aromatic_atoms","text":"Calculate the number of aromatic atoms. Source code in datamol/descriptors/descriptors.py 81 82 83 84 def n_aromatic_atoms ( mol : Mol ) -> int : \"\"\"Calculate the number of aromatic atoms.\"\"\" matches = mol . GetSubstructMatches ( _AROMATIC_QUERY ) return len ( matches )","title":"n_aromatic_atoms()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_aromatic_atoms_proportion","text":"Calculate the aromatic proportion: # aromatic atoms/#atoms total. Parameters: Name Type Description Default mol Mol A molecule. required Only heavy atoms are considered. Source code in datamol/descriptors/descriptors.py 87 88 89 90 91 92 93 94 95 def n_aromatic_atoms_proportion ( mol : Mol ) -> int : \"\"\"Calculate the aromatic proportion: # aromatic atoms/#atoms total. Args: mol: A molecule. Only heavy atoms are considered. \"\"\" return n_aromatic_atoms ( mol ) / mol . GetNumHeavyAtoms ()","title":"n_aromatic_atoms_proportion()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_charged_atoms","text":"Compute the number of charged atoms in a molecule. Parameters: Name Type Description Default mol Mol A molecule. required Returns: Name Type Description n_charged_atoms int number of charged atoms in the molecule Source code in datamol/descriptors/descriptors.py 116 117 118 119 120 121 122 123 124 125 def n_charged_atoms ( mol : Mol ) -> int : \"\"\"Compute the number of charged atoms in a molecule. Args: mol: A molecule. Returns: n_charged_atoms: number of charged atoms in the molecule \"\"\" return sum ([ at . GetFormalCharge () != 0 for at in mol . GetAtoms ()])","title":"n_charged_atoms()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_rigid_bonds","text":"Compute the number of rigid bonds in a molecule. Rigid bonds are bonds that are not single and not in rings. Parameters: Name Type Description Default mol Mol A molecule. required Returns: Name Type Description n_rigid_bonds int number of rigid bonds in the molecule Source code in datamol/descriptors/descriptors.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def n_rigid_bonds ( mol : Mol ) -> int : \"\"\"Compute the number of rigid bonds in a molecule. Rigid bonds are bonds that are not single and not in rings. Args: mol: A molecule. Returns: n_rigid_bonds: number of rigid bonds in the molecule \"\"\" non_rigid_bonds_count = from_smarts ( \"*-&!@*\" ) n_rigid_bonds = mol . GetNumBonds () - len ( mol . GetSubstructMatches ( non_rigid_bonds_count )) return n_rigid_bonds","title":"n_rigid_bonds()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_stereo_centers","text":"Compute the number of stereocenters in a molecule. Parameters: Name Type Description Default mol Mol A molecule. required Returns: Name Type Description n_stero_center int number of stereocenters in the molecule Source code in datamol/descriptors/descriptors.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def n_stereo_centers ( mol : Mol ) -> int : \"\"\"Compute the number of stereocenters in a molecule. Args: mol: A molecule. Returns: n_stero_center: number of stereocenters in the molecule \"\"\" n = 0 try : rdmolops . FindPotentialStereo ( mol , cleanIt = False ) n = rdMolDescriptors . CalcNumAtomStereoCenters ( mol ) except : pass return n","title":"n_stereo_centers()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute","text":"","title":"compute"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute.any_rdkit_descriptor","text":"Return a descriptor function by name either from rdkit.Chem import Descriptors or rdkit.Chem.rdMolDescriptors . Parameters: Name Type Description Default name str Descriptor name. required Source code in datamol/descriptors/compute.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def any_rdkit_descriptor ( name : str ) -> Callable : \"\"\"Return a descriptor function by name either from `rdkit.Chem import Descriptors` or `rdkit.Chem.rdMolDescriptors`. Args: name: Descriptor name. \"\"\" fn = getattr ( Descriptors , name , None ) if fn is None : fn = getattr ( rdMolDescriptors , name , None ) if fn is None : raise ValueError ( f \"Descriptor { name } not found.\" ) return fn","title":"any_rdkit_descriptor()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute.batch_compute_many_descriptors","text":"Compute a list of opiniated molecular properties on a list of molecules. Parameters: Name Type Description Default mols List [ Mol ] A list of molecules. required properties_fn Optional [ Dict [ str , Union [ Callable , str ]]] A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, dm.descriptors.any_descriptor() is used to retrieve the descriptor function. None add_properties bool Whether to add the computed properties to the default list. True Returns: Type Description pd . DataFrame A dataframe of computed properties with one row per input molecules. Source code in datamol/descriptors/compute.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def batch_compute_many_descriptors ( mols : List [ Mol ], properties_fn : Optional [ Dict [ str , Union [ Callable , str ]]] = None , add_properties : bool = True , n_jobs : int = 1 , batch_size : Optional [ int ] = None , progress : bool = False , progress_leave : bool = True , ) -> pd . DataFrame : \"\"\"Compute a list of opiniated molecular properties on a list of molecules. Args: mols: A list of molecules. properties_fn: A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, `dm.descriptors.any_descriptor()` is used to retrieve the descriptor function. add_properties: Whether to add the computed properties to the default list. Returns: A dataframe of computed properties with one row per input molecules. \"\"\" compute_fn = functools . partial ( compute_many_descriptors , properties_fn = properties_fn , add_properties = add_properties , ) props = parallelized ( compute_fn , mols , batch_size = batch_size , progress = progress , n_jobs = n_jobs , tqdm_kwargs = dict ( leave = progress_leave ), ) return pd . DataFrame ( props )","title":"batch_compute_many_descriptors()"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute.compute_many_descriptors","text":"Compute a list of opiniated molecular properties. Parameters: Name Type Description Default mol Mol A molecule. required properties_fn Optional [ Dict [ str , Union [ Callable , str ]]] A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, dm.descriptors.any_descriptor() is used to retrieve the descriptor function. None add_properties bool Whether to add the computed properties to the default list. True Returns: Type Description dict Computed properties as a dict. Source code in datamol/descriptors/compute.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def compute_many_descriptors ( mol : Mol , properties_fn : Optional [ Dict [ str , Union [ Callable , str ]]] = None , add_properties : bool = True , ) -> dict : \"\"\"Compute a list of opiniated molecular properties. Args: mol: A molecule. properties_fn: A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, `dm.descriptors.any_descriptor()` is used to retrieve the descriptor function. add_properties: Whether to add the computed properties to the default list. Returns: Computed properties as a dict. \"\"\" if properties_fn is None : properties_fn = _DEFAULT_PROPERTIES_FN elif add_properties : [ properties_fn . setdefault ( k , v ) for k , v in _DEFAULT_PROPERTIES_FN . items ()] props = {} for k , v in properties_fn . items (): if isinstance ( v , str ): v = any_rdkit_descriptor ( v ) props [ k ] = v ( mol ) return props","title":"compute_many_descriptors()"},{"location":"api/datamol.fragment.html","text":"datamol.fragment \u00b6 _fragment \u00b6 anybreak ( mol , remove_parent = False , sanitize = True , fix = True ) \u00b6 Fragment molecule by applying brics first, then fall back to frag. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def anybreak ( mol : Chem . rdchem . Mol , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Fragment molecule by applying brics first, then fall back to frag. Args: mol: a molecule. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" frags = [] try : frags = brics ( mol , fix = fix , remove_parent = remove_parent , sanitize = sanitize ) except : pass if len ( frags ) == 0 : frags = frag ( mol , remove_parent = remove_parent , sanitize = sanitize , fix = fix ) return frags brics ( mol , singlepass = True , remove_parent = False , sanitize = True , fix = True ) \u00b6 Run BRICS on the molecules and potentially fix dummy atoms. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required singlepass bool Single pass for BRICSDecompose . True remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def brics ( mol : Chem . rdchem . Mol , singlepass : bool = True , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Run BRICS on the molecules and potentially fix dummy atoms. Args: mol: a molecule. singlepass: Single pass for `BRICSDecompose`. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" frags = BRICS . BRICSDecompose ( mol , returnMols = True , singlePass = singlepass ) frags = list ( frags ) if fix : frags = [ dm . fix_mol ( x ) for x in frags ] if sanitize : frags = [ dm . sanitize_mol ( x ) for x in frags ] if remove_parent : frags . pop ( 0 ) frags = [ x for x in frags if x is not None ] return frags frag ( mol , remove_parent = False , sanitize = True , fix = True ) \u00b6 Generate all possible fragmentation of a molecule. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def frag ( mol : Chem . rdchem . Mol , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Generate all possible fragmentation of a molecule. Args: mol: a molecule. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" frags = FraggleSim . generate_fraggle_fragmentation ( mol ) smiles = set ([]) for seq in frags : smiles |= { s . strip () for s in seq . split ( \".\" )} smiles = list ( sorted ( smiles , reverse = True )) frags = [ dm . to_mol ( s ) for s in smiles ] if fix : frags = [ dm . fix_mol ( x ) for x in frags ] if sanitize : frags = [ dm . sanitize_mol ( x ) for x in frags ] frags = [ x for x in frags if x is not None ] if remove_parent : return frags return [ mol ] + frags mmpa_cut ( mol , rdkit_pattern = False ) \u00b6 Cut molecules to perform mmpa analysis later Parameters: Name Type Description Default mol dm . Mol Molecule to fragment. required rdkit_pattern bool Whether to perform the fragmentation using the default rdkit pattern: [#6+0;!$( =, #[!#6])]!@!=!#[ ]\" False Returns: Type Description Optional [ Set [ Any ]] List of 'smiles,core,chains' Source code in datamol/fragment/_fragment.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def mmpa_cut ( mol : dm . Mol , rdkit_pattern : bool = False ) -> Optional [ Set [ Any ]]: \"\"\"Cut molecules to perform mmpa analysis later Args: mol: Molecule to fragment. rdkit_pattern: Whether to perform the fragmentation using the default rdkit pattern: [#6+0;!$(*=, #[!#6])]!@!=!#[*]\" Returns: List of 'smiles,core,chains' \"\"\" if mol is None : return mol outlines = set () smiles = dm . to_smiles ( mol ) if rdkit_pattern : frags = mmpa_frag ( mol , max_cut = 3 , max_bond_cut = 30 ) else : # heavy atoms frags = mmpa_frag ( mol , pattern = \"[!#1]!@!=!#[!#1]\" , max_cut = 4 , max_bond_cut = 30 ) frags . update ( mmpa_frag ( mol , pattern = \"[!#1]!@!=!#[!#1]\" , max_cut = 3 , max_bond_cut = 30 )) frags = set ( frags ) for core , chains in frags : output = f \" { smiles } , { core } , { chains } \\n \" outlines . add ( output ) # hydrogen splitting mol = dm . add_hs ( mol ) smiles = dm . to_smiles ( mol ) n = mol . GetNumHeavyAtoms () if n < 60 : frags = mmpa_frag ( mol , pattern = None , max_cut = 1 , max_bond_cut = 100 , h_split = True ) for core , chains in frags : output = f \" { smiles } , { core } , { chains } \\n \" outlines . add ( output ) return outlines mmpa_frag ( mol , pattern = None , max_cut = 1 , max_bond_cut = 20 , h_split = False ) \u00b6 Fragment molecule on specific bonds suitable for a MMPA analysis. Parameters: Name Type Description Default mol dm . Mol Molecule to fragment. required pattern Optional [ str ] Bond pattern to split on. Will use default rdkit pattern '[#6+0;!$( =,#[!#6])]!@!=!#[ ]' if not provided. None max_cut int Number of cuts. 1 max_bond_cut int Maximum number of bond to cut. Default to 20. 20 h_split bool Whether to split at hydrogen position too. This is equivalent to enabling the addition of new fragments. False Returns: Type Description Optional [ Set [ dm . Mol ]] List of fragments. Source code in datamol/fragment/_fragment.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def mmpa_frag ( mol : dm . Mol , pattern : Optional [ str ] = None , max_cut : int = 1 , max_bond_cut : int = 20 , h_split : bool = False , ) -> Optional [ Set [ dm . Mol ]]: \"\"\"Fragment molecule on specific bonds suitable for a MMPA analysis. Args: mol: Molecule to fragment. pattern: Bond pattern to split on. Will use default rdkit pattern '[#6+0;!$(*=,#[!#6])]!@!=!#[*]' if not provided. max_cut: Number of cuts. max_bond_cut: Maximum number of bond to cut. Default to 20. h_split: Whether to split at hydrogen position too. This is equivalent to enabling the addition of new fragments. Returns: List of fragments. \"\"\" frags = [] if pattern is None : frags = rdMMPA . FragmentMol ( mol , maxCuts = max_cut , resultsAsMols = False , maxCutBonds = max_bond_cut , ) elif pattern : frags = rdMMPA . FragmentMol ( mol , pattern = pattern , maxCuts = max_cut , resultsAsMols = False , maxCutBonds = max_bond_cut , ) if h_split : mol = dm . add_hs ( mol ) frags += rdMMPA . FragmentMol ( mol , pattern = \"[#1]!@!=!#[!#1]\" , maxCuts = 1 , resultsAsMols = False , maxCutBonds = max_bond_cut , ) return set ( frags ) recap ( mol , remove_parent = False , sanitize = True , fix = True ) \u00b6 Fragment the molecule using the recap algorithm. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def recap ( mol : Chem . rdchem . Mol , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Fragment the molecule using the recap algorithm. Args: mol: a molecule. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" res = Recap . RecapDecompose ( mol ) frags = [ dm . to_mol ( x ) for x in res . GetAllChildren () . keys ()] if fix : frags = [ dm . fix_mol ( x ) for x in frags ] if sanitize : frags = [ dm . sanitize_mol ( x ) for x in frags ] frags = [ x for x in frags if x is not None ] if remove_parent : return frags return [ mol ] + frags _assemble \u00b6 maclandrol: 22/07/19 This is an attempt to reverse engineer the BRICS (Breaking of Retrosynthetically Interesting Chemical Substructures) approach for molecule fragmentation and use it as an heuristic for assembling molecules. The original paper on BRICS can be found here: http://dacemirror.sci-hub.tw/journal-article/93060992e8d889318b77b562c0e5b75f/degen2008.pdf . This makes senses from a methodological point of view, but I can't either guarantee that its is working as expected of if it's the best way to tackle this problem. The goal here is to reconstruct a set of original molecules, which if they were to be fragmented using BRICS, should yield the same fragment set in input. Thus, in theory fragments obtained using BRICS CAN be assembled into the original molecules with this method. This differs from rdkit BRICSBuild implementation that requires the presence of dummy indicator atoms added by a prior BRICS fragmentation. assemble_fragment_iter ( fragmentlist , seens = None , scrambleReagents = False , max_n_mols = float ( 'inf' ), maxdepth = 3 , as_smiles = True , RXNS = None ) \u00b6 Perform an assembly from fragment given all potential RXNS transformation. Source code in datamol/fragment/_assemble.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def assemble_fragment_iter ( fragmentlist , seens = None , scrambleReagents = False , max_n_mols = float ( \"inf\" ), maxdepth = 3 , as_smiles = True , RXNS = None , ): \"\"\"Perform an assembly from fragment given all potential RXNS transformation.\"\"\" if RXNS is None : RXNS = ALL_BRICS_RETRO seen = set () if max_n_mols <= 0 : return if not seens : seens = list ( fragmentlist ) if scrambleReagents : seens = list ( seens ) random . shuffle ( seens , random = random . random ) for seen in seens : nextSteps = [] for rxn in RXNS : for fg in fragmentlist : for m , pSmi in _run_at_all_rct ( rxn , fg , seen ): if pSmi not in seen : seen . add ( pSmi ) yield m if not as_smiles else pSmi if _can_continue_with ( m , rxn ): nextSteps . append ( m ) if nextSteps and len ( seen ) <= max_n_mols and maxdepth > 0 : for p in assemble_fragment_iter ( fragmentlist , seens = nextSteps , scrambleReagents = scrambleReagents , max_n_mols = ( max_n_mols - len ( seen )), maxdepth = maxdepth - 1 , ): pSmi = dm . to_smiles ( p , True ) if pSmi not in seen : seen . add ( pSmi ) yield p if not as_smiles else pSmi if len ( seen ) >= max_n_mols : return assemble_fragment_order ( fragmentlist , seen = None , allow_incomplete = False , max_n_mols = float ( 'inf' ), RXNS = None ) \u00b6 Assemble a list of fragment into a set of possible molecules under rules defined by the brics algorithm We are of course assuming that the order in the fragmentlist matter :D ! that none of the fragment has explicitly defined hydrogen atoms. only a list of unique molecule is internally maintained Parameters: Name Type Description Default fragmentlist list list of original fragments to grow required seen Optional [ Mol ] original molecules used as base. If none, the first element of fragment list will be poped out None allow_incomplete bool Whether to accept assembled molecules with missing fragment False Source code in datamol/fragment/_assemble.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def assemble_fragment_order ( fragmentlist : list , seen : Optional [ Mol ] = None , allow_incomplete : bool = False , max_n_mols : float = float ( \"inf\" ), RXNS = None , ): \"\"\"Assemble a list of fragment into a set of possible molecules under rules defined by the brics algorithm We are of course assuming: 1. that the order in the fragmentlist matter :D ! 2. that none of the fragment has explicitly defined hydrogen atoms. 3. only a list of unique molecule is internally maintained Args: fragmentlist: list of original fragments to grow seen: original molecules used as base. If none, the first element of fragment list will be poped out allow_incomplete: Whether to accept assembled molecules with missing fragment \"\"\" if RXNS is None : RXNS = ALL_BRICS_RETRO fragmentlist = list ( fragmentlist ) yield_counter = 0 if seen is None : seen = fragmentlist . pop ( 0 ) seen = [ dm . to_smiles ( seen )] # only one molecule to assemble while yield_counter < max_n_mols and len ( fragmentlist ) > 0 : # find all the way to add this fragment to seen frag = fragmentlist . pop ( 0 ) level_set = [ dm . to_mol ( x ) for x in seen ] seen = set () for sm in level_set : try : # there is no point in even trying something on molecules that cannot be kekulized for rxn in RXNS : for m , mSmi in _run_at_all_rct ( rxn , frag , sm ): if allow_incomplete and mSmi not in seen : yield m yield_counter += 1 seen . add ( mSmi ) except Exception as e : print ( e ) pass for m in seen : if yield_counter < max_n_mols : yield dm . to_mol ( m ) yield_counter += 1 break_mol ( mol , minFragmentSize = 1 , silent = True , onlyUseReactions = [], randomize = False , mode = 'brics' , returnTree = False ) \u00b6 Breaks a molecules into a list of fragment. Source code in datamol/fragment/_assemble.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def break_mol ( mol : Chem . rdchem . Mol , minFragmentSize : int = 1 , silent : bool = True , onlyUseReactions : list = [], randomize : bool = False , mode : str = \"brics\" , returnTree : bool = False , ): \"\"\"Breaks a molecules into a list of fragment.\"\"\" if mode . lower () == \"brics\" : all_reactions = ALL_BRICS all_reactions_type = ALL_BRICS_TYPE elif mode . lower () == \"rxn\" : all_reactions = ALL_RXNS all_reactions_type = ALL_RXNS_TYPE else : all_reactions = ALL_BRICS + ALL_RXNS all_reactions_type = ALL_BRICS_TYPE + ALL_RXNS_TYPE if randomize : p = np . random . permutation ( len ( all_reactions )) all_reactions = [ all_reactions [ ind ] for ind in p ] all_reactions_type = [ all_reactions_type [ ind ] for ind in p ] nx = dm . graph . _get_networkx () mSmi = dm . to_smiles ( mol , isomeric = True ) G = nx . DiGraph () node_num = 0 G . add_node ( node_num , smiles = mSmi , mol = mol ) allNodes = set () activePool = { mSmi : node_num } allNodes . add ( mSmi ) while activePool : nSmi = list ( activePool . keys ())[ 0 ] parent = activePool . pop ( nSmi ) node = G . nodes [ parent ] mol = node [ \"mol\" ] for rxnIdx , reaction in zip ( all_reactions_type , all_reactions ): if onlyUseReactions and rxnIdx not in onlyUseReactions : continue ps = reaction . RunReactants (( mol ,)) if ps : all_pass = [ all ([ prod . GetNumAtoms ( onlyExplicit = True ) > minFragmentSize for prod in p_ ]) for p_ in ps ] nz_i = 0 while nz_i < len ( all_pass ) and not all_pass [ nz_i ]: nz_i += 1 if not silent : print ( nSmi , \"->\" , len ( ps ), \"products and selected \" , nz_i ) # display(MolsToGridImage(list(itertools.chain(*list(ps))), molsPerRow=2)) prodSeq = ps [ nz_i % len ( all_pass )] seqOk = True # we want to disqualify small fragments, so sort the product sequence by size prodSeq = [( prod . GetNumAtoms ( onlyExplicit = True ), prod ) for prod in prodSeq ] prodSeq . sort ( key = lambda x : x [ 0 ]) for _ , prod in prodSeq : prod . sanitized = True try : Chem . SanitizeMol ( prod ) except : if dm . sanitize_mol ( prod ) is None : seqOk = False break continue pSmi = dm . to_smiles ( prod , isomeric = True ) seqOk = seqOk and ( dm . to_mol ( pSmi ) is not None ) notDummies = sum ([ atm . GetSymbol () != \"*\" for atm in prod . GetAtoms ()]) # nDummies = pSmi.count('*') # if minFragmentSize > 0 and (nats - nDummies < minFragmentSize): if minFragmentSize > 0 and notDummies < minFragmentSize : seqOk = False break prod . pSmi = pSmi if seqOk : for _ , prod in prodSeq : if not prod . sanitized : continue pSmi = prod . pSmi node_num += 1 usmi = dm . to_smiles ( dm . fix_mol ( prod ), isomeric = True ) G . add_node ( node_num , smiles = usmi , mol = prod ) G . add_edge ( parent , node_num ) if usmi not in allNodes : activePool [ pSmi ] = node_num allNodes . add ( usmi ) G . nodes [ parent ][ \"rxn\" ] = rxnIdx break # at least one reaction matches leaves_smiles = [ G . nodes [ n ][ \"smiles\" ] for n in G . nodes () if G . in_degree ( n ) != 0 and G . out_degree ( n ) == 0 ] if returnTree : return leaves_smiles , allNodes , G return leaves_smiles , allNodes build ( ll_mols , max_n_mols = float ( 'inf' ), mode = 'brics' , frag_rxn = None , ADD_RNXS = []) \u00b6 Build a super molecule from a list of fragments Source code in datamol/fragment/_assemble.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def build ( ll_mols , max_n_mols = float ( \"inf\" ), mode = \"brics\" , frag_rxn = None , ADD_RNXS = []): \"\"\"Build a super molecule from a list of fragments\"\"\" seen = set () stop = False CUR_RXNS = [] CUR_RXNS_TYPE = [] if mode == \"brics\" : CUR_RXNS = ALL_BRICS_RETRO CUR_RXNS_TYPE = ALL_BRICS_TYPE elif mode == \"rxn\" : CUR_RXNS = ALL_RXNS_RETRO CUR_RXNS_TYPE = ALL_RXNS_TYPE elif mode is not None : CUR_RXNS = ALL_BRICS_RETRO + ALL_RXNS_RETRO CUR_RXNS_TYPE = ALL_BRICS_TYPE + ALL_RXNS_TYPE if ADD_RNXS is not None : ADD_RNXS_TYPE = [ f \"RXN- { i } \" for i in range ( len ( ADD_RNXS ))] if isinstance ( ADD_RNXS , dict ): ADD_RNXS_TYPE = ADD_RNXS . keys () ADD_RNXS = ADD_RNXS . values () CUR_RXNS += list ( ADD_RNXS ) CUR_RXNS_TYPE += list ( ADD_RNXS_TYPE ) for i , rxn_type in enumerate ( CUR_RXNS_TYPE ): if ( frag_rxn is not None ) and ( frag_rxn . strip ( '\"' ) == rxn_type ): CUR_RXNS = [ CUR_RXNS [ i ]] break for fraglist in itertools . product ( * ll_mols ): if stop : break fraglist = list ( fraglist ) for rxn in CUR_RXNS : # should be size==1 if frag_rxn is provided ps = [] try : ps = _run_at_all_rct ( rxn , fraglist [ 0 ], fraglist [ 1 ]) except Exception : pass for m , mSmi in ps : if len ( seen ) >= max_n_mols : stop = True break if mSmi not in seen : seen . add ( mSmi ) yield m","title":"datamol.fragment"},{"location":"api/datamol.fragment.html#datamolfragment","text":"","title":"datamol.fragment"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment","text":"","title":"_fragment"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.anybreak","text":"Fragment molecule by applying brics first, then fall back to frag. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def anybreak ( mol : Chem . rdchem . Mol , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Fragment molecule by applying brics first, then fall back to frag. Args: mol: a molecule. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" frags = [] try : frags = brics ( mol , fix = fix , remove_parent = remove_parent , sanitize = sanitize ) except : pass if len ( frags ) == 0 : frags = frag ( mol , remove_parent = remove_parent , sanitize = sanitize , fix = fix ) return frags","title":"anybreak()"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.brics","text":"Run BRICS on the molecules and potentially fix dummy atoms. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required singlepass bool Single pass for BRICSDecompose . True remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def brics ( mol : Chem . rdchem . Mol , singlepass : bool = True , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Run BRICS on the molecules and potentially fix dummy atoms. Args: mol: a molecule. singlepass: Single pass for `BRICSDecompose`. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" frags = BRICS . BRICSDecompose ( mol , returnMols = True , singlePass = singlepass ) frags = list ( frags ) if fix : frags = [ dm . fix_mol ( x ) for x in frags ] if sanitize : frags = [ dm . sanitize_mol ( x ) for x in frags ] if remove_parent : frags . pop ( 0 ) frags = [ x for x in frags if x is not None ] return frags","title":"brics()"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.frag","text":"Generate all possible fragmentation of a molecule. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def frag ( mol : Chem . rdchem . Mol , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Generate all possible fragmentation of a molecule. Args: mol: a molecule. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" frags = FraggleSim . generate_fraggle_fragmentation ( mol ) smiles = set ([]) for seq in frags : smiles |= { s . strip () for s in seq . split ( \".\" )} smiles = list ( sorted ( smiles , reverse = True )) frags = [ dm . to_mol ( s ) for s in smiles ] if fix : frags = [ dm . fix_mol ( x ) for x in frags ] if sanitize : frags = [ dm . sanitize_mol ( x ) for x in frags ] frags = [ x for x in frags if x is not None ] if remove_parent : return frags return [ mol ] + frags","title":"frag()"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.mmpa_cut","text":"Cut molecules to perform mmpa analysis later Parameters: Name Type Description Default mol dm . Mol Molecule to fragment. required rdkit_pattern bool Whether to perform the fragmentation using the default rdkit pattern: [#6+0;!$( =, #[!#6])]!@!=!#[ ]\" False Returns: Type Description Optional [ Set [ Any ]] List of 'smiles,core,chains' Source code in datamol/fragment/_fragment.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def mmpa_cut ( mol : dm . Mol , rdkit_pattern : bool = False ) -> Optional [ Set [ Any ]]: \"\"\"Cut molecules to perform mmpa analysis later Args: mol: Molecule to fragment. rdkit_pattern: Whether to perform the fragmentation using the default rdkit pattern: [#6+0;!$(*=, #[!#6])]!@!=!#[*]\" Returns: List of 'smiles,core,chains' \"\"\" if mol is None : return mol outlines = set () smiles = dm . to_smiles ( mol ) if rdkit_pattern : frags = mmpa_frag ( mol , max_cut = 3 , max_bond_cut = 30 ) else : # heavy atoms frags = mmpa_frag ( mol , pattern = \"[!#1]!@!=!#[!#1]\" , max_cut = 4 , max_bond_cut = 30 ) frags . update ( mmpa_frag ( mol , pattern = \"[!#1]!@!=!#[!#1]\" , max_cut = 3 , max_bond_cut = 30 )) frags = set ( frags ) for core , chains in frags : output = f \" { smiles } , { core } , { chains } \\n \" outlines . add ( output ) # hydrogen splitting mol = dm . add_hs ( mol ) smiles = dm . to_smiles ( mol ) n = mol . GetNumHeavyAtoms () if n < 60 : frags = mmpa_frag ( mol , pattern = None , max_cut = 1 , max_bond_cut = 100 , h_split = True ) for core , chains in frags : output = f \" { smiles } , { core } , { chains } \\n \" outlines . add ( output ) return outlines","title":"mmpa_cut()"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.mmpa_frag","text":"Fragment molecule on specific bonds suitable for a MMPA analysis. Parameters: Name Type Description Default mol dm . Mol Molecule to fragment. required pattern Optional [ str ] Bond pattern to split on. Will use default rdkit pattern '[#6+0;!$( =,#[!#6])]!@!=!#[ ]' if not provided. None max_cut int Number of cuts. 1 max_bond_cut int Maximum number of bond to cut. Default to 20. 20 h_split bool Whether to split at hydrogen position too. This is equivalent to enabling the addition of new fragments. False Returns: Type Description Optional [ Set [ dm . Mol ]] List of fragments. Source code in datamol/fragment/_fragment.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def mmpa_frag ( mol : dm . Mol , pattern : Optional [ str ] = None , max_cut : int = 1 , max_bond_cut : int = 20 , h_split : bool = False , ) -> Optional [ Set [ dm . Mol ]]: \"\"\"Fragment molecule on specific bonds suitable for a MMPA analysis. Args: mol: Molecule to fragment. pattern: Bond pattern to split on. Will use default rdkit pattern '[#6+0;!$(*=,#[!#6])]!@!=!#[*]' if not provided. max_cut: Number of cuts. max_bond_cut: Maximum number of bond to cut. Default to 20. h_split: Whether to split at hydrogen position too. This is equivalent to enabling the addition of new fragments. Returns: List of fragments. \"\"\" frags = [] if pattern is None : frags = rdMMPA . FragmentMol ( mol , maxCuts = max_cut , resultsAsMols = False , maxCutBonds = max_bond_cut , ) elif pattern : frags = rdMMPA . FragmentMol ( mol , pattern = pattern , maxCuts = max_cut , resultsAsMols = False , maxCutBonds = max_bond_cut , ) if h_split : mol = dm . add_hs ( mol ) frags += rdMMPA . FragmentMol ( mol , pattern = \"[#1]!@!=!#[!#1]\" , maxCuts = 1 , resultsAsMols = False , maxCutBonds = max_bond_cut , ) return set ( frags )","title":"mmpa_frag()"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.recap","text":"Fragment the molecule using the recap algorithm. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required remove_parent bool Remove parent from the fragments. False sanitize bool Wether to sanitize the fragments. True fix bool Wether to fix the fragments. True Source code in datamol/fragment/_fragment.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def recap ( mol : Chem . rdchem . Mol , remove_parent : bool = False , sanitize : bool = True , fix : bool = True , ): \"\"\"Fragment the molecule using the recap algorithm. Args: mol: a molecule. remove_parent: Remove parent from the fragments. sanitize: Wether to sanitize the fragments. fix: Wether to fix the fragments. \"\"\" res = Recap . RecapDecompose ( mol ) frags = [ dm . to_mol ( x ) for x in res . GetAllChildren () . keys ()] if fix : frags = [ dm . fix_mol ( x ) for x in frags ] if sanitize : frags = [ dm . sanitize_mol ( x ) for x in frags ] frags = [ x for x in frags if x is not None ] if remove_parent : return frags return [ mol ] + frags","title":"recap()"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble","text":"maclandrol: 22/07/19 This is an attempt to reverse engineer the BRICS (Breaking of Retrosynthetically Interesting Chemical Substructures) approach for molecule fragmentation and use it as an heuristic for assembling molecules. The original paper on BRICS can be found here: http://dacemirror.sci-hub.tw/journal-article/93060992e8d889318b77b562c0e5b75f/degen2008.pdf . This makes senses from a methodological point of view, but I can't either guarantee that its is working as expected of if it's the best way to tackle this problem. The goal here is to reconstruct a set of original molecules, which if they were to be fragmented using BRICS, should yield the same fragment set in input. Thus, in theory fragments obtained using BRICS CAN be assembled into the original molecules with this method. This differs from rdkit BRICSBuild implementation that requires the presence of dummy indicator atoms added by a prior BRICS fragmentation.","title":"_assemble"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.assemble_fragment_iter","text":"Perform an assembly from fragment given all potential RXNS transformation. Source code in datamol/fragment/_assemble.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def assemble_fragment_iter ( fragmentlist , seens = None , scrambleReagents = False , max_n_mols = float ( \"inf\" ), maxdepth = 3 , as_smiles = True , RXNS = None , ): \"\"\"Perform an assembly from fragment given all potential RXNS transformation.\"\"\" if RXNS is None : RXNS = ALL_BRICS_RETRO seen = set () if max_n_mols <= 0 : return if not seens : seens = list ( fragmentlist ) if scrambleReagents : seens = list ( seens ) random . shuffle ( seens , random = random . random ) for seen in seens : nextSteps = [] for rxn in RXNS : for fg in fragmentlist : for m , pSmi in _run_at_all_rct ( rxn , fg , seen ): if pSmi not in seen : seen . add ( pSmi ) yield m if not as_smiles else pSmi if _can_continue_with ( m , rxn ): nextSteps . append ( m ) if nextSteps and len ( seen ) <= max_n_mols and maxdepth > 0 : for p in assemble_fragment_iter ( fragmentlist , seens = nextSteps , scrambleReagents = scrambleReagents , max_n_mols = ( max_n_mols - len ( seen )), maxdepth = maxdepth - 1 , ): pSmi = dm . to_smiles ( p , True ) if pSmi not in seen : seen . add ( pSmi ) yield p if not as_smiles else pSmi if len ( seen ) >= max_n_mols : return","title":"assemble_fragment_iter()"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.assemble_fragment_order","text":"Assemble a list of fragment into a set of possible molecules under rules defined by the brics algorithm We are of course assuming that the order in the fragmentlist matter :D ! that none of the fragment has explicitly defined hydrogen atoms. only a list of unique molecule is internally maintained Parameters: Name Type Description Default fragmentlist list list of original fragments to grow required seen Optional [ Mol ] original molecules used as base. If none, the first element of fragment list will be poped out None allow_incomplete bool Whether to accept assembled molecules with missing fragment False Source code in datamol/fragment/_assemble.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def assemble_fragment_order ( fragmentlist : list , seen : Optional [ Mol ] = None , allow_incomplete : bool = False , max_n_mols : float = float ( \"inf\" ), RXNS = None , ): \"\"\"Assemble a list of fragment into a set of possible molecules under rules defined by the brics algorithm We are of course assuming: 1. that the order in the fragmentlist matter :D ! 2. that none of the fragment has explicitly defined hydrogen atoms. 3. only a list of unique molecule is internally maintained Args: fragmentlist: list of original fragments to grow seen: original molecules used as base. If none, the first element of fragment list will be poped out allow_incomplete: Whether to accept assembled molecules with missing fragment \"\"\" if RXNS is None : RXNS = ALL_BRICS_RETRO fragmentlist = list ( fragmentlist ) yield_counter = 0 if seen is None : seen = fragmentlist . pop ( 0 ) seen = [ dm . to_smiles ( seen )] # only one molecule to assemble while yield_counter < max_n_mols and len ( fragmentlist ) > 0 : # find all the way to add this fragment to seen frag = fragmentlist . pop ( 0 ) level_set = [ dm . to_mol ( x ) for x in seen ] seen = set () for sm in level_set : try : # there is no point in even trying something on molecules that cannot be kekulized for rxn in RXNS : for m , mSmi in _run_at_all_rct ( rxn , frag , sm ): if allow_incomplete and mSmi not in seen : yield m yield_counter += 1 seen . add ( mSmi ) except Exception as e : print ( e ) pass for m in seen : if yield_counter < max_n_mols : yield dm . to_mol ( m ) yield_counter += 1","title":"assemble_fragment_order()"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.break_mol","text":"Breaks a molecules into a list of fragment. Source code in datamol/fragment/_assemble.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def break_mol ( mol : Chem . rdchem . Mol , minFragmentSize : int = 1 , silent : bool = True , onlyUseReactions : list = [], randomize : bool = False , mode : str = \"brics\" , returnTree : bool = False , ): \"\"\"Breaks a molecules into a list of fragment.\"\"\" if mode . lower () == \"brics\" : all_reactions = ALL_BRICS all_reactions_type = ALL_BRICS_TYPE elif mode . lower () == \"rxn\" : all_reactions = ALL_RXNS all_reactions_type = ALL_RXNS_TYPE else : all_reactions = ALL_BRICS + ALL_RXNS all_reactions_type = ALL_BRICS_TYPE + ALL_RXNS_TYPE if randomize : p = np . random . permutation ( len ( all_reactions )) all_reactions = [ all_reactions [ ind ] for ind in p ] all_reactions_type = [ all_reactions_type [ ind ] for ind in p ] nx = dm . graph . _get_networkx () mSmi = dm . to_smiles ( mol , isomeric = True ) G = nx . DiGraph () node_num = 0 G . add_node ( node_num , smiles = mSmi , mol = mol ) allNodes = set () activePool = { mSmi : node_num } allNodes . add ( mSmi ) while activePool : nSmi = list ( activePool . keys ())[ 0 ] parent = activePool . pop ( nSmi ) node = G . nodes [ parent ] mol = node [ \"mol\" ] for rxnIdx , reaction in zip ( all_reactions_type , all_reactions ): if onlyUseReactions and rxnIdx not in onlyUseReactions : continue ps = reaction . RunReactants (( mol ,)) if ps : all_pass = [ all ([ prod . GetNumAtoms ( onlyExplicit = True ) > minFragmentSize for prod in p_ ]) for p_ in ps ] nz_i = 0 while nz_i < len ( all_pass ) and not all_pass [ nz_i ]: nz_i += 1 if not silent : print ( nSmi , \"->\" , len ( ps ), \"products and selected \" , nz_i ) # display(MolsToGridImage(list(itertools.chain(*list(ps))), molsPerRow=2)) prodSeq = ps [ nz_i % len ( all_pass )] seqOk = True # we want to disqualify small fragments, so sort the product sequence by size prodSeq = [( prod . GetNumAtoms ( onlyExplicit = True ), prod ) for prod in prodSeq ] prodSeq . sort ( key = lambda x : x [ 0 ]) for _ , prod in prodSeq : prod . sanitized = True try : Chem . SanitizeMol ( prod ) except : if dm . sanitize_mol ( prod ) is None : seqOk = False break continue pSmi = dm . to_smiles ( prod , isomeric = True ) seqOk = seqOk and ( dm . to_mol ( pSmi ) is not None ) notDummies = sum ([ atm . GetSymbol () != \"*\" for atm in prod . GetAtoms ()]) # nDummies = pSmi.count('*') # if minFragmentSize > 0 and (nats - nDummies < minFragmentSize): if minFragmentSize > 0 and notDummies < minFragmentSize : seqOk = False break prod . pSmi = pSmi if seqOk : for _ , prod in prodSeq : if not prod . sanitized : continue pSmi = prod . pSmi node_num += 1 usmi = dm . to_smiles ( dm . fix_mol ( prod ), isomeric = True ) G . add_node ( node_num , smiles = usmi , mol = prod ) G . add_edge ( parent , node_num ) if usmi not in allNodes : activePool [ pSmi ] = node_num allNodes . add ( usmi ) G . nodes [ parent ][ \"rxn\" ] = rxnIdx break # at least one reaction matches leaves_smiles = [ G . nodes [ n ][ \"smiles\" ] for n in G . nodes () if G . in_degree ( n ) != 0 and G . out_degree ( n ) == 0 ] if returnTree : return leaves_smiles , allNodes , G return leaves_smiles , allNodes","title":"break_mol()"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.build","text":"Build a super molecule from a list of fragments Source code in datamol/fragment/_assemble.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def build ( ll_mols , max_n_mols = float ( \"inf\" ), mode = \"brics\" , frag_rxn = None , ADD_RNXS = []): \"\"\"Build a super molecule from a list of fragments\"\"\" seen = set () stop = False CUR_RXNS = [] CUR_RXNS_TYPE = [] if mode == \"brics\" : CUR_RXNS = ALL_BRICS_RETRO CUR_RXNS_TYPE = ALL_BRICS_TYPE elif mode == \"rxn\" : CUR_RXNS = ALL_RXNS_RETRO CUR_RXNS_TYPE = ALL_RXNS_TYPE elif mode is not None : CUR_RXNS = ALL_BRICS_RETRO + ALL_RXNS_RETRO CUR_RXNS_TYPE = ALL_BRICS_TYPE + ALL_RXNS_TYPE if ADD_RNXS is not None : ADD_RNXS_TYPE = [ f \"RXN- { i } \" for i in range ( len ( ADD_RNXS ))] if isinstance ( ADD_RNXS , dict ): ADD_RNXS_TYPE = ADD_RNXS . keys () ADD_RNXS = ADD_RNXS . values () CUR_RXNS += list ( ADD_RNXS ) CUR_RXNS_TYPE += list ( ADD_RNXS_TYPE ) for i , rxn_type in enumerate ( CUR_RXNS_TYPE ): if ( frag_rxn is not None ) and ( frag_rxn . strip ( '\"' ) == rxn_type ): CUR_RXNS = [ CUR_RXNS [ i ]] break for fraglist in itertools . product ( * ll_mols ): if stop : break fraglist = list ( fraglist ) for rxn in CUR_RXNS : # should be size==1 if frag_rxn is provided ps = [] try : ps = _run_at_all_rct ( rxn , fraglist [ 0 ], fraglist [ 1 ]) except Exception : pass for m , mSmi in ps : if len ( seen ) >= max_n_mols : stop = True break if mSmi not in seen : seen . add ( mSmi ) yield m","title":"build()"},{"location":"api/datamol.html","text":"datamol \u00b6 Module mol \u00b6 mol \u00b6 add_hs ( mol , explicit_only = False , add_coords = False , only_on_atoms = None , add_residue_info = False ) \u00b6 Adds hydrogens to the molecule. Parameters: Name Type Description Default mol Mol a molecule. required explicit_only bool whether to only add explicit hydrogens. False add_coords bool whether to add 3D coordinates to the hydrogens. False only_on_atoms Optional [ List [ int ]] a list of atoms to add hydrogens only on. None add_residue_info bool whether to add residue information to the hydrogens. Useful for PDB files. False Source code in datamol/mol.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 def add_hs ( mol : Mol , explicit_only : bool = False , add_coords : bool = False , only_on_atoms : Optional [ List [ int ]] = None , add_residue_info : bool = False , ): \"\"\"Adds hydrogens to the molecule. Args: mol: a molecule. explicit_only: whether to only add explicit hydrogens. add_coords: whether to add 3D coordinates to the hydrogens. only_on_atoms: a list of atoms to add hydrogens only on. add_residue_info: whether to add residue information to the hydrogens. Useful for PDB files. \"\"\" mol = AddHs ( mol , explicitOnly = explicit_only , addCoords = add_coords , onlyOnAtoms = only_on_atoms , addResidueInfo = add_residue_info , ) return mol adjust_singleton ( mol ) \u00b6 Remove all atoms that are essentially disconnected singleton nodes in the molecular graph. For example, the chlorine atom and methane fragment will be removed in Cl.[N:1]1=CC(O)=CC2CCCCC12.CC.C\", but not the ethane fragment. Parameters: Name Type Description Default mol Mol a molecule. required Source code in datamol/mol.py 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def adjust_singleton ( mol : Mol ) -> Optional [ Mol ]: \"\"\"Remove all atoms that are essentially disconnected singleton nodes in the molecular graph. For example, the chlorine atom and methane fragment will be removed in Cl.[N:1]1=CC(O)=CC2CCCCC12.CC.C\", but not the ethane fragment. Args: mol: a molecule. \"\"\" to_rem = [] em = RWMol ( mol ) for atom in mol . GetAtoms (): if atom . GetExplicitValence () == 0 : to_rem . append ( atom . GetIdx ()) to_rem . sort ( reverse = True ) for a_idx in to_rem : em . RemoveAtom ( a_idx ) return em . GetMol () atom_indices_to_mol ( mol , copy = False ) \u00b6 Add the molAtomMapNumber property to each atoms. Parameters: Name Type Description Default mol Mol a molecule required copy bool Whether to copy the molecule. False Source code in datamol/mol.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def atom_indices_to_mol ( mol : Mol , copy : bool = False ): \"\"\"Add the `molAtomMapNumber` property to each atoms. Args: mol: a molecule copy: Whether to copy the molecule. \"\"\" if copy is True : mol = copy_mol ( mol ) for atom in mol . GetAtoms (): atom . SetProp ( \"molAtomMapNumber\" , str ( atom . GetIdx ())) return mol atom_list_to_bond ( mol , atom_indices , bond_as_idx = False ) \u00b6 Return a list of existing bond indices between a list of atom indices. Parameters: Name Type Description Default mol Mol A molecule. required atom_indices List [ int ] A list of atom indices. required Source code in datamol/mol.py 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 def atom_list_to_bond ( mol : Mol , atom_indices : List [ int ], bond_as_idx : bool = False , ): \"\"\"Return a list of existing bond indices between a list of atom indices. Args: mol: A molecule. atom_indices: A list of atom indices. \"\"\" # Build an atom map atom_map = {} submol = PathToSubmol ( mol , atom_indices , useQuery = True , atomMap = atom_map ) atom_map_reversed = { v : k for k , v in atom_map . items ()} bonds = [] for bond in submol . GetBonds (): a1 , a2 = bond . GetBeginAtomIdx (), bond . GetEndAtomIdx () ori_a1 = atom_map_reversed [ a1 ] ori_a2 = atom_map_reversed [ a2 ] if ori_a1 in atom_indices and ori_a2 in atom_indices : ori_bond = mol . GetBondBetweenAtoms ( ori_a1 , ori_a2 ) if bond_as_idx : bonds . append ( ori_bond . GetIdx ()) else : bonds . append ( ori_bond ) return bonds clear_mol_props ( mol , copy = True , include_private = False , include_computed = False ) \u00b6 Clear all properties from a molecule. Parameters: Name Type Description Default mol Mol A molecule. required copy bool Whether to copy the molecule. True Source code in datamol/mol.py 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 def clear_mol_props ( mol : Mol , copy : bool = True , include_private : bool = False , include_computed : bool = False , ): \"\"\"Clear all properties from a molecule. Args: mol: A molecule. copy: Whether to copy the molecule. \"\"\" if copy : mol = copy_mol ( mol ) props = mol . GetPropsAsDict ( includePrivate = include_private , includeComputed = include_computed ) for key in props . keys (): mol . ClearProp ( key ) return mol compute_ring_system ( mol , include_spiro = True ) \u00b6 Compute the list of ring system in a molecule. This is based on RDKit's cookbook: https://www.rdkit.org/docs/Cookbook.html#rings-aromaticity-and-kekulization Parameters: Name Type Description Default mol Mol input molecule required include_spiro bool whether to include spiro rings. True Returns: Name Type Description ring_system List [ Set [ int ]] list of ring system (atom indices). Source code in datamol/mol.py 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 def compute_ring_system ( mol : Mol , include_spiro : bool = True ) -> List [ Set [ int ]]: \"\"\"Compute the list of ring system in a molecule. This is based on RDKit's cookbook: https://www.rdkit.org/docs/Cookbook.html#rings-aromaticity-and-kekulization Args: mol: input molecule include_spiro: whether to include spiro rings. Returns: ring_system: list of ring system (atom indices). \"\"\" ri = mol . GetRingInfo () systems = [] for ring in ri . AtomRings (): ringAts = set ( ring ) nSystems = [] for system in systems : nInCommon = len ( ringAts . intersection ( system )) if nInCommon and ( include_spiro or nInCommon > 1 ): ringAts = ringAts . union ( system ) else : nSystems . append ( system ) nSystems . append ( ringAts ) systems = nSystems return systems copy_mol ( mol ) \u00b6 Copy a molecule and return a new one. Parameters: Name Type Description Default mol Mol a molecule to copy. required Source code in datamol/mol.py 57 58 59 60 61 62 63 def copy_mol ( mol : Mol ) -> Mol : \"\"\"Copy a molecule and return a new one. Args: mol: a molecule to copy. \"\"\" return copy . deepcopy ( mol ) copy_mol_props ( source , destination , include_private = False , include_computed = False ) \u00b6 Copy properties from one source molecule to another destination molecule. Parameters: Name Type Description Default source Mol a molecule to copy from. required destination Mol a molecule to copy to. required include_private bool Include private properties. False include_computed bool Include computed properties. False Source code in datamol/mol.py 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 def copy_mol_props ( source : Mol , destination : Mol , include_private : bool = False , include_computed : bool = False , ): \"\"\"Copy properties from one source molecule to another destination molecule. Args: source: a molecule to copy from. destination: a molecule to copy to. include_private: Include private properties. include_computed: Include computed properties. \"\"\" props = source . GetPropsAsDict ( includePrivate = include_private , includeComputed = include_computed ) set_mol_props ( destination , props ) decrease_bond ( bond ) \u00b6 Remove one single bond from the input bond. Note that you should first kekulize your molecules and remove non-standard bond. Parameters: Name Type Description Default bond Chem . rdchem . Bond a bond. required Source code in datamol/mol.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def decrease_bond ( bond : Chem . rdchem . Bond ) -> Optional [ Union [ list , Chem . rdchem . Bond ]]: \"\"\"Remove one single bond from the input bond. Note that you should first kekulize your molecules and remove non-standard bond. Args: bond: a bond. \"\"\" if bond . GetBondType () == TRIPLE_BOND : return DOUBLE_BOND if bond . GetBondType () == DOUBLE_BOND : return SINGLE_BOND if bond . GetBondType () == SINGLE_BOND : return None return bond fix_mol ( mol , n_iter = 1 , remove_singleton = False , largest_only = False , inplace = False ) \u00b6 Fix error in molecule using a greedy approach. Parameters: Name Type Description Default mol Mol input molecule to fix required n_iter int Number of valence fix iteration to apply 1 remove_singleton bool Whether adjust_singleton should be applied False largest_only bool Whether only the largest fragment should be kept False inplace bool Whether to return a copy of the mol or perform in place operation False Returns: Type Description Optional [ Mol ] Fixed molecule. Source code in datamol/mol.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 def fix_mol ( mol : Mol , n_iter : int = 1 , remove_singleton : bool = False , largest_only : bool = False , inplace : bool = False , ) -> Optional [ Mol ]: \"\"\"Fix error in molecule using a greedy approach. Args: mol: input molecule to fix n_iter: Number of valence fix iteration to apply remove_singleton: Whether `adjust_singleton` should be applied largest_only: Whether only the largest fragment should be kept inplace: Whether to return a copy of the mol or perform in place operation Returns: Fixed molecule. \"\"\" if not inplace : mol = copy . copy ( mol ) m = sanitize_mol ( mol ) or mol # fail back to mol when the fixer fail if m is not None : m = remove_dummies ( m ) for _ in range ( n_iter ): m = fix_valence ( m ) if remove_singleton : m = adjust_singleton ( m ) if largest_only : # m = max(Chem.rdmolops.GetMolFrags(m, asMols=True, sanitizeFrags=False), key=lambda m: m.GetNumAtoms()) m = rdMolStandardize . FragmentParent ( m , skipStandardize = True ) return m fix_valence ( mol , inplace = False , allow_ring_break = False ) \u00b6 Identify and try to fix valence issues by removing any supplemental bond that should not be in the graph. Parameters: Name Type Description Default mol Mol input molecule with incorrect valence for some atoms required inplace bool Whether to modify in place or make a copy False allow_ring_break bool Whether bond removal involving ring is allowed. False Returns: Type Description Optional [ Mol ] Fixed potential valence issue in molecule or original molecule when nothing is broken Optional [ Mol ] of if failed. Source code in datamol/mol.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def fix_valence ( mol : Mol , inplace : bool = False , allow_ring_break : bool = False ) -> Optional [ Mol ]: \"\"\"Identify and try to fix valence issues by removing any supplemental bond that should not be in the graph. Args: mol: input molecule with incorrect valence for some atoms inplace: Whether to modify in place or make a copy allow_ring_break: Whether bond removal involving ring is allowed. Returns: Fixed potential valence issue in molecule or original molecule when nothing is broken of if failed. \"\"\" if not inplace : mol = copy . copy ( mol ) vm = rdMolStandardize . RDKitValidation () if len ( vm . validate ( mol )) == 0 : # don't fix something that is not broken return mol try : m = remove_hs ( mol , implicit_only = False , update_explicit_count = True , sanitize = False , ) m . UpdatePropertyCache ( False ) # first pass using explicit false count for atom in m . GetAtoms (): while incorrect_valence ( atom ) and atom . GetTotalNumHs () > 0 : cur_hydrogen = atom . GetTotalNumHs () atom . SetNumExplicitHs ( max ( 0 , cur_hydrogen - 1 )) atom . SetFormalCharge ( max ( 0 , atom . GetFormalCharge () - 1 )) # atom.SetNumRadicalElectrons(0) atom . UpdatePropertyCache ( False ) em = RWMol ( m ) bonds = em . GetBonds () bonds = [ bond for bond in bonds if any ( [ incorrect_valence ( bond . GetBeginAtom ()), incorrect_valence ( bond . GetEndAtom ()), ] ) ] for bond in bonds : a1 = bond . GetBeginAtom () a2 = bond . GetEndAtom () if incorrect_valence ( a1 ) or incorrect_valence ( a2 ): mbond = decrease_bond ( bond ) if allow_ring_break or ( mbond or not bond . IsInRing ()): em . RemoveBond ( a1 . GetIdx (), a2 . GetIdx ()) if mbond is not None : em . AddBond ( a1 . GetIdx (), a2 . GetIdx (), mbond ) a1 . UpdatePropertyCache ( False ) a2 . UpdatePropertyCache ( False ) m = em . GetMol () except Exception : return None return m fix_valence_charge ( mol , inplace = False ) \u00b6 Fix valence issues that are due to incorrect charges. Parameters: Name Type Description Default mol Mol Input molecule with incorrect valence for some atoms required inplace bool Whether to modify in place or make a copy. False Returns: Type Description Optional [ Mol ] Fixed molecule via charge correction or original molecule if failed. Source code in datamol/mol.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def fix_valence_charge ( mol : Mol , inplace : bool = False ) -> Optional [ Mol ]: \"\"\"Fix valence issues that are due to incorrect charges. Args: mol: Input molecule with incorrect valence for some atoms inplace: Whether to modify in place or make a copy. Returns: Fixed molecule via charge correction or original molecule if failed. \"\"\" vm = rdMolStandardize . RDKitValidation () # Don't fix something that is not broken if len ( vm . validate ( mol )) > 0 : if not inplace : mol = copy . copy ( mol ) mol . UpdatePropertyCache ( False ) for a in mol . GetAtoms (): n_electron = ( a . GetImplicitValence () + a . GetExplicitValence () - PERIODIC_TABLE . GetDefaultValence ( a . GetSymbol ()) ) a . SetFormalCharge ( n_electron ) return mol incorrect_valence ( a , update = False ) \u00b6 Check if an atom connection is not valid or all the atom of a molecule. Parameters: Name Type Description Default a Union [ Mol , Chem . rdchem . Atom ] atom or molecule to check for valence issue. required update bool Update owning molecule property cache first. False Returns: Type Description bool Whether the input atom valence is correct. Source code in datamol/mol.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def incorrect_valence ( a : Union [ Mol , Chem . rdchem . Atom ], update : bool = False ) -> bool : \"\"\"Check if an atom connection is not valid or all the atom of a molecule. Args: a: atom or molecule to check for valence issue. update: Update owning molecule property cache first. Returns: Whether the input atom valence is correct. \"\"\" if isinstance ( a , Mol ): a . UpdatePropertyCache ( False ) vm = rdMolStandardize . RDKitValidation () return len ( vm . validate ( a )) > 0 if update : m = a . GetOwningMol () m . UpdatePropertyCache ( False ) return ( a . GetImplicitValence () == 0 ) and ( a . GetExplicitValence () > max ( PERIODIC_TABLE . GetValenceList ( a . GetSymbol ())) ) is_transition_metal ( at ) \u00b6 Check if atom is a transition metal. Parameters: Name Type Description Default at Chem . rdchem . Atom an atom. required Source code in datamol/mol.py 685 686 687 688 689 690 691 692 def is_transition_metal ( at : Chem . rdchem . Atom ) -> bool : \"\"\"Check if atom is a transition metal. Args: at: an atom. \"\"\" n = at . GetAtomicNum () return ( n >= 22 and n <= 29 ) or ( n >= 40 and n <= 47 ) or ( n >= 72 and n <= 79 ) keep_largest_fragment ( mol ) \u00b6 Only keep largest fragment of each molecule. Source code in datamol/mol.py 676 677 678 679 680 681 682 def keep_largest_fragment ( mol : Mol ) -> Optional [ Mol ]: \"\"\"Only keep largest fragment of each molecule.\"\"\" return max ( GetMolFrags ( mol , asMols = True ), default = mol , key = lambda m : m . GetNumAtoms (), ) make_scaffold_generic ( mol , include_bonds = False ) \u00b6 Make the atom in a scaffold or molecule generic. Parameters: Name Type Description Default mol Mol A molecule or a scaffold. required include_bonds bool Whether we should also update bond order or keep as is. False Source code in datamol/mol.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 def make_scaffold_generic ( mol : Mol , include_bonds : bool = False ): \"\"\"Make the atom in a scaffold or molecule generic. Args: mol: A molecule or a scaffold. include_bonds: Whether we should also update bond order or keep as is. \"\"\" for atom in mol . GetAtoms (): if atom . GetAtomicNum () != 1 : atom . SetAtomicNum ( 0 ) atom . SetFormalCharge ( 0 ) atom . SetChiralTag ( rdchem . ChiralType . CHI_UNSPECIFIED ) atom . SetNoImplicit ( 0 ) atom . SetNumExplicitHs ( 0 ) if include_bonds : for bond in mol . GetBonds (): bond . SetBondType ( UNSPECIFIED_BOND ) mol . UpdatePropertyCache () Chem . GetSymmSSSR ( mol ) # type: ignore return mol protect_atoms ( mol , substruct = None , atoms = None , in_place = False ) \u00b6 Protect a list of atoms or substruct in a molecule. The _protected attributes of a molecule is used by RDKit in several functions, especially for reactions where \"protected\" atoms are disallowed from taking part in reactions. Parameters: Name Type Description Default mol Mol input molecule to protect required substruct Optional [ Mol ] optional substructure query to identify atoms to protect None atoms Optional [ Union [ List [ int ], int ]] optional list of atom indices to protect None in_place bool whether to perform the protection in place or return a copy of the molecule False Source code in datamol/mol.py 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 def protect_atoms ( mol : Mol , substruct : Optional [ Mol ] = None , atoms : Optional [ Union [ List [ int ], int ]] = None , in_place : bool = False , ) -> Mol : \"\"\"Protect a list of atoms or substruct in a molecule. The _protected attributes of a molecule is used by RDKit in several functions, especially for reactions where \"protected\" atoms are disallowed from taking part in reactions. Args: mol: input molecule to protect substruct: optional substructure query to identify atoms to protect atoms: optional list of atom indices to protect in_place: whether to perform the protection in place or return a copy of the molecule \"\"\" if atoms is None : atoms = [] elif not isinstance ( atoms , ( tuple , list )): atoms = [ atoms ] # do not perform protection in place if in_place : mol_copy = mol else : mol_copy = copy_mol ( mol ) if substruct is not None : matches = mol_copy . GetSubstructMatches ( substruct ) atoms . extend ( itertools . chain ( * matches )) for a in atoms : if a is None : continue mol_copy . GetAtomWithIdx ( a ) . SetProp ( \"_protected\" , \"1\" ) return mol_copy randomize_atoms ( mol ) \u00b6 Randomize the position of the atoms in a mol. Parameters: Name Type Description Default mol Mol a molecule. required Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def randomize_atoms ( mol : Mol ) -> Optional [ Mol ]: \"\"\"Randomize the position of the atoms in a mol. Args: mol: a molecule. Returns: mol: a molecule. \"\"\" if mol . GetNumAtoms () == 0 : return mol atom_indices = list ( range ( mol . GetNumAtoms ())) random . shuffle ( atom_indices ) return RenumberAtoms ( mol , atom_indices ) remove_dummies ( mol , dummy = '*' ) \u00b6 Remove dummy atoms from molecules. Source code in datamol/mol.py 599 600 601 602 603 604 605 606 607 608 609 610 def remove_dummies ( mol : Mol , dummy : str = \"*\" ) -> Optional [ Mol ]: \"\"\"Remove dummy atoms from molecules.\"\"\" du = to_mol ( dummy ) out = mol try : out = ReplaceSubstructs ( mol , du , to_mol ( \"[H]\" ), True )[ 0 ] out = remove_hs ( out ) except Exception : out = DeleteSubstructs ( mol , du ) return out remove_hs ( mol , implicit_only = False , update_explicit_count = False , sanitize = True ) \u00b6 Removes hydrogens from a molecule. Parameters: Name Type Description Default mol Mol a molecule. required implicit_only bool whether to only remove implicit hydrogens. False update_explicit_count bool whether to update the explicit hydrogen count. False sanitize bool whether to sanitize the molecule after the hydrogens are removed. True Source code in datamol/mol.py 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 def remove_hs ( mol : Mol , implicit_only : bool = False , update_explicit_count : bool = False , sanitize : bool = True , ): \"\"\"Removes hydrogens from a molecule. Args: mol: a molecule. implicit_only: whether to only remove implicit hydrogens. update_explicit_count: whether to update the explicit hydrogen count. sanitize: whether to sanitize the molecule after the hydrogens are removed. \"\"\" mol = RemoveHs ( mol , implicitOnly = implicit_only , updateExplicitCount = update_explicit_count , sanitize = sanitize , ) return mol reorder_atoms ( mol , break_ties = True , include_chirality = True , include_isotopes = True ) \u00b6 Reorder the atoms in a mol. It ensures a single atom order for the same molecule, regardless of its original representation. Parameters: Name Type Description Default mol Mol a molecule. required break_ties bool Force breaking of ranked ties. True include_chirality bool Use chiral information when computing rank. True include_isotopes bool Use isotope information when computing rank. True Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def reorder_atoms ( mol : Mol , break_ties : bool = True , include_chirality : bool = True , include_isotopes : bool = True , ) -> Optional [ Mol ]: \"\"\"Reorder the atoms in a mol. It ensures a single atom order for the same molecule, regardless of its original representation. Args: mol: a molecule. break_ties: Force breaking of ranked ties. include_chirality: Use chiral information when computing rank. include_isotopes: Use isotope information when computing rank. Returns: mol: a molecule. \"\"\" if mol . GetNumAtoms () == 0 : return mol new_order = CanonicalRankAtoms ( mol , breakTies = break_ties , includeChirality = include_chirality , includeIsotopes = include_isotopes , ) new_order = sorted ([( y , x ) for x , y in enumerate ( new_order )]) return RenumberAtoms ( mol , [ y for ( x , y ) in new_order ]) replace_dummies_atoms ( mol , atom = 'C' , dummy = '*' , replace_all = True ) \u00b6 Remove dummy atoms from molecules. Parameters: Name Type Description Default mol Mol molecule with dummies required atom str replacement atom, default is carbon 'C' dummy str dummy atom representation '*' replace_all bool Whether to replace all dummies True Returns: Name Type Description mol Optional [ Mol ] Molecule with dummy replaced Source code in datamol/mol.py 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 def replace_dummies_atoms ( mol : Mol , atom : str = \"C\" , dummy : str = \"*\" , replace_all : bool = True , ) -> Optional [ Mol ]: \"\"\"Remove dummy atoms from molecules. Args: mol: molecule with dummies atom: replacement atom, default is carbon dummy: dummy atom representation replace_all: Whether to replace all dummies Returns: mol: Molecule with dummy replaced \"\"\" du = to_mol ( dummy ) replacement = to_mol ( atom ) out = ReplaceSubstructs ( mol , du , replacement , replaceAll = replace_all )[ 0 ] return out same_mol ( mol1 , mol2 , use_non_standard_inchikey = False ) \u00b6 Check two molecules are the same by comparing their InChiKey. Invalid molecules (None) are always considered as not the same. Parameters: Name Type Description Default mol1 Optional [ Mol ] A molecule. required mol2 Optional [ Mol ] A molecule. required use_non_standard_inchikey bool Whether to use the standard or non-standard InChiKey. False Source code in datamol/mol.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def same_mol ( mol1 : Optional [ Mol ], mol2 : Optional [ Mol ], use_non_standard_inchikey : bool = False , ) -> bool : \"\"\"Check two molecules are the same by comparing their InChiKey. Invalid molecules (None) are always considered as not the same. Args: mol1: A molecule. mol2: A molecule. use_non_standard_inchikey: Whether to use the standard or non-standard InChiKey. \"\"\" if mol1 is None or mol2 is None : return False if use_non_standard_inchikey : return to_inchikey_non_standard ( mol1 ) == to_inchikey_non_standard ( mol2 ) else : return to_inchikey ( mol1 ) == to_inchikey ( mol2 ) sanitize_first ( mols , charge_neutral = False , sanifix = True ) \u00b6 Sanitize a list of molecules and return the first valid molecule seen in the list. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules. required charge_neutral bool whether charge neutralization should be applied. False sanifix bool whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. True Returns: Name Type Description mol Mol a molecule. Source code in datamol/mol.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def sanitize_first ( mols : List [ Mol ], charge_neutral : bool = False , sanifix : bool = True ) -> Mol : \"\"\"Sanitize a list of molecules and return the first valid molecule seen in the list. Args: mols: a list of molecules. charge_neutral: whether charge neutralization should be applied. sanifix: whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. Returns: mol: a molecule. \"\"\" for mol in mols : mol = sanitize_mol ( mol , charge_neutral = charge_neutral , sanifix = sanifix ) if mol : return mol return None sanitize_mol ( mol , charge_neutral = False , sanifix = True , verbose = True , add_hs = False ) \u00b6 An augmented version of RDKit sanitize=True . It uses a mol-SMILES-mol conversion to catch potential aromaticity errors and try to fix aromatic nitrogen (using the popular sanifix4 script). Optionally, it can neutralize the charge of the molecule. Note #1: Only the first conformer (if present) will be preserved and a warning will be displayed if more than one conformer is detected. Note #2: The molecule's properties will be preserved but the atom's properties will be lost. Parameters: Name Type Description Default mol Mol a molecule. required charge_neutral bool whether charge neutralization should be applied. False sanifix bool whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. True verbose bool Whether displaying a warning about multiple conformers. True add_hs bool Add hydrogens to the returned molecule. Useful when the input molecule already contains hydrogens. False Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def sanitize_mol ( mol : Mol , charge_neutral : bool = False , sanifix : bool = True , verbose : bool = True , add_hs : bool = False , ) -> Optional [ Mol ]: \"\"\"An augmented version of RDKit `sanitize=True`. It uses a mol-SMILES-mol conversion to catch potential aromaticity errors and try to fix aromatic nitrogen (using the popular sanifix4 script). Optionally, it can neutralize the charge of the molecule. Note #1: Only the first conformer (if present) will be preserved and a warning will be displayed if more than one conformer is detected. Note #2: The molecule's properties will be preserved but the atom's properties will be lost. Args: mol: a molecule. charge_neutral: whether charge neutralization should be applied. sanifix: whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. verbose: Whether displaying a warning about multiple conformers. add_hs: Add hydrogens to the returned molecule. Useful when the input molecule already contains hydrogens. Returns: mol: a molecule. \"\"\" if mol is None : return mol # Extract properties. original_mol = copy_mol ( mol ) properties = original_mol . GetPropsAsDict () if charge_neutral : mol = to_neutral ( mol ) if sanifix : mol = _sanifix4 . sanifix ( mol ) if mol is not None : # Detect multiple conformers if verbose and mol . GetNumConformers () > 1 : logger . warning ( f \"The molecule contains multiple conformers. Only the first one will be preserved.\" ) # Try catch to avoid occasional aromaticity errors try : # `cxsmiles` is used here to preserve the first conformer. mol = to_mol ( to_smiles ( mol , cxsmiles = True ), sanitize = True , add_hs = add_hs ) except Exception : mol = None if mol is not None : # Insert back properties. mol = set_mol_props ( mol , properties ) return mol sanitize_smiles ( smiles , isomeric = True ) \u00b6 Takes SMILES string and returns its sanitized version. Parameters: Name Type Description Default smiles Optional [ str ] smiles to be sanitized. required isomeric bool Whether to include information about stereochemistry in the SMILES. True Returns: Type Description Optional [ str ] sanitized smiles. Source code in datamol/mol.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def sanitize_smiles ( smiles : Optional [ str ], isomeric : bool = True ) -> Optional [ str ]: \"\"\"Takes SMILES string and returns its sanitized version. Args: smiles: smiles to be sanitized. isomeric: Whether to include information about stereochemistry in the SMILES. Returns: sanitized smiles. \"\"\" mol = None try : mol = to_mol ( smiles , sanitize = False ) mol = sanitize_mol ( mol , False ) except Exception : return None if mol is None : return None try : smiles = to_smiles ( mol , isomeric = isomeric ) except : return None return smiles set_dative_bonds ( mol , from_atoms = ( 7 , 8 )) \u00b6 Replaces some single bonds between metals and atoms with atomic numbers in fromAtoms with dative bonds. The replacement is only done if the atom has \"too many\" bonds. Parameters: Name Type Description Default mol Mol molecule with bond to modify required from_atoms Tuple [ int , int ] List of atoms (symbol or atomic number) to consider for bond replacement. By default, only Nitrogen (7) and Oxygen (8) are considered. (7, 8) Returns: Type Description Optional [ Mol ] The modified molecule. Source code in datamol/mol.py 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 def set_dative_bonds ( mol : Mol , from_atoms : Tuple [ int , int ] = ( 7 , 8 )) -> Optional [ Mol ]: \"\"\"Replaces some single bonds between metals and atoms with atomic numbers in fromAtoms with dative bonds. The replacement is only done if the atom has \"too many\" bonds. Arguments: mol: molecule with bond to modify from_atoms: List of atoms (symbol or atomic number) to consider for bond replacement. By default, only Nitrogen (7) and Oxygen (8) are considered. Returns: The modified molecule. \"\"\" rwmol = RWMol ( mol ) rwmol . UpdatePropertyCache ( strict = False ) metals = [ at for at in rwmol . GetAtoms () if is_transition_metal ( at )] for metal in metals : for nbr in metal . GetNeighbors (): if ( nbr . GetAtomicNum () in from_atoms or nbr . GetSymbol () in from_atoms ) and ( nbr . GetExplicitValence () > PERIODIC_TABLE . GetDefaultValence ( nbr . GetAtomicNum ()) and rwmol . GetBondBetweenAtoms ( nbr . GetIdx (), metal . GetIdx ()) . GetBondType () == SINGLE_BOND ): rwmol . RemoveBond ( nbr . GetIdx (), metal . GetIdx ()) rwmol . AddBond ( nbr . GetIdx (), metal . GetIdx (), DATIVE_BOND ) return rwmol set_mol_props ( mol , props , copy = False ) \u00b6 Set properties to a mol from a dict. Parameters: Name Type Description Default mol Mol the mol where to copy the props. required props Dict [ str , Any ] the props to copy. required copy bool whether to copy the provided mol False Source code in datamol/mol.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 def set_mol_props ( mol : Mol , props : Dict [ str , Any ], copy : bool = False , ) -> Mol : \"\"\"Set properties to a mol from a dict. Args: mol: the mol where to copy the props. props: the props to copy. copy: whether to copy the provided mol \"\"\" if copy is True : mol = copy_mol ( mol ) for k , v in props . items (): if isinstance ( v , bool ): mol . SetBoolProp ( k , v ) elif isinstance ( v , int ): # NOTE(hadim): A Python integer is 32 bits and RDKit seems # to overflow before that. Here we catch the error # and instead uses silently `SetDoubleProp` instead. try : mol . SetIntProp ( k , v ) except OverflowError : mol . SetDoubleProp ( k , v ) elif isinstance ( v , float ): mol . SetDoubleProp ( k , v ) else : mol . SetProp ( k , str ( v )) return mol standardize_mol ( mol , disconnect_metals = False , normalize = True , reionize = True , uncharge = False , stereo = True ) \u00b6 This function returns a standardized version the given molecule. It relies on the RDKit rdMolStandardize module which is largely inspired from MolVS . Parameters: Name Type Description Default mol Mol A molecule to standardize. required disconnect_metals bool Disconnect metals that are defined as covalently bonded to non-metal. Depending on the source of the database, some compounds may be reported in salt form or associated to metallic ions (e.g. the sodium salt of a carboxylic compound). In most cases, these counter-ions are not relevant so the use of this function is required before further utilization of the dataset. In summary the process is the following: Break covalent bonds between metals and organic atoms under certain conditions. First, disconnect N, O, F from any metal. Then disconnect other non-metals from transition metals (with exceptions). For every bond broken, adjust the charges of the begin and end atoms accordingly. False normalize bool Applies a series of standard transformations to correct functional groups and recombine charges. It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the overall proper charge of the compound. It includes: Uncharge-separate sulfones Charge-separate nitro groups Charge-separate pyridine oxide Charge-separate azide Charge-separate diazo and azo groups Charge-separate sulfoxides Hydrazine-diazonium system True reionize bool If one or more acidic functionalities are present in the molecule, this option ensures the correct neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens. For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge The algorithm works as follows: Use SMARTS to find the strongest protonated acid and the weakest ionized acid. If the ionized acid is weaker than the protonated acid, swap proton and repeat. True uncharge bool This option neutralize the molecule by reversing the protonation state of protonated and deprotonated groups, if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid). In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge to ensure a net zero charge. False stereo bool Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry ( AssignStereochemistry ). True Returns: Name Type Description mol Mol A standardized molecule. Source code in datamol/mol.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 def standardize_mol ( mol : Mol , disconnect_metals : bool = False , normalize : bool = True , reionize : bool = True , uncharge : bool = False , stereo : bool = True , ) -> Mol : r \"\"\" This function returns a standardized version the given molecule. It relies on the RDKit [`rdMolStandardize` module](https://www.rdkit.org/docs/source/rdkit.Chem.MolStandardize.rdMolStandardize.html) which is largely inspired from [MolVS](https://github.com/mcs07/MolVS). Arguments: mol: A molecule to standardize. disconnect_metals: Disconnect metals that are defined as covalently bonded to non-metal. Depending on the source of the database, some compounds may be reported in salt form or associated to metallic ions (e.g. the sodium salt of a carboxylic compound). In most cases, these counter-ions are not relevant so the use of this function is required before further utilization of the dataset. In summary the process is the following: - Break covalent bonds between metals and organic atoms under certain conditions. - First, disconnect N, O, F from any metal. Then disconnect other non-metals from transition metals (with exceptions). - For every bond broken, adjust the charges of the begin and end atoms accordingly. normalize: Applies a series of standard transformations to correct functional groups and recombine charges. It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the overall proper charge of the compound. It includes: - Uncharge-separate sulfones - Charge-separate nitro groups - Charge-separate pyridine oxide - Charge-separate azide - Charge-separate diazo and azo groups - Charge-separate sulfoxides - Hydrazine-diazonium system reionize: If one or more acidic functionalities are present in the molecule, this option ensures the correct neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens. For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge The algorithm works as follows: - Use SMARTS to find the strongest protonated acid and the weakest ionized acid. - If the ionized acid is weaker than the protonated acid, swap proton and repeat. uncharge: This option neutralize the molecule by reversing the protonation state of protonated and deprotonated groups, if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid). In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge to ensure a net zero charge. stereo: Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry (`AssignStereochemistry`). Returns: mol: A standardized molecule. \"\"\" mol = copy_mol ( mol ) if disconnect_metals : md = rdMolStandardize . MetalDisconnector () mol = md . Disconnect ( mol ) if normalize : mol = rdMolStandardize . Normalize ( mol ) if reionize : reionizer = rdMolStandardize . Reionizer () mol = reionizer . reionize ( mol ) if uncharge : uncharger = rdMolStandardize . Uncharger () mol = uncharger . uncharge ( mol ) if stereo : AssignStereochemistry ( mol , force = False , cleanIt = True ) return mol standardize_smiles ( smiles , tautomer = False ) \u00b6 Apply smile standardization procedure. This is a convenient function wrapped arrounf RDKit smiles standardizer and tautomeric canonicalization. Parameters: Name Type Description Default smiles str Smiles to standardize required tautomer bool Whether to canonicalize tautomers False Returns: Name Type Description standard_smiles str the standardized smiles Source code in datamol/mol.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def standardize_smiles ( smiles : str , tautomer : bool = False ) -> str : r \"\"\" Apply smile standardization procedure. This is a convenient function wrapped arrounf RDKit smiles standardizer and tautomeric canonicalization. Args: smiles: Smiles to standardize tautomer: Whether to canonicalize tautomers Returns: standard_smiles: the standardized smiles \"\"\" smiles = rdMolStandardize . StandardizeSmiles ( smiles ) if tautomer : smiles = canonicalize_tautomer_smiles ( smiles ) return smiles strip_mol_to_core ( mol , bond_cutter = None ) \u00b6 Strip a molecule to its core, i.e. remove all atoms not in the core. This method 'guess' the molecular core, by finding the ring system. Parameters: Name Type Description Default mol Mol A molecule. required bond_cutter Mol A molecule used to cut the bonds. None Source code in datamol/mol.py 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 def strip_mol_to_core ( mol : Mol , bond_cutter : Mol = None ): \"\"\"Strip a molecule to its core, i.e. remove all atoms not in the core. This method 'guess' the molecular core, by finding the ring system. Args: mol: A molecule. bond_cutter: A molecule used to cut the bonds. \"\"\" if bond_cutter is None : bond_cutter = from_smarts ( \"[R;!$(*=,#[!#6])]!@!=!#[*;$([A;!R][A;!R])]\" ) with without_rdkit_log (): scaffold = MurckoScaffold . GetScaffoldForMol ( mol ) out = mol . GetSubstructMatches ( bond_cutter ) bond_inds = [ mol . GetBondBetweenAtoms ( i , j ) . GetIdx () for i , j in out ] if len ( bond_inds ) > 0 : fragmented = rdmolops . FragmentOnBonds ( mol , bond_inds ) fragmented = remove_dummies ( fragmented ) fragmented = to_scaffold_murcko ( fragmented ) scaffold = keep_largest_fragment ( fragmented ) return scaffold substructure_matching_bonds ( mol , query , ** kwargs ) \u00b6 Perform a substructure match using GetSubstructMatches but instead of returning only the atom indices also return the bond indices. Parameters: Name Type Description Default mol Mol A molecule. required query Mol A molecule used as a query to match against. required **kwargs Any Any other arguments to pass to mol.GetSubstructMatches() . {} Returns: Name Type Description atom_matches list A list of lists of atom indices. bond_matches list A list of lists of bond indices. Source code in datamol/mol.py 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 def substructure_matching_bonds ( mol : Mol , query : Mol , ** kwargs : Any ) -> Tuple [ list , list ]: \"\"\"Perform a substructure match using `GetSubstructMatches` but instead of returning only the atom indices also return the bond indices. Args: mol: A molecule. query: A molecule used as a query to match against. **kwargs: Any other arguments to pass to `mol.GetSubstructMatches()`. Returns: atom_matches: A list of lists of atom indices. bond_matches: A list of lists of bond indices. \"\"\" # NOTE(hadim): If more substructure functions are added here, consider moving it to # a dedicated `substructure` module. # Set default arguments kwargs . setdefault ( \"uniquify\" , True ) # Get the matching atom indices atom_matches = list ( mol . GetSubstructMatches ( query , ** kwargs )) # Get the bond to highligh from the query query_bond_indices = [ ( bond . GetBeginAtomIdx (), bond . GetEndAtomIdx ()) for bond in query . GetBonds () ] # Retrieve the atom indices query_atom_indices = [ atom . GetIdx () for i , atom in enumerate ( query . GetAtoms ())] bond_matches = [] for match in atom_matches : # Map the atom of the query to the atom of the mol matching the query atom_map = dict ( zip ( query_atom_indices , match )) # For this match atoms we now, we use the map to retrieve the matching bonds # in the mol. mol_bond_indices = [( atom_map [ a1 ], atom_map [ a2 ]) for a1 , a2 in query_bond_indices ] # Convert the bond atom indices to bond indices mol_bond_indices = [ mol . GetBondBetweenAtoms ( a1 , a2 ) . GetIdx () for a1 , a2 in mol_bond_indices ] bond_matches . append ( mol_bond_indices ) return atom_matches , bond_matches to_mol ( mol , add_hs = False , explicit_only = False , ordered = False , kekulize = False , sanitize = True ) \u00b6 Convert an input molecule (smiles representation) into a Mol . Parameters: Name Type Description Default mol Union [ str , Mol ] A SMILES or a molecule. required add_hs bool Whether hydrogens should be added the molecule. False explicit_only bool Whether to only add explicit hydrogen or both (implicit and explicit). when add_hs is set to True. False ordered bool Whether the atom should be ordered. This option is important if you want to ensure that the features returned will always maintain a single atom order for the same molecule, regardless of its original SMILES representation. False kekulize bool Whether to perform kekulization of the input molecules. False sanitize bool Whether to apply rdkit sanitization when input is a SMILES. True Returns: Name Type Description mol Optional [ Mol ] the molecule if some conversion have been made. If the conversion fails Optional [ Mol ] None is returned so make sure that you handle this case on your own. Source code in datamol/mol.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def to_mol ( mol : Union [ str , Mol ], add_hs : bool = False , explicit_only : bool = False , ordered : bool = False , kekulize : bool = False , sanitize : bool = True , ) -> Optional [ Mol ]: \"\"\"Convert an input molecule (smiles representation) into a `Mol`. Args: mol: A SMILES or a molecule. add_hs: Whether hydrogens should be added the molecule. explicit_only: Whether to only add explicit hydrogen or both (implicit and explicit). when `add_hs` is set to True. ordered: Whether the atom should be ordered. This option is important if you want to ensure that the features returned will always maintain a single atom order for the same molecule, regardless of its original SMILES representation. kekulize: Whether to perform kekulization of the input molecules. sanitize: Whether to apply rdkit sanitization when input is a SMILES. Returns: mol: the molecule if some conversion have been made. If the conversion fails None is returned so make sure that you handle this case on your own. \"\"\" if not isinstance ( mol , ( str , Mol )): raise ValueError ( f \"Input should be a Mol or a string instead of ' { type ( mol ) } '\" ) if isinstance ( mol , str ): _mol = MolFromSmiles ( mol , sanitize = sanitize ) if not sanitize and _mol is not None : _mol . UpdatePropertyCache ( False ) else : _mol = mol # Add hydrogens if _mol is not None and add_hs : _mol = AddHs ( _mol , explicitOnly = explicit_only , addCoords = True ) # Reorder atoms if _mol is not None and ordered : _mol = reorder_atoms ( _mol ) if _mol is not None and kekulize : Kekulize ( _mol , clearAromaticFlags = False ) return _mol to_neutral ( mol ) \u00b6 Neutralize the charge of a molecule. Parameters: Name Type Description Default mol Optional [ Mol ] a molecule. required Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def to_neutral ( mol : Optional [ Mol ]) -> Optional [ Mol ]: \"\"\"Neutralize the charge of a molecule. Args: mol: a molecule. Returns: mol: a molecule. \"\"\" if mol is None : return mol for a in mol . GetAtoms (): if a . GetFormalCharge () < 0 or ( a . GetExplicitValence () >= PERIODIC_TABLE . GetDefaultValence ( a . GetSymbol ()) and a . GetFormalCharge () > 0 ): a . SetFormalCharge ( 0 ) a . UpdatePropertyCache ( False ) return mol to_scaffold_murcko ( mol , make_generic = False ) \u00b6 Extract the Murcko scaffold from a molecule. Parameters: Name Type Description Default mol Mol A molecule. required make_generic bool Whether to make the scaffold generic. False Source code in datamol/mol.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def to_scaffold_murcko ( mol : Mol , make_generic : bool = False ): \"\"\"Extract the Murcko scaffold from a molecule. Args: mol: A molecule. make_generic: Whether to make the scaffold generic. \"\"\" scf = MurckoScaffold . GetScaffoldForMol ( mol ) # NOTE(hadim): this is already done in `GetScaffoldForMol` # Note sure we need it here. scf . UpdatePropertyCache () Chem . GetSymmSSSR ( scf ) # type: ignore if make_generic : scf = make_scaffold_generic ( scf ) scf = to_mol ( scf ) return scf unique_id ( mol ) \u00b6 A datamol unique molecule ID. The ID is an MD5 hash of the non-standard InChiKey provided by dm.to_inchikey_non_standard() . It guarantees uniqueness for different tautomeric forms of the same molecule. Parameters: Name Type Description Default mol Mol A molecule. required Source code in datamol/mol.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def unique_id ( mol : Mol ) -> Optional [ str ]: \"\"\"A datamol unique molecule ID. The ID is an MD5 hash of the non-standard InChiKey provided by `dm.to_inchikey_non_standard()`. It guarantees uniqueness for different tautomeric forms of the same molecule. Args: mol: A molecule. \"\"\" ik = to_inchikey_non_standard ( mol ) if ik is None : return None return hashlib . md5 ( ik . encode ( \"utf-8\" )) . hexdigest () Module io \u00b6 io \u00b6 read_csv ( urlpath , smiles_column = None , mol_column = 'mol' , ** kwargs ) \u00b6 Read a CSV file. Parameters: Name Type Description Default urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required smiles_column Optional [ str ] Use this column to build a mol column. None mol_column str Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. 'mol' **kwargs Any Arguments to pass to pd.read_csv() . {} Returns: Name Type Description df pd . DataFrame a pandas.DataFrame Source code in datamol/io.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def read_csv ( urlpath : Union [ str , os . PathLike , IO ], smiles_column : Optional [ str ] = None , mol_column : str = \"mol\" , ** kwargs : Any , ) -> pd . DataFrame : \"\"\"Read a CSV file. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. smiles_column: Use this column to build a mol column. mol_column: Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. **kwargs: Arguments to pass to `pd.read_csv()`. Returns: df: a `pandas.DataFrame` \"\"\" df : pd . DataFrame = pd . read_csv ( urlpath , ** kwargs ) # type: ignore if smiles_column is not None : PandasTools . AddMoleculeColumnToFrame ( df , smiles_column , mol_column ) return df read_excel ( urlpath , sheet_name = 0 , smiles_column = None , mol_column = 'mol' , ** kwargs ) \u00b6 Read an excel file. Parameters: Name Type Description Default urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required sheet_name Optional [ Union [ str , int , list ]] see pandas.read_excel() doc. 0 mol_column str Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. 'mol' mol_column str name to give to the mol column. 'mol' **kwargs Any Arguments to pass to pd.read_excel() . {} Returns: Name Type Description df pd . DataFrame a pandas.DataFrame Source code in datamol/io.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def read_excel ( urlpath : Union [ str , os . PathLike , IO ], sheet_name : Optional [ Union [ str , int , list ]] = 0 , smiles_column : Optional [ str ] = None , mol_column : str = \"mol\" , ** kwargs : Any , ) -> pd . DataFrame : \"\"\"Read an excel file. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. sheet_name: see `pandas.read_excel()` doc. mol_column: Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. mol_column: name to give to the mol column. **kwargs: Arguments to pass to `pd.read_excel()`. Returns: df: a `pandas.DataFrame` \"\"\" df = pd . read_excel ( urlpath , sheet_name = sheet_name , ** kwargs ) df = cast ( pd . DataFrame , df ) if smiles_column is not None : PandasTools . AddMoleculeColumnToFrame ( df , smiles_column , mol_column ) return df read_molblock ( molblock , sanitize = True , strict_parsing = True , remove_hs = True , fail_if_invalid = False ) \u00b6 Read a Mol block. Note that potential molecule properties are not read. Parameters: Name Type Description Default molblock str String containing the Mol block. required sanitize bool Whether to sanitize the molecules. True strict_parsing bool If set to false, the parser is more lax about correctness of the contents. True remove_hs bool Whether to remove the existing hydrogens in the SDF files. True fail_if_invalid bool If set to true, the parser will raise an exception if the molecule is invalid instead of returning None. False Source code in datamol/io.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def read_molblock ( molblock : str , sanitize : bool = True , strict_parsing : bool = True , remove_hs : bool = True , fail_if_invalid : bool = False , ) -> Optional [ dm . Mol ]: \"\"\"Read a Mol block. Note that potential molecule properties are **not** read. Args: molblock: String containing the Mol block. sanitize: Whether to sanitize the molecules. strict_parsing: If set to false, the parser is more lax about correctness of the contents. remove_hs: Whether to remove the existing hydrogens in the SDF files. fail_if_invalid: If set to true, the parser will raise an exception if the molecule is invalid instead of returning None. \"\"\" mol = rdmolfiles . MolFromMolBlock ( molblock , sanitize = sanitize , removeHs = remove_hs , strictParsing = strict_parsing , ) if mol is None and fail_if_invalid : raise ValueError ( f \"Invalid molecule: { molblock } \" ) return mol read_sdf ( urlpath , sanitize = True , as_df = False , smiles_column = 'smiles' , mol_column = None , include_private = False , include_computed = False , strict_parsing = True , remove_hs = True ) \u00b6 Read an SDF file. Note: This function is meant to be used with dataset that fit in-memory . For a more advanced usage we suggest you to use directly Chem.ForwardSDMolSupplier . Parameters: Name Type Description Default urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required sanitize bool Whether to sanitize the molecules. True as_df bool Whether to return a list mol or a pandas DataFrame. False smiles_column Optional [ str ] Name of the SMILES column. Only relevant if as_df is True. 'smiles' mol_column Optional [ str ] Name of the mol column. Only relevant if as_df is True. None include_private bool Include private properties in the columns. Only relevant if as_df is True. False include_computed bool Include computed properties in the columns. Only relevant if as_df is True. False strict_parsing bool If set to false, the parser is more lax about correctness of the contents. True remove_hs bool Whether to remove the existing hydrogens in the SDF files. True Source code in datamol/io.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def read_sdf ( urlpath : Union [ str , os . PathLike , IO ], sanitize : bool = True , as_df : bool = False , smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , include_private : bool = False , include_computed : bool = False , strict_parsing : bool = True , remove_hs : bool = True , ) -> Union [ List [ Mol ], pd . DataFrame ]: \"\"\"Read an SDF file. Note: This function is meant to be used with dataset that fit _in-memory_. For a more advanced usage we suggest you to use directly `Chem.ForwardSDMolSupplier`. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. sanitize: Whether to sanitize the molecules. as_df: Whether to return a list mol or a pandas DataFrame. smiles_column: Name of the SMILES column. Only relevant if `as_df` is True. mol_column: Name of the mol column. Only relevant if `as_df` is True. include_private: Include private properties in the columns. Only relevant if `as_df` is True. include_computed: Include computed properties in the columns. Only relevant if `as_df` is True. strict_parsing: If set to false, the parser is more lax about correctness of the contents. remove_hs: Whether to remove the existing hydrogens in the SDF files. \"\"\" # File-like object if isinstance ( urlpath , io . IOBase ): supplier = rdmolfiles . ForwardSDMolSupplier ( urlpath , sanitize = sanitize , strictParsing = strict_parsing , removeHs = remove_hs , ) mols = list ( supplier ) # Regular local or remote paths else : with fsspec . open ( urlpath ) as f : # Handle gzip file if needed if str ( urlpath ) . endswith ( \".gz\" ) or str ( urlpath ) . endswith ( \".gzip\" ): f = gzip . open ( f ) # type: ignore supplier = rdmolfiles . ForwardSDMolSupplier ( f , sanitize = sanitize , strictParsing = strict_parsing , removeHs = remove_hs , ) mols = list ( supplier ) # Discard None values mols = [ mol for mol in mols if mol is not None ] # Convert to dataframe if as_df : return dm . to_df ( mols , smiles_column = smiles_column , mol_column = mol_column , include_private = include_private , include_computed = include_computed , ) # type: ignore return mols read_smi ( urlpath ) \u00b6 Read a list of smiles from am .smi file. Parameters: Name Type Description Default urlpath Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ] Path to a file or a file-like object. Path can be remote or local. Note: file-like object are not supported yet. required Source code in datamol/io.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def read_smi ( urlpath : Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ], ) -> Sequence [ Mol ]: \"\"\"Read a list of smiles from am `.smi` file. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. Note: file-like object are not supported yet. \"\"\" active_path = urlpath # NOTE(hadim): the temporary local file copy # is because `SmilesMolSupplier` does not support # using file-like object, only path. # Copy to a local temporary path if the path is a remote one. if not fsspec . utils . can_be_local ( str ( urlpath )): active_path = pathlib . Path ( tempfile . mkstemp ()[ 1 ]) dm . utils . fs . copy_file ( urlpath , active_path ) # Read the molecules supplier = rdmolfiles . SmilesMolSupplier ( str ( active_path ), titleLine = 0 ) mols = [ mol for mol in supplier if mol is not None ] # Delete the local temporary path if not fsspec . utils . can_be_local ( str ( urlpath )): pathlib . Path ( str ( active_path )) . unlink () return mols to_molblock ( mol , include_stereo = True , conf_id =- 1 , kekulize = True , force_V3000 = False ) \u00b6 Convert a molecule to a mol block string. Note that any molecule properties are lost. Parameters: Name Type Description Default mol Mol A molecule. required include_stereo bool Toggles inclusion of stereochemical information in the output. True conf_id int Selects which conformation to output. -1 kekulize bool Triggers kekulization of the molecule before it's written, as suggested by the MDL spec. True force_V3000 bool Force generation a V3000 mol block (happens automatically with more than 999 atoms or bonds). False Source code in datamol/io.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def to_molblock ( mol : Mol , include_stereo : bool = True , conf_id : int = - 1 , kekulize : bool = True , force_V3000 : bool = False , ): \"\"\"Convert a molecule to a mol block string. Note that any molecule properties are lost. Args: mol: A molecule. include_stereo: Toggles inclusion of stereochemical information in the output. conf_id: Selects which conformation to output. kekulize: Triggers kekulization of the molecule before it's written, as suggested by the MDL spec. force_V3000: Force generation a V3000 mol block (happens automatically with more than 999 atoms or bonds). \"\"\" molblock = rdmolfiles . MolToMolBlock ( mol , includeStereo = include_stereo , confId = conf_id , kekulize = kekulize , forceV3000 = force_V3000 , ) return molblock to_sdf ( mols , urlpath , smiles_column = 'smiles' , mol_column = None ) \u00b6 Write molecules to a file. Parameters: Name Type Description Default mols Union [ Mol , Sequence [ Mol ], pd . DataFrame ] a dataframe, a molecule or a list of molecule. required urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required smiles_column Optional [ str ] Column name to extract the molecule. 'smiles' mol_column Optional [ str ] Column name to extract the molecule. It takes precedence over smiles_column . None Source code in datamol/io.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def to_sdf ( mols : Union [ Mol , Sequence [ Mol ], pd . DataFrame ], urlpath : Union [ str , os . PathLike , IO ], smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , ): \"\"\"Write molecules to a file. Args: mols: a dataframe, a molecule or a list of molecule. urlpath: Path to a file or a file-like object. Path can be remote or local. smiles_column: Column name to extract the molecule. mol_column: Column name to extract the molecule. It takes precedence over `smiles_column`. \"\"\" if isinstance ( mols , pd . DataFrame ): mols = dm . from_df ( mols , smiles_column = smiles_column , mol_column = mol_column ) elif isinstance ( mols , Mol ): mols = [ mols ] # Filter out None values mols = [ mol for mol in mols if mol is not None ] # File-like object if isinstance ( urlpath , io . IOBase ): writer = rdmolfiles . SDWriter ( urlpath ) for mol in mols : writer . write ( mol ) writer . close () # Regular local or remote paths else : with fsspec . open ( urlpath , mode = \"w\" ) as f : writer = rdmolfiles . SDWriter ( f ) for mol in mols : writer . write ( mol ) writer . close () to_smi ( mols , urlpath , error_if_empty = False ) \u00b6 Save a list of molecules in an .smi file. Parameters: Name Type Description Default mols Sequence [ Mol ] a list of molecules. required urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required error_if_empty bool whether to raise and error if the input list is empty. False Source code in datamol/io.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def to_smi ( mols : Sequence [ Mol ], urlpath : Union [ str , os . PathLike , IO ], error_if_empty : bool = False , ): \"\"\"Save a list of molecules in an `.smi` file. Args: mols: a list of molecules. urlpath: Path to a file or a file-like object. Path can be remote or local. error_if_empty: whether to raise and error if the input list is empty. \"\"\" if len ( mols ) == 0 and error_if_empty : raise ValueError ( \"The list of mols/smiles provided is empty.\" ) # Filter out None values mols = [ mol for mol in mols if mol is not None ] # File-like object if isinstance ( urlpath , io . IOBase ): writer = rdmolfiles . SmilesWriter ( urlpath , includeHeader = False , nameHeader = \"\" ) for mol in mols : writer . write ( mol ) writer . close () # Regular local or remote paths else : with fsspec . open ( urlpath , \"w\" ) as f : writer = rdmolfiles . SmilesWriter ( f , includeHeader = False , nameHeader = \"\" ) for mol in mols : writer . write ( mol ) writer . close () to_xlsx ( mols , urlpath , smiles_column = 'smiles' , mol_column = 'mol' , mol_size = [ 300 , 300 ]) \u00b6 Write molecules to an Excel file with a molecule column as an RDKit rendered image. Parameters: Name Type Description Default mols Union [ Mol , Sequence [ Mol ], pd . DataFrame ] a dataframe, a molecule or a list of molecule. required urlpath Union [ str , os . PathLike ] Path to a file or a file-like object. Path can be remote or local. required smiles_column Optional [ str ] Column name to extract the molecule. 'smiles' mol_column str Column name to extract the molecule. It takes precedence over smiles_column . Column name to write the RDKit rendered image. If none, the molecule images are not written. 'mol' Source code in datamol/io.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def to_xlsx ( mols : Union [ Mol , Sequence [ Mol ], pd . DataFrame ], urlpath : Union [ str , os . PathLike ], smiles_column : Optional [ str ] = \"smiles\" , mol_column : str = \"mol\" , mol_size : List [ int ] = [ 300 , 300 ], ): \"\"\"Write molecules to an Excel file with a molecule column as an RDKit rendered image. Args: mols: a dataframe, a molecule or a list of molecule. urlpath: Path to a file or a file-like object. Path can be remote or local. smiles_column: Column name to extract the molecule. mol_column: Column name to extract the molecule. It takes precedence over `smiles_column`. Column name to write the RDKit rendered image. If none, the molecule images are not written. \"\"\" if isinstance ( mols , Mol ): mols = [ mols ] if isinstance ( mols , Sequence ): mols = [ mol for mol in mols if mol is not None ] mols = dm . to_df ( mols , smiles_column = smiles_column , mol_column = mol_column ) if mols is None or mols . empty : # type: ignore raise ValueError ( \"No molecules to write\" ) with fsspec . open ( urlpath , mode = \"wb\" ) as f : PandasTools . SaveXlsxFromFrame ( mols , f , molCol = mol_column , size = mol_size ) Module convert \u00b6 convert \u00b6 from_df ( df , smiles_column = 'smiles' , mol_column = None , conserve_smiles = False , sanitize = True ) \u00b6 Convert a dataframe to a list of mols. For the reverse operation, you might to check dm.to_df() . Note If smiles_column is used to build the molecules, this property is removed from the molecules' properties. You can decide to conserve the SMILES column by setting conserve_smiles to True. Parameters: Name Type Description Default df pd . DataFrame a dataframe. required smiles_column Optional [ str ] Column name to extract the molecule. 'smiles' mol_column Optional [ str ] Column name to extract the molecule. It takes precedence over smiles_column . None conserve_smiles bool Whether to conserve the SMILES in the mols' props. False sanitize bool Whether to sanitize if smiles_column is not None. True Source code in datamol/convert.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def from_df ( df : pd . DataFrame , smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , conserve_smiles : bool = False , sanitize : bool = True , ) -> List [ Mol ]: \"\"\"Convert a dataframe to a list of mols. For the reverse operation, you might to check `dm.to_df()`. Note: If `smiles_column` is used to build the molecules, this property is removed from the molecules' properties. You can decide to conserve the SMILES column by setting `conserve_smiles` to True. Args: df: a dataframe. smiles_column: Column name to extract the molecule. mol_column: Column name to extract the molecule. It takes precedence over `smiles_column`. conserve_smiles: Whether to conserve the SMILES in the mols' props. sanitize: Whether to sanitize if `smiles_column` is not None. \"\"\" if smiles_column is None and mol_column is None : raise ValueError ( \"Either `smiles_column` or `mol_column` must be not None.\" ) if len ( df ) == 0 : return [] # Try to detect the mol column if `mol_column` is None. if mol_column is None : for col in df . columns : if isinstance ( df [ col ] . iloc [ 0 ], Mol ): mol_column = col def _row_to_mol ( row ): props = row . to_dict () if mol_column is not None : mol = props . pop ( mol_column ) else : if conserve_smiles : smiles = props [ smiles_column ] else : # If a SMILES column is used to create the molecule then it is removed from the # properties. smiles = props . pop ( smiles_column ) mol = dm . to_mol ( smiles , sanitize = sanitize ) if mol is None : return None dm . set_mol_props ( mol , props ) return mol return df . apply ( _row_to_mol , axis = 1 ) . tolist () from_inchi ( inchi , sanitize = True , remove_hs = True ) \u00b6 Convert an InChi to a mol. Parameters: Name Type Description Default inchi Optional [ str ] an inchi string. required sanitize bool do sanitize. True remove_hs bool do remove hs. True Returns: Type Description Optional [ Mol ] mol Source code in datamol/convert.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def from_inchi ( inchi : Optional [ str ], sanitize : bool = True , remove_hs : bool = True , ) -> Optional [ Mol ]: \"\"\"Convert an InChi to a mol. Args: inchi: an inchi string. sanitize: do sanitize. remove_hs: do remove hs. Returns: mol \"\"\" if inchi is None : return None return Chem . MolFromInchi ( inchi , sanitize = sanitize , removeHs = remove_hs ) from_selfies ( selfies , as_mol = False ) \u00b6 Convert a SEFLIES to a smiles or a mol. Parameters: Name Type Description Default selfies str a selfies. required as_mol str whether to return a mol or a smiles. False Returns: Type Description Optional [ Union [ str , Mol ]] smiles or mol. Source code in datamol/convert.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def from_selfies ( selfies : str , as_mol : bool = False ) -> Optional [ Union [ str , Mol ]]: \"\"\"Convert a SEFLIES to a smiles or a mol. Args: selfies: a selfies. as_mol (str, optional): whether to return a mol or a smiles. Returns: smiles or mol. \"\"\" if selfies is None : return None smiles = sf . decoder ( selfies ) if as_mol and smiles is not None : return dm . to_mol ( smiles ) return smiles from_smarts ( smarts ) \u00b6 Convert a SMARTS string to a molecule Parameters: Name Type Description Default smarts Optional [ str ] a smarts string required Source code in datamol/convert.py 347 348 349 350 351 352 353 354 355 356 def from_smarts ( smarts : Optional [ str ]) -> Optional [ Mol ]: \"\"\"Convert a SMARTS string to a molecule Args: smarts: a smarts string \"\"\" if smarts is None : return None return Chem . MolFromSmarts ( smarts ) # type: ignore render_mol_df ( df ) \u00b6 Render the molecules column in a dataframe. The rendering is performed in-place only. So nothing is returned. Parameters: Name Type Description Default df pd . DataFrame a dataframe. required Source code in datamol/convert.py 491 492 493 494 495 496 497 498 499 500 def render_mol_df ( df : pd . DataFrame ): \"\"\"Render the molecules column in a dataframe. The rendering is performed in-place only. So nothing is returned. Args: df: a dataframe. \"\"\" # NOTE(hadim): replace by `PandaTools.ChangeMoleculeRendering` once # https://github.com/rdkit/rdkit/issues/3563 is fixed. _ChangeMoleculeRendering ( df ) smiles_as_smarts ( mol , keep_hs = True ) \u00b6 Convert a smiles to a smarts if possible Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule. required keep_hs bool Whether to keep hydrogen. This will increase the count of H atoms for atoms with attached hydrogens to create a valid smarts without further substitution allowed e.g. [H]-[CH]-[ ] -> [H]-[CH2]-[ ] True Returns: Type Description Optional [ str ] smarts of the molecule Source code in datamol/convert.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def smiles_as_smarts ( mol : Union [ str , Mol ], keep_hs : bool = True ) -> Optional [ str ]: \"\"\"Convert a smiles to a smarts if possible Args: mol: a molecule. keep_hs: Whether to keep hydrogen. This will increase the count of H atoms for atoms with attached hydrogens to create a valid smarts without further substitution allowed e.g. [H]-[CH]-[*] -> [H]-[CH2]-[*] Returns: smarts of the molecule \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None # Change the isotope to 99 for atom in mol . GetAtoms (): # type: ignore if keep_hs : s = sum ( na . GetAtomicNum () == 1 for na in atom . GetNeighbors ()) if s : atom . SetNumExplicitHs ( atom . GetTotalNumHs () + s ) atom . SetIsotope ( 99 ) # Print out the smiles, all the atom attributes will be fully specified smarts = to_smiles ( mol , isomeric = True , explicit_bonds = True ) if smarts is None : return None # Remove the 99 isotope labels smarts = re . sub ( r \"\\[99\" , \"[\" , smarts ) return smarts to_df ( mols , smiles_column = 'smiles' , mol_column = None , include_private = False , include_computed = False , render_df_mol = True , render_all_df_mol = False ) \u00b6 Convert a list of mols to a dataframe using each mol properties as a column. For the reverse operation, you might to check dm.from_df() . Parameters: Name Type Description Default mols List [ Mol ] a molecule. required smiles_column Optional [ str ] name of the SMILES column. 'smiles' mol_column Optional [ str ] Name of the column. If not None, rdkit.Chem.PandaTools is used to add a molecule column. None include_private bool Include private properties in the columns. False include_computed bool Include computed properties in the columns. False render_df_mol bool whether to render the molecule in the dataframe to images. If called once, it will be applied for the newly created dataframe with mol in it. True render_all_df_mol bool Whether to render all pandas dataframe mol column as images. False Source code in datamol/convert.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def to_df ( mols : List [ Mol ], smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , include_private : bool = False , include_computed : bool = False , render_df_mol : bool = True , render_all_df_mol : bool = False , ) -> Optional [ pd . DataFrame ]: \"\"\"Convert a list of mols to a dataframe using each mol properties as a column. For the reverse operation, you might to check `dm.from_df()`. Args: mols: a molecule. smiles_column: name of the SMILES column. mol_column: Name of the column. If not None, rdkit.Chem.PandaTools is used to add a molecule column. include_private: Include private properties in the columns. include_computed: Include computed properties in the columns. render_df_mol: whether to render the molecule in the dataframe to images. If called once, it will be applied for the newly created dataframe with mol in it. render_all_df_mol: Whether to render all pandas dataframe mol column as images. \"\"\" # Init a dataframe df = pd . DataFrame () # Feed it with smiles if smiles_column is not None : smiles = [ to_smiles ( mol ) for mol in mols ] df [ smiles_column ] = smiles # Add a mol column if mol_column is not None : df [ mol_column ] = mols # Add any other properties present in the molecule props = [ mol . GetPropsAsDict ( includePrivate = include_private , includeComputed = include_computed , ) for mol in mols ] props_df = pd . DataFrame ( props ) if smiles_column is not None and smiles_column in props_df . columns : logger . warning ( f \"The SMILES column name provided (' { smiles_column } ') is already present in the properties\" \" of the molecules. THe returned dataframe will two columns with the same name.\" ) # Concat the df with the properties df df = pd . concat ([ df , props_df ], axis = 1 ) # Render mol column to images if render_df_mol is True and mol_column is not None : render_mol_df ( df ) if render_all_df_mol : PandasTools . RenderImagesInAllDataFrames () return df to_inchi ( mol ) \u00b6 Convert a mol to a standard Inchi. Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule. required Source code in datamol/convert.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def to_inchi ( mol : Union [ str , Mol ]) -> Optional [ str ]: \"\"\"Convert a mol to a standard Inchi. Args: mol: a molecule. \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchi_val = Chem . MolToInchi ( mol ) if not inchi_val : return None return inchi_val to_inchi_non_standard ( mol , fixed_hydrogen_layer = True , undefined_stereocenter = True , reconnected_metal_layer = True , tautomerism_keto_enol = True , tautomerism_15 = True , options = None ) \u00b6 Convert a mol to a non-standard Inchi. Note that turning all the flags to False will result in the standard Inchi. Warning : this function will return a non-standard Inchi. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChi. If you don't know much about non-standard InChi, we highly recommend you to use the standard InChi with dm.to_inchi() . Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule. required fixed_hydrogen_layer bool whether to include a fixed hydrogen layer ( /FixedH ). True undefined_stereocenter bool whether to include an undefined stereocenter layer ( /SUU ). True reconnected_metal_layer bool whether to include reconnected metals ( /RecMet ). True tautomerism_keto_enol bool whether to account tautomerism keto-enol ( /KET ). True tautomerism_15 bool whether to account 1,5-tautomerism ( /15T ). True options Optional [ List [ str ]] More InchI options in a form of a list of string. Example: [\"/SRel\", \"/AuxNone\"] . None Source code in datamol/convert.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def to_inchi_non_standard ( mol : Union [ str , Mol ], fixed_hydrogen_layer : bool = True , undefined_stereocenter : bool = True , reconnected_metal_layer : bool = True , tautomerism_keto_enol : bool = True , tautomerism_15 : bool = True , options : Optional [ List [ str ]] = None , ) -> Optional [ str ]: \"\"\"Convert a mol to a non-standard Inchi. Note that turning all the flags to `False` will result in the standard Inchi. **Warning**: this function will return a **non-standard** Inchi. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChi. If you don't know much about non-standard InChi, we highly recommend you to use the standard InChi with `dm.to_inchi()`. Args: mol: a molecule. fixed_hydrogen_layer: whether to include a fixed hydrogen layer (`/FixedH`). undefined_stereocenter: whether to include an undefined stereocenter layer (`/SUU`). reconnected_metal_layer: whether to include reconnected metals (`/RecMet`). tautomerism_keto_enol: whether to account tautomerism keto-enol (`/KET`). tautomerism_15: whether to account 1,5-tautomerism (`/15T`). options: More InchI options in a form of a list of string. Example: `[\"/SRel\", \"/AuxNone\"]`. \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchi_options = _process_inchi_options ( fixed_hydrogen_layer = fixed_hydrogen_layer , undefined_stereocenter = undefined_stereocenter , reconnected_metal_layer = reconnected_metal_layer , tautomerism_keto_enol = tautomerism_keto_enol , tautomerism_15 = tautomerism_15 , options = options , ) inchi_val = Chem . MolToInchi ( mol , options = inchi_options ) if not inchi_val : return None return inchi_val to_inchikey ( mol ) \u00b6 Convert a mol to a standard InchiKey. Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule required Source code in datamol/convert.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def to_inchikey ( mol : Union [ str , Mol ]) -> Optional [ str ]: \"\"\"Convert a mol to a standard InchiKey. Args: mol: a molecule \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchikey = Chem . MolToInchiKey ( mol ) if not inchikey : return None return inchikey to_inchikey_non_standard ( mol , fixed_hydrogen_layer = True , undefined_stereocenter = True , reconnected_metal_layer = True , tautomerism_keto_enol = True , tautomerism_15 = True , options = None ) \u00b6 Convert a mol to a non-standard InchiKey. Note that turning all the flags to False will result in the standard InchiKey. Warning : this function will return a non-standard InchiKey. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChiKey. If you don't know much about non-standard InchiKey, we highly recommend you to use the standard InchiKey with dm.to_inchikey() . Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule required fixed_hydrogen_layer bool whether to include a fixed hydrogen layer ( /FixedH ). True undefined_stereocenter bool whether to include an undefined stereocenter layer ( /SUU ). True reconnected_metal_layer bool whether to include reconnected metals ( /RecMet ). True tautomerism_keto_enol bool whether to account tautomerism keto-enol ( /KET ). True tautomerism_15 bool whether to account 1,5-tautomerism ( /15T ). True options Optional [ List [ str ]] More InchI options in a form of a list of string. Example: [\"/SRel\", \"/AuxNone\"] . None Source code in datamol/convert.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def to_inchikey_non_standard ( mol : Union [ str , Mol ], fixed_hydrogen_layer : bool = True , undefined_stereocenter : bool = True , reconnected_metal_layer : bool = True , tautomerism_keto_enol : bool = True , tautomerism_15 : bool = True , options : Optional [ List [ str ]] = None , ) -> Optional [ str ]: \"\"\"Convert a mol to a non-standard InchiKey. Note that turning all the flags to `False` will result in the standard InchiKey. **Warning**: this function will return a **non-standard** InchiKey. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChiKey. If you don't know much about non-standard InchiKey, we highly recommend you to use the standard InchiKey with `dm.to_inchikey()`. Args: mol: a molecule fixed_hydrogen_layer: whether to include a fixed hydrogen layer (`/FixedH`). undefined_stereocenter: whether to include an undefined stereocenter layer (`/SUU`). reconnected_metal_layer: whether to include reconnected metals (`/RecMet`). tautomerism_keto_enol: whether to account tautomerism keto-enol (`/KET`). tautomerism_15: whether to account 1,5-tautomerism (`/15T`). options: More InchI options in a form of a list of string. Example: `[\"/SRel\", \"/AuxNone\"]`. \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchi_options = _process_inchi_options ( fixed_hydrogen_layer = fixed_hydrogen_layer , undefined_stereocenter = undefined_stereocenter , reconnected_metal_layer = reconnected_metal_layer , tautomerism_keto_enol = tautomerism_keto_enol , tautomerism_15 = tautomerism_15 , options = options , ) inchikey = Chem . MolToInchiKey ( mol , options = inchi_options ) if not inchikey : return None return inchikey to_selfies ( mol ) \u00b6 Convert a mol to SELFIES. Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule or a SMILES. required Returns: Name Type Description selfies Optional [ str ] SELFIES string. Source code in datamol/convert.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def to_selfies ( mol : Union [ str , Mol ]) -> Optional [ str ]: \"\"\"Convert a mol to SELFIES. Args: mol: a molecule or a SMILES. Returns: selfies: SELFIES string. \"\"\" if isinstance ( mol , Mol ): mol = to_smiles ( mol ) if mol is None : return None selfies = sf . encoder ( mol ) if selfies == - 1 : return None return selfies to_smarts ( mol ) \u00b6 Convert a mol to SMARTS format Parameters: Name Type Description Default mol Mol a molecule. required Source code in datamol/convert.py 243 244 245 246 247 248 249 250 251 252 253 def to_smarts ( mol : Mol ) -> Optional [ str ]: \"\"\"Convert a mol to SMARTS format Args: mol: a molecule. \"\"\" if mol is None : return None return Chem . MolToSmarts ( mol ) # type: ignore to_smiles ( mol , canonical = True , isomeric = True , kekulize = False , ordered = False , explicit_bonds = False , explicit_hs = False , randomize = False , cxsmiles = False , allow_to_fail = False ) \u00b6 Convert a mol to a SMILES. Parameters: Name Type Description Default mol Mol a molecule. required canonical bool if false no attempt will be made to canonicalize the molecule. True isomeric bool whether to include information about stereochemistry in the SMILES. True kekulize bool whether to return the kekule version of the SMILES. False ordered bool whether to force reordering of the atoms first. False explicit_bonds bool if true, all bond orders will be explicitly indicated in the output SMILES. False explicit_hs bool if true, all H counts will be explicitly indicated in the output SMILES. False randomize bool whether to randomize the generated smiles. Override canonical . False cxsmiles bool Whether to return a CXSMILES instead of a SMILES. False allow_to_fail bool Raise an error if the conversion to SMILES fails. Return None otherwise. False Source code in datamol/convert.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def to_smiles ( mol : Mol , canonical : bool = True , isomeric : bool = True , kekulize : bool = False , ordered : bool = False , explicit_bonds : bool = False , explicit_hs : bool = False , randomize : bool = False , cxsmiles : bool = False , allow_to_fail : bool = False , ) -> Optional [ str ]: \"\"\"Convert a mol to a SMILES. Args: mol: a molecule. canonical: if false no attempt will be made to canonicalize the molecule. isomeric: whether to include information about stereochemistry in the SMILES. kekulize: whether to return the kekule version of the SMILES. ordered: whether to force reordering of the atoms first. explicit_bonds: if true, all bond orders will be explicitly indicated in the output SMILES. explicit_hs: if true, all H counts will be explicitly indicated in the output SMILES. randomize: whether to randomize the generated smiles. Override `canonical`. cxsmiles: Whether to return a CXSMILES instead of a SMILES. allow_to_fail: Raise an error if the conversion to SMILES fails. Return None otherwise. \"\"\" if ordered and canonical is False : mol = dm . reorder_atoms ( mol ) if randomize : mol = dm . randomize_atoms ( mol ) canonical = False smiles = None try : if cxsmiles : smiles = rdmolfiles . MolToCXSmiles ( mol , isomericSmiles = isomeric , canonical = canonical , allBondsExplicit = explicit_bonds , allHsExplicit = explicit_hs , kekuleSmiles = kekulize , ) else : smiles = rdmolfiles . MolToSmiles ( mol , isomericSmiles = isomeric , canonical = canonical , allBondsExplicit = explicit_bonds , allHsExplicit = explicit_hs , kekuleSmiles = kekulize , ) except Exception as e : if allow_to_fail : raise e return None return smiles Module cluster \u00b6 cluster \u00b6 assign_to_centroids ( mols , centroids , feature_fn = None , dist_fn = None , n_jobs = 1 ) \u00b6 Assign molecules to centroids. Each molecule will be assigned to the closest centroid. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules to assign to centroids required centroids List [ Mol ] list of molecules to use as centroid required feature_fn Optional [ Callable ] A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None dist_fn Optional [ Callable ] A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. None n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Returns: Name Type Description clusters_map dict dict of index mapping each centroid index to the molecule index in the cluster clusters_list list list of all molecules in each cluster. The cluster index follows the index of the centroid. Note that the centroid molecule is not added to the cluster. Source code in datamol/cluster.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def assign_to_centroids ( mols : List [ Mol ], centroids : List [ Mol ], feature_fn : Optional [ Callable ] = None , dist_fn : Optional [ Callable ] = None , n_jobs : Optional [ int ] = 1 , ) -> Tuple [ dict , list ]: r \"\"\"Assign molecules to centroids. Each molecule will be assigned to the closest centroid. Args: mols: a list of molecules to assign to centroids centroids: list of molecules to use as centroid feature_fn: A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. dist_fn: A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. Returns: clusters_map: dict of index mapping each centroid index to the molecule index in the cluster clusters_list: list of all molecules in each cluster. The cluster index follows the index of the centroid. Note that the centroid molecule is not added to the cluster. \"\"\" if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) all_mols = [ x for x in mols ] + [ c for c in centroids ] features = dm . parallelized ( feature_fn , all_mols , n_jobs = n_jobs ) def distij ( i , j , features = features ): return 1.0 - DataStructs . cDataStructs . TanimotoSimilarity ( features [ int ( i )], features [ int ( j )]) if dist_fn is None : dist_fn = distij clusters_map = ddict ( list ) clusters_list = [[] for _ in centroids ] query_inds = np . expand_dims ( np . arange ( len ( mols ), dtype = int ), axis = 1 ) centroid_inds = np . expand_dims ( np . arange ( len ( centroids ), dtype = int ), axis = 1 ) + len ( mols ) dist_mat = distance . cdist ( query_inds , centroid_inds , metric = distij ) closest = np . argmin ( dist_mat , axis = 1 ) for ind , cluster_ind in enumerate ( closest ): # type: ignore clusters_map [ cluster_ind ] . append ( ind ) clusters_list [ cluster_ind ] . append ( mols [ ind ]) return clusters_map , clusters_list cluster_mols ( mols , cutoff = 0.2 , feature_fn = None , n_jobs = 1 ) \u00b6 Cluster a set of molecules using the butina clustering algorithm and a given threshold. Parameters: Name Type Description Default mols Union [ Sequence [ Mol ], pd . Series ] a list of molecules. required cutoff float Cuttoff for the clustering. Default to 0.2. 0.2 feature_fn Optional [ Callable ] A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Source code in datamol/cluster.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def cluster_mols ( mols : Union [ Sequence [ Mol ], pd . Series ], cutoff : float = 0.2 , feature_fn : Optional [ Callable ] = None , n_jobs : Optional [ int ] = 1 , ): \"\"\"Cluster a set of molecules using the butina clustering algorithm and a given threshold. Args: mols: a list of molecules. cutoff: Cuttoff for the clustering. Default to 0.2. feature_fn: A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. \"\"\" if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) features = dm . parallelized ( feature_fn , mols , n_jobs = n_jobs ) dists = [] n_mols = len ( mols ) for i in range ( 1 , n_mols ): dist = DataStructs . cDataStructs . BulkTanimotoSimilarity ( features [ i ], features [: i ], returnDistance = True ) dists . extend ([ x for x in dist ]) # now cluster the data cluster_indices = Butina . ClusterData ( dists , n_mols , cutoff , isDistData = True ) cluster_mols = [ operator . itemgetter ( * cluster )( mols ) for cluster in cluster_indices ] # Make single mol cluster a list cluster_mols = [[ c ] if isinstance ( c , Mol ) else c for c in cluster_mols ] return cluster_indices , cluster_mols pick_centroids ( mols , npick = 0 , initial_picks = None , threshold = 0.5 , feature_fn = None , dist_fn = None , seed = 42 , method = 'sphere' , n_jobs = 1 ) \u00b6 Pick a set of npick centroids from a list of molecules. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules. required npick int Number of element to pick from mols, including the preselection. 0 threshold float Minimum distance between centroids for maxmin and sphere exclusion ( sphere ) methods. 0.5 initial_picks Optional [ List [ int ]] Starting list of index for molecules that should be in the set of picked molecules. Default to None. None feature_fn callable A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None dist_fn Optional [ Callable ] A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. None seed int seed for reproducibility 42 method str Picking method to use. One of sphere , maxmin or any supported rdkit hierarchical clustering method such as centroid , clink , upgma 'sphere' n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Returns: Name Type Description picked_inds int index of the molecule that have been selected as centroids mols list molecules that have been picked Source code in datamol/cluster.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def pick_centroids ( mols : List [ Mol ], npick : int = 0 , initial_picks : Optional [ List [ int ]] = None , threshold : float = 0.5 , feature_fn : Optional [ Callable ] = None , dist_fn : Optional [ Callable ] = None , seed : int = 42 , method : str = \"sphere\" , n_jobs : Optional [ int ] = 1 , ) -> Tuple [ int , list ]: r \"\"\"Pick a set of `npick` centroids from a list of molecules. Args: mols: a list of molecules. npick: Number of element to pick from mols, including the preselection. threshold: Minimum distance between centroids for `maxmin` and sphere exclusion (`sphere`) methods. initial_picks: Starting list of index for molecules that should be in the set of picked molecules. Default to None. feature_fn (callable, optional): A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. dist_fn: A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. seed: seed for reproducibility method: Picking method to use. One of `sphere`, `maxmin` or any supported rdkit hierarchical clustering method such as `centroid`, `clink`, `upgma` n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. Returns: picked_inds: index of the molecule that have been selected as centroids mols: molecules that have been picked \"\"\" n_mols = len ( mols ) if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) features = dm . parallelized ( feature_fn , mols , n_jobs = n_jobs ) def distij ( i , j , features = features ): return 1.0 - DataStructs . cDataStructs . TanimotoSimilarity ( features [ i ], features [ j ]) if dist_fn is None : dist_fn = distij initial_picks = [] if initial_picks is None else initial_picks if method == \"maxmin\" : picker = MaxMinPicker () picked_inds , _ = picker . LazyPickWithThreshold ( dist_fn , n_mols , pickSize = npick , threshold = threshold , firstPicks = initial_picks , seed = seed , ) elif method == \"sphere\" : picker = LeaderPicker () picked_inds = picker . LazyPick ( dist_fn , n_mols , threshold = threshold , pickSize = npick , firstPicks = initial_picks ) elif method . upper () in ClusterMethod . names . keys () and npick : if initial_picks : logger . warning ( \"Initial picks is not supported by hierarchical clustering. You pick has been discarded.\" ) dist_mat = dm . parallelized ( distij , list ( zip ( * np . tril_indices ( len ( mols ), k =- 1 ))), arg_type = \"args\" ) dist_mat = np . asarray ( dist_mat ) picker = HierarchicalClusterPicker ( ClusterMethod . names [ method . upper ()]) picked_inds = picker . Pick ( dist_mat , n_mols , npick ) else : raise ValueError ( f \"Picking method { method } with { npick } elements to pick is not supported.\" ) picked_inds = np . array ( picked_inds ) picked_mols = [ mols [ x ] for x in picked_inds ] return picked_inds , picked_mols pick_diverse ( mols , npick , initial_picks = None , feature_fn = None , dist_fn = None , seed = 42 , n_jobs = 1 ) \u00b6 Pick a set of diverse molecules based on they fingerprint. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules. required npick int Number of element to pick from mols, including the preselection. required initial_picks Optional [ List [ int ]] Starting list of index for molecules that should be in the set of picked molecules. Default to None. None feature_fn Optional [ Callable ] A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None dist_fn Optional [ Callable ] A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. None seed int seed for reproducibility 42 n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Returns: Name Type Description picked_inds int index of the molecule that have been picked mols list molecules that have been picked Source code in datamol/cluster.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def pick_diverse ( mols : List [ Mol ], npick : int , initial_picks : Optional [ List [ int ]] = None , feature_fn : Optional [ Callable ] = None , dist_fn : Optional [ Callable ] = None , seed : int = 42 , n_jobs : Optional [ int ] = 1 , ) -> Tuple [ int , list ]: r \"\"\"Pick a set of diverse molecules based on they fingerprint. Args: mols: a list of molecules. npick: Number of element to pick from mols, including the preselection. initial_picks: Starting list of index for molecules that should be in the set of picked molecules. Default to None. feature_fn: A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. dist_fn: A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. seed: seed for reproducibility n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. Returns: picked_inds: index of the molecule that have been picked mols: molecules that have been picked \"\"\" if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) features = dm . parallelized ( feature_fn , mols , n_jobs = n_jobs ) def distij ( i , j , features = features ): return 1.0 - DataStructs . cDataStructs . TanimotoSimilarity ( features [ i ], features [ j ]) if dist_fn is None : dist_fn = distij picker = MaxMinPicker () initial_picks = [] if initial_picks is None else initial_picks picked_inds = picker . LazyPick ( dist_fn , len ( mols ), npick , firstPicks = initial_picks , seed = seed ) picked_inds = np . array ( picked_inds ) picked_mols = [ mols [ x ] for x in picked_inds ] return picked_inds , picked_mols Module fp \u00b6 fp \u00b6 fold_count_fp ( fp , dim = 1024 , binary = False ) \u00b6 Fast folding of a count fingerprint to the specified dimension. Parameters: Name Type Description Default fp Union [ np . ndarray , SparseBitVect , ExplicitBitVect ] A fingerprint. required dim int The dimension of the folded array. 1024 binary bool Whether to fold into a binary array or take use a count vector. False Returns: Name Type Description folded np . ndarray returns folded array to the provided dimension. Source code in datamol/fp.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def fold_count_fp ( fp : Union [ np . ndarray , SparseBitVect , ExplicitBitVect ], dim : int = 1024 , binary : bool = False , ) -> np . ndarray : \"\"\"Fast folding of a count fingerprint to the specified dimension. Args: fp: A fingerprint. dim: The dimension of the folded array. binary: Whether to fold into a binary array or take use a count vector. Returns: folded: returns folded array to the provided dimension. \"\"\" if isinstance ( fp , ( UIntSparseIntVect , IntSparseIntVect , LongSparseIntVect , ULongSparseIntVect , ), ): tmp = fp . GetNonzeroElements () elif isinstance ( fp , SparseBitVect ): on_bits = fp . GetOnBits () tmp = dict ( zip ( on_bits , np . ones ( len ( on_bits )))) else : raise ValueError ( f \"The fingerprint is of wrong type: { type ( fp ) } \" ) # ON bits dict to (i, v) i = np . array ( list ( tmp . keys ())) % dim v = np . array ( list ( tmp . values ())) # Fold indices i = i % dim # Create the folded fp folded = np . zeros ( dim , dtype = \"int\" ) np . add . at ( folded , i , v ) if binary : folded = np . clip ( folded , a_min = 0 , a_max = 1 ) return folded fp_to_array ( fp ) \u00b6 Convert rdkit fingerprint to numpy array. Note This implementation has shown to be faster than using DataStructs.ConvertToNumpyArray by a factor of ~4. See https://github.com/rdkit/rdkit/discussions/3863 . Parameters: Name Type Description Default fp Union [ np . ndarray , SparseBitVect , ExplicitBitVect , UIntSparseIntVect ] The fingerprint. required Source code in datamol/fp.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def fp_to_array ( fp : Union [ np . ndarray , SparseBitVect , ExplicitBitVect , UIntSparseIntVect ] ) -> np . ndarray : \"\"\"Convert rdkit fingerprint to numpy array. Note: This implementation has shown to be faster than using `DataStructs.ConvertToNumpyArray` by a factor of ~4. See https://github.com/rdkit/rdkit/discussions/3863. Args: fp: The fingerprint. \"\"\" if isinstance ( fp , np . ndarray ): fp_out = fp elif isinstance ( fp , SparseBitVect ): tmp = np . zeros ( fp . GetNumBits (), dtype = int ) on_bits = np . array ( fp . GetOnBits ()) tmp [ on_bits ] = 1 fp_out = tmp elif isinstance ( fp , ExplicitBitVect ): fp_out = np . frombuffer ( fp . ToBitString () . encode (), \"u1\" ) - ord ( \"0\" ) elif isinstance ( fp , ( UIntSparseIntVect , IntSparseIntVect , LongSparseIntVect , ULongSparseIntVect , ), ): tmp = np . zeros ( fp . GetLength (), dtype = int ) bit_idx , values = np . array ( list ( fp . GetNonzeroElements () . items ())) . T tmp [ bit_idx ] = values fp_out = tmp else : raise ValueError ( f \"The fingerprint of type ' { type ( fp ) } ' is not supported. \" \"Please open a ticket at https://github.com/datamol-org/datamol/issues.\" ) return fp_out list_supported_fingerprints () \u00b6 Return the supported fingerprints in datamol. Source code in datamol/fp.py 294 295 296 297 def list_supported_fingerprints (): \"\"\"Return the supported fingerprints in datamol.\"\"\" return _FP_FUNCS to_fp ( mol , as_array = True , fp_type = 'ecfp' , fold_size = None , ** fp_args ) \u00b6 Compute the molecular fingerprint given a molecule or a SMILES. Parameters: Name Type Description Default mol Union [ str , Chem . rdchem . Mol ] a molecule or a SMILES. required as_array bool Whether to return a numpy array of an RDKit vec. Default to True. True fp_type str The type of the fingerprint. See dm.list_supported_fingerprints() for a complete list. 'ecfp' fold_size Optional [ int ] If set, fold the fingerprint to the fold_size . If set, returned array is always a numpy array. None **fp_args Any Arguments to build the fingerprint. Refer to the official RDKit documentation. {} Returns: Type Description Optional [ Union [ np . ndarray , SparseBitVect , ExplicitBitVect ]] A fingerprint vector or None Source code in datamol/fp.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def to_fp ( mol : Union [ str , Chem . rdchem . Mol ], as_array : bool = True , fp_type : str = \"ecfp\" , fold_size : Optional [ int ] = None , ** fp_args : Any , ) -> Optional [ Union [ np . ndarray , SparseBitVect , ExplicitBitVect ]]: \"\"\"Compute the molecular fingerprint given a molecule or a SMILES. Args: mol: a molecule or a SMILES. as_array: Whether to return a numpy array of an RDKit vec. Default to True. fp_type: The type of the fingerprint. See `dm.list_supported_fingerprints()` for a complete list. fold_size: If set, fold the fingerprint to the `fold_size`. If set, returned array is always a numpy array. **fp_args: Arguments to build the fingerprint. Refer to the official RDKit documentation. Returns: A fingerprint vector or None \"\"\" # Get fp function fp_func = _FP_FUNCS . get ( fp_type ) if fp_func is None : raise ValueError ( f \"The fingerprint ' { fp_type } ' is not available. Use `dm.list_supported_fingerprints()` to \" \"get a complete list of the available fingerprints.\" ) # Convert input to mol if needed if isinstance ( mol , str ): mol_obj = dm . to_mol ( mol ) else : mol_obj = mol if mol_obj is None : raise ValueError ( f \"It seems like the input molecule ' { mol } ' is invalid.\" ) mol = mol_obj # Insert default values. for key , value in _FP_DEFAULT_ARGS [ fp_type ] . items (): fp_args . setdefault ( key , value ) # Compute the fingerprint fp = fp_func ( mol , ** fp_args ) # Fold the fp if needed. if fold_size is not None : fp = fold_count_fp ( fp , dim = fold_size ) # Convert to a numpy array if not fold_size and as_array : fp = fp_to_array ( fp ) return fp Module similarity \u00b6 similarity \u00b6 cdist ( mols1 , mols2 , n_jobs = 1 , distances_chunk = False , distances_chunk_memory = 1024 , distances_n_jobs =- 1 , ** fp_args ) \u00b6 Compute the tanimoto distance between the fingerprints of each pair of molecules of the two collections of inputs. Parameters: Name Type Description Default mols1 List [ Union [ str , dm . Mol ]] list of molecules. required mols2 List [ Union [ str , dm . Mol ]] list of molecules. required n_jobs Optional [ int ] Number of jobs for fingerprint computation. Let to 1 for no parallelization. Set to None or -1 to use all available cores. 1 distances_chunk bool Whether to use chunked computation. False distances_chunk_memory int Memory size in MB to use for chunked computation. 1024 distances_n_jobs int Number of jobs for parallelization. -1 **fp_args Any list of args to pass to to_fp() . {} Returns: Type Description np . ndarray distmat Source code in datamol/similarity.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def cdist ( mols1 : List [ Union [ str , dm . Mol ]], mols2 : List [ Union [ str , dm . Mol ]], n_jobs : Optional [ int ] = 1 , distances_chunk : bool = False , distances_chunk_memory : int = 1024 , distances_n_jobs : int = - 1 , ** fp_args : Any , ) -> np . ndarray : \"\"\"Compute the tanimoto distance between the fingerprints of each pair of molecules of the two collections of inputs. Args: mols1: list of molecules. mols2: list of molecules. n_jobs: Number of jobs for fingerprint computation. Let to 1 for no parallelization. Set to None or -1 to use all available cores. distances_chunk: Whether to use chunked computation. distances_chunk_memory: Memory size in MB to use for chunked computation. distances_n_jobs: Number of jobs for parallelization. **fp_args: list of args to pass to `to_fp()`. Returns: distmat \"\"\" fps1 = dm . parallelized ( functools . partial ( dm . to_fp , as_array = True , ** fp_args ), mols1 , n_jobs = n_jobs , ) fps2 = dm . parallelized ( functools . partial ( dm . to_fp , as_array = True , ** fp_args ), mols2 , n_jobs = n_jobs , ) fps1 = np . array ( fps1 ) . astype ( bool ) fps2 = np . array ( fps2 ) . astype ( bool ) if distances_chunk : distances = pairwise_distances_chunked ( fps1 , fps2 , metric = \"jaccard\" , n_jobs = distances_n_jobs , working_memory = distances_chunk_memory , ) distances = [ i for i in distances ] distances = np . vstack ( distances ) else : distances = distance . cdist ( fps1 , fps2 , metric = \"jaccard\" ) return distances pdist ( mols , n_jobs = 1 , squareform = True , ** fp_args ) \u00b6 Compute the pairwise tanimoto distance between the fingerprints of all the molecules in the input set. Parameters: Name Type Description Default mols List [ Union [ str , dm . Mol ]] list of molecules required n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 squareform bool Whether to return in square form (matrix) or in a condensed form (1D vector). True **fp_args Any list of args to pass to to_fp() . {} Returns: Type Description np . ndarray dist_mat Source code in datamol/similarity.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def pdist ( mols : List [ Union [ str , dm . Mol ]], n_jobs : Optional [ int ] = 1 , squareform : bool = True , ** fp_args : Any , ) -> np . ndarray : \"\"\"Compute the pairwise tanimoto distance between the fingerprints of all the molecules in the input set. Args: mols: list of molecules n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. squareform: Whether to return in square form (matrix) or in a condensed form (1D vector). **fp_args: list of args to pass to `to_fp()`. Returns: dist_mat \"\"\" fps = dm . parallelized ( functools . partial ( dm . to_fp , as_array = True , ** fp_args ), mols , n_jobs = n_jobs , ) fps = np . array ( fps ) dist_mat = distance . pdist ( fps , metric = \"jaccard\" ) if squareform : dist_mat = distance . squareform ( dist_mat , force = \"tomatrix\" ) return dist_mat Module isomers \u00b6 isomers \u00b6 Module data \u00b6 data \u00b6 cdk2 ( as_df = True , mol_column = 'mol' ) \u00b6 Return the RDKit CDK2 dataset from RDConfig.RDDocsDir, 'Book/data/cdk2.sdf' . Parameters: Name Type Description Default as_df bool Whether to return a list mol or a pandas DataFrame. True mol_column Optional [ str ] Name of the mol column. Only relevant if as_df is True. 'mol' Source code in datamol/data.py 30 31 32 33 34 35 36 37 38 39 40 def cdk2 ( as_df : bool = True , mol_column : Optional [ str ] = \"mol\" ): \"\"\"Return the RDKit CDK2 dataset from `RDConfig.RDDocsDir, 'Book/data/cdk2.sdf'`. Args: as_df: Whether to return a list mol or a pandas DataFrame. mol_column: Name of the mol column. Only relevant if `as_df` is True. \"\"\" with pkg_resources . resource_stream ( \"datamol\" , \"data/cdk2.sdf\" ) as f : data = read_sdf ( f , as_df = as_df , mol_column = mol_column ) return data freesolv () \u00b6 Return the FreeSolv dataset as a dataframe. The dataset contains 642 molecules and the following columns: ['iupac', 'smiles', 'expt', 'calc'] . Warning This dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. It is not a dataset for benchmarking, analysis or model training. Source code in datamol/data.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def freesolv (): \"\"\"Return the FreeSolv dataset as a dataframe. The dataset contains 642 molecules and the following columns: `['iupac', 'smiles', 'expt', 'calc']`. Warning: This dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. **It is not** a dataset for benchmarking, analysis or model training. \"\"\" with pkg_resources . resource_stream ( \"datamol\" , \"data/freesolv.csv\" ) as f : data = pd . read_csv ( f ) return data solubility ( as_df = True , mol_column = 'mol' ) \u00b6 Return the RDKit solubility dataset from RDConfig.RDDocsDir, 'Book/data/solubility.{train|test}.sdf' . The dataframe or the list of molecules with contain a split column, either train or test . Parameters: Name Type Description Default as_df bool Whether to return a list mol or a pandas DataFrame. True mol_column Optional [ str ] Name of the mol column. Only relevant if as_df is True. 'mol' Source code in datamol/data.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def solubility ( as_df : bool = True , mol_column : Optional [ str ] = \"mol\" ): \"\"\"Return the RDKit solubility dataset from `RDConfig.RDDocsDir, 'Book/data/solubility.{train|test}.sdf'`. The dataframe or the list of molecules with contain a `split` column, either `train` or `test`. Args: as_df: Whether to return a list mol or a pandas DataFrame. mol_column: Name of the mol column. Only relevant if `as_df` is True. \"\"\" with pkg_resources . resource_stream ( \"datamol\" , \"data/solubility.train.sdf\" ) as f : train = read_sdf ( f , as_df = True , mol_column = \"mol\" , smiles_column = None ) with pkg_resources . resource_stream ( \"datamol\" , \"data/solubility.test.sdf\" ) as f : test = read_sdf ( f , as_df = True , mol_column = \"mol\" , smiles_column = None ) train = cast ( pd . DataFrame , train ) test = cast ( pd . DataFrame , test ) train [ \"split\" ] = \"train\" test [ \"split\" ] = \"test\" # NOTE(hadim): LMAO RDkit consistency xD test = test . rename ( columns = { \"SMILES\" : \"smiles\" }) data = pd . concat ([ train , test ], ignore_index = True ) if as_df : if mol_column is None : data = data . drop ( columns = [ \"mol\" ]) render_mol_df ( data ) return data return from_df ( data , mol_column = mol_column ) Module log \u00b6 log \u00b6 without_rdkit_log \u00b6 Context manager to disable RDKit logs. By default all logs are disabled. Example: import datamol as dm with dm . without_rdkit_log (): mol = dm . to_mol ( \"CCCCO\" ) # potential RDKit logs won't show Source code in datamol/log.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class without_rdkit_log : \"\"\"Context manager to disable RDKit logs. By default all logs are disabled. Example: ```python import datamol as dm with dm.without_rdkit_log(): mol = dm.to_mol(\"CCCCO\") # potential RDKit logs won't show ``` \"\"\" def __init__ ( self , mute_errors : bool = True , mute_warning : bool = True , mute_info : bool = True , mute_debug : bool = True , enable : bool = True , ): if enable is False : mute_errors = False mute_warning = False mute_info = False mute_debug = False # Get current log state self . previous_status = self . _get_log_status () # Init the desired log state to apply during in the context self . desired_status = {} self . desired_status [ \"rdApp.error\" ] = not mute_errors self . desired_status [ \"rdApp.warning\" ] = not mute_warning self . desired_status [ \"rdApp.debug\" ] = not mute_debug self . desired_status [ \"rdApp.info\" ] = not mute_info def _get_log_status ( self ): \"\"\"Get the current log status of RDKit logs.\"\"\" log_status = rdBase . LogStatus () log_status = { st . split ( \":\" )[ 0 ]: st . split ( \":\" )[ 1 ] for st in log_status . split ( \" \\n \" )} log_status = { k : True if v == \"enabled\" else False for k , v in log_status . items ()} return log_status def _apply_log_status ( self , log_status ): \"\"\"Apply an RDKit log status.\"\"\" for k , v in log_status . items (): if v is True : rdBase . EnableLog ( k ) else : rdBase . DisableLog ( k ) def __enter__ ( self ): self . _apply_log_status ( self . desired_status ) def __exit__ ( self , * args , ** kwargs ): self . _apply_log_status ( self . previous_status ) disable_rdkit_log () \u00b6 Disable all rdkit logs. Source code in datamol/log.py 65 66 67 68 def disable_rdkit_log (): \"\"\"Disable all rdkit logs.\"\"\" for log_level in RDLogger . _levels : rdBase . DisableLog ( log_level ) enable_rdkit_log () \u00b6 Enable all rdkit logs. Source code in datamol/log.py 71 72 73 74 def enable_rdkit_log (): \"\"\"Enable all rdkit logs.\"\"\" for log_level in RDLogger . _levels : rdBase . EnableLog ( log_level ) Module graph \u00b6 graph \u00b6 get_all_path_between ( mol , atom_idx_1 , atom_idx_2 , ignore_cycle_basis = False ) \u00b6 Get all simple path between two atoms of a molecule Parameters: Name Type Description Default mol dm . Mol a molecule required atom_idx_1 int Atom index 1. required atom_idx_2 int Atom index 2. required ignore_cycle_basis bool Whether to ignore cycle basis. Defaults to False. False Returns: Type Description list list of path between two atoms. Source code in datamol/graph.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_all_path_between ( mol : dm . Mol , atom_idx_1 : int , atom_idx_2 : int , ignore_cycle_basis : bool = False , ) -> list : \"\"\"Get all simple path between two atoms of a molecule Args: mol (dm.Mol): a molecule atom_idx_1 (int): Atom index 1. atom_idx_2 (int): Atom index 2. ignore_cycle_basis: Whether to ignore cycle basis. Defaults to False. Returns: list of path between two atoms. \"\"\" nx = _get_networkx () adj = GetAdjacencyMatrix ( mol ) G = nx . Graph ( adj ) path = nx . all_simple_paths ( G , source = atom_idx_1 , target = atom_idx_2 ) if ignore_cycle_basis : rings = [ set ( x ) for x in mol . GetRingInfo () . AtomRings ()] final_path = [] for p in path : reject_path = False for r in rings : if r . issubset ( set ( p )): reject_path = True break if not reject_path : final_path . append ( p ) path = final_path return list ( path ) match_molecular_graphs ( mol1 , mol2 , match_atoms_on = [ 'atomic_num' ], match_bonds_on = [ 'bond_type' ]) \u00b6 Match the node indices of 2 molecular graphs, with optional usage of atomic number and edge type. Note The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. Note Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Parameters: Name Type Description Default mol1 dm . Mol A molecule. required mol2 dm . Mol A molecule. required match_atoms_on List [ str ] Properties on which to match the atom types. By default, it matches on the 'atomic_num' property. Empty list means that it does not consider atom features during matching. Other properties are defined by the datamol.graph.to_graph function and include: - atomic_num - formal_charge - chiral_tag - hybridization - num_explicit_hs - implicit_valence - degree - symbol - ring_atom - is_aromatic ['atomic_num'] match_bonds_on List [ str ] Properties on which to match the bond types. Empty list means that it does not consider bond features during matching. By default, it matches on the 'bond_type' property. No other properties are defined by the datamol.graph.to_graph function. ['bond_type'] Returns: Type Description List [ Dict [ int , int ]] A list of all matches dictionaries. In case of a single match, the list has len==1. List [ Dict [ int , int ]] Each dictionary contains as key the indices of mol1 and as value the corresponding List [ Dict [ int , int ]] indices of mol2 . Source code in datamol/graph.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def match_molecular_graphs ( mol1 : dm . Mol , mol2 : dm . Mol , match_atoms_on : List [ str ] = [ \"atomic_num\" ], match_bonds_on : List [ str ] = [ \"bond_type\" ], ) -> List [ Dict [ int , int ]]: \"\"\" Match the node indices of 2 molecular graphs, with optional usage of atomic number and edge type. Note: The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. Note: Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Args: mol1: A molecule. mol2: A molecule. match_atoms_on: Properties on which to match the atom types. By default, it matches on the `'atomic_num'` property. Empty list means that it does not consider atom features during matching. Other properties are defined by the `datamol.graph.to_graph` function and include: - atomic_num - formal_charge - chiral_tag - hybridization - num_explicit_hs - implicit_valence - degree - symbol - ring_atom - is_aromatic match_bonds_on: Properties on which to match the bond types. Empty list means that it does not consider bond features during matching. By default, it matches on the `'bond_type'` property. No other properties are defined by the `datamol.graph.to_graph` function. Returns: A list of all matches dictionaries. In case of a single match, the list has len==1. Each dictionary contains as key the indices of `mol1` and as value the corresponding indices of `mol2`. \"\"\" nx = _get_networkx () if isinstance ( match_atoms_on , str ): match_atoms_on = [ match_atoms_on ] if isinstance ( match_bonds_on , str ): match_bonds_on = [ match_bonds_on ] def node_match_fn ( node1 , node2 ): \"\"\"Function that matches the atomic number\"\"\" return all ([ node1 [ prop ] == node2 [ prop ] for prop in match_atoms_on ]) def edge_match_fn ( edge1 , edge2 ): \"\"\"Function that matches the bond type\"\"\" return all ([ edge1 [ prop ] == edge2 [ prop ] for prop in match_bonds_on ]) # Convert to networkx graph g1 = to_graph ( mol1 ) g2 = to_graph ( mol2 ) # Use the `match` function to find the matching indices node_match = node_match_fn if len ( match_atoms_on ) > 0 else None edge_match = edge_match_fn if len ( match_bonds_on ) > 0 else None graph_matcher = nx . algorithms . isomorphism . vf2userfunc . GraphMatcher ( g1 , g2 , node_match = node_match , edge_match = edge_match ) matches = list ( graph_matcher . match ()) return matches reorder_mol_from_template ( mol , mol_template , enforce_atomic_num = False , enforce_bond_type = False , ambiguous_match_mode = 'No' , verbose = True ) \u00b6 Re-order the nodes of a molecular graph from the nodes of a template molecule. Molecular graphs and atom types need to be identical, but edge types and charges are not enforced. This is particularily useful when dealing with XYZ files containing node ordering, but with missing information regarding charges and edge types. Note If you only need to match bond orders, you can check the function rdkit.Chem.AllChem.AssignBondOrdersFromTemplate . The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Parameters: Name Type Description Default mol dm . Mol The molecule to re-order required mol_template dm . Mol The molecule containing the right node order. required enforce_atomic_num bool Whether to enforce atomic number. Atomic numbers are always enforced for a first try. If no match are found and this parameter is False , the matching is tried again. False enforce_bond_type bool Whether to enforce bond types. Bond types are always enforced for a first try. If no match are found and this parameter is False , the matching is tried again. False ambiguous_match_mode str Whether to allow ambiguous matching. This means that, if there are many matches to the molecule, it will still re-order the molecule according to specific rules. Options are: - \"no\": Does not allow ambiguous matching. - \"hs-only\": Allow matching of ambiguous hydrogens. Does not work if trying to match implicit with explicit hydrogens. - \"first\": Return the first match. - \"best\": Return the match with the least errors on atom type, edges type, and edge stereo. Errors on the atoms are counted with 1 point, on the charge with 0.25 points, on the edges with 0.25 points, and on the Stereo with 0.05 points. If the option enforce_atomic_num is used, then no errors on the atoms are allowed. If the option enforce_bond_type is used, then no errors on the edges are allowed. - \"best-first\": \"best\", followed by \"first\". 'No' verbose bool Whether to warn when the matching does not work or is ambiguous. Different warnings are raised depending on the value of ambiguous_match_mode . True Returns: Type Description Optional [ dm . Mol ] None if the molecular graphs do not match (both the graph and atom types). Pring a warning. Optional [ dm . Mol ] None if multiple matche are found, which can happen for symmetric molecules such as benzene Pring a warning. Optional [ dm . Mol ] Mol The re-ordered molecule when a single match is found. Source code in datamol/graph.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def reorder_mol_from_template ( mol : dm . Mol , mol_template : dm . Mol , enforce_atomic_num : bool = False , enforce_bond_type : bool = False , ambiguous_match_mode : str = \"No\" , verbose : bool = True , ) -> Optional [ dm . Mol ]: \"\"\" Re-order the nodes of a molecular graph from the nodes of a template molecule. Molecular graphs and atom types need to be identical, but edge types and charges are not enforced. This is particularily useful when dealing with XYZ files containing node ordering, but with missing information regarding charges and edge types. !!! note * If you only need to match bond orders, you can check the function `rdkit.Chem.AllChem.AssignBondOrdersFromTemplate`. * The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. * Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Args: mol: The molecule to re-order mol_template: The molecule containing the right node order. enforce_atomic_num: Whether to enforce atomic number. Atomic numbers are always enforced for a first try. If no match are found and this parameter is `False`, the matching is tried again. enforce_bond_type: Whether to enforce bond types. Bond types are always enforced for a first try. If no match are found and this parameter is `False`, the matching is tried again. ambiguous_match_mode: Whether to allow ambiguous matching. This means that, if there are many matches to the molecule, it will still re-order the molecule according to specific rules. Options are: - \"no\": Does not allow ambiguous matching. - \"hs-only\": Allow matching of ambiguous hydrogens. Does not work if trying to match implicit with explicit hydrogens. - \"first\": Return the first match. - \"best\": Return the match with the least errors on atom type, edges type, and edge stereo. Errors on the atoms are counted with 1 point, on the charge with 0.25 points, on the edges with 0.25 points, and on the Stereo with 0.05 points. If the option `enforce_atomic_num` is used, then no errors on the atoms are allowed. If the option `enforce_bond_type` is used, then no errors on the edges are allowed. - \"best-first\": \"best\", followed by \"first\". verbose: Whether to warn when the matching does not work or is ambiguous. Different warnings are raised depending on the value of `ambiguous_match_mode`. Returns: - `None` if the molecular graphs do not match (both the graph and atom types). Pring a warning. - `None` if multiple matche are found, which can happen for symmetric molecules such as benzene Pring a warning. - `Mol` The re-ordered molecule when a single match is found. \"\"\" ambiguous_match_mode = ambiguous_match_mode . lower () # Match the ordering of the graphs matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [ \"atomic_num\" ], match_bonds_on = [ \"bond_type\" ], ) # If no matches were found, retry without bond types if ( len ( matches ) == 0 ) and ( not enforce_bond_type ): matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [ \"atomic_num\" ], match_bonds_on = [], ) # If no matches were found, retry without atom types if ( len ( matches ) == 0 ) and ( not enforce_atomic_num ): matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [], match_bonds_on = [ \"bond_type\" ], ) # If no matches were found, retry without bond and atom types if ( len ( matches ) == 0 ) and ( not enforce_bond_type ) and ( not enforce_atomic_num ): matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [], match_bonds_on = []) # If no match were found, exit the function and return None if len ( matches ) == 0 : if verbose : logger . warning ( \"No match was found\" ) return None if len ( matches ) > 1 : # In case we want to allow ambiguous match of hydrogens if ambiguous_match_mode == \"hs-only\" : first_keys = list ( matches [ 0 ] . keys ()) all_hs_mismatch = True for this_match in matches : this_keys = list ( this_match . keys ()) keys_mismatch = [ ii for ii in range ( len ( this_keys )) if ( first_keys [ ii ] != this_keys [ ii ]) ] atoms_mismatch = [ mol . GetAtomWithIdx ( key ) . GetAtomicNum () for key in keys_mismatch ] all_hs = all ([ atom == 1 for atom in atoms_mismatch ]) if not all_hs : all_hs_mismatch = False break if all_hs_mismatch : matches = matches [ 0 : 1 ] else : if verbose : logger . warning ( f \" { len ( matches ) } matches were found, ordering is ambiguous, even when ignoring hydrogens\" ) return None # Compute the number of atoms and bonds mismatch, and select the one with the least mismatch if ( ambiguous_match_mode in [ \"best\" , \"best-first\" ]) and not ( enforce_atomic_num and enforce_bond_type ): num_mismatches = [] for this_match in matches : num_atoms_mismatch , num_charge_mismatch = 0 , 0 # Get the number of atomic mismatch for key , val in this_match . items (): atom1 = mol . GetAtomWithIdx ( val ) atom2 = mol_template . GetAtomWithIdx ( key ) num_atoms_mismatch += atom1 . GetAtomicNum () != atom2 . GetAtomicNum () num_charge_mismatch += atom1 . GetFormalCharge () != atom2 . GetFormalCharge () # Get the number of bond mismatch num_bonds_type_mismatch , num_bonds_stereo_mismatch = 0 , 0 for bond1 in mol_template . GetBonds (): begin_idx , end_idx = bond1 . GetBeginAtomIdx (), bond1 . GetEndAtomIdx () bond2 = mol . GetBondBetweenAtoms ( this_match [ begin_idx ], this_match [ end_idx ]) num_bonds_type_mismatch += bond1 . GetBondType () != bond2 . GetBondType () num_bonds_stereo_mismatch += ( bond1 . GetStereo () != bond2 . GetStereo ()) or ( bond1 . GetBondDir () != bond2 . GetBondDir () ) num_mismatches . append ( ( 1 * num_atoms_mismatch ) + ( 0.25 * num_charge_mismatch ) + ( 0.25 * num_bonds_type_mismatch ) + ( 0.05 * num_bonds_stereo_mismatch ) ) min_mismatch_idx = [ ii for ii in range ( len ( num_mismatches )) if num_mismatches [ ii ] == min ( num_mismatches ) ] matches = [ matches [ idx ] for idx in min_mismatch_idx ] # Select the first matching element if ambiguous_match_mode in [ \"first\" , \"best-first\" ]: matches = [ matches [ 0 ]] if len ( matches ) > 1 : # If many matches were found, exit the function and return None if ambiguous_match_mode == \"no\" : if verbose : logger . warning ( f \" { len ( matches ) } matches were found, ordering is ambiguous\" ) return None # Re-order the molecule from the matching indices of the template match = matches [ 0 ] match = [ match [ ii ] for ii in range ( mol . GetNumAtoms ())] reordered_mol = RenumberAtoms ( mol , match ) return reordered_mol to_graph ( mol ) \u00b6 Convert a molecule to a network x graph. A list of properties are added to every nodes and edges. Parameters: Name Type Description Default mol dm . Mol a molecule. required Returns: Name Type Description mol_graph networkx . Graph a graph representing the molecule. Source code in datamol/graph.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def to_graph ( mol : dm . Mol ): \"\"\"Convert a molecule to a network x graph. A list of properties are added to every nodes and edges. Args: mol (dm.Mol): a molecule. Returns: mol_graph (networkx.Graph): a graph representing the molecule. \"\"\" nx = _get_networkx () mol_graph = nx . Graph () for atom in mol . GetAtoms (): mol_graph . add_node ( atom . GetIdx (), atomic_num = atom . GetAtomicNum (), formal_charge = atom . GetFormalCharge (), chiral_tag = atom . GetChiralTag (), hybridization = atom . GetHybridization (), num_explicit_hs = atom . GetNumExplicitHs (), implicit_valence = atom . GetImplicitValence (), degree = atom . GetDegree (), symbol = atom . GetSymbol (), ring_atom = atom . IsInRing (), is_aromatic = atom . GetIsAromatic (), ) for bond in mol . GetBonds (): mol_graph . add_edge ( bond . GetBeginAtomIdx (), bond . GetEndAtomIdx (), bond_type = bond . GetBondType (), ) return mol_graph","title":"datamol"},{"location":"api/datamol.html#datamol","text":"","title":"datamol"},{"location":"api/datamol.html#module-mol","text":"","title":"Module mol"},{"location":"api/datamol.html#datamol.mol","text":"","title":"mol"},{"location":"api/datamol.html#datamol.mol.add_hs","text":"Adds hydrogens to the molecule. Parameters: Name Type Description Default mol Mol a molecule. required explicit_only bool whether to only add explicit hydrogens. False add_coords bool whether to add 3D coordinates to the hydrogens. False only_on_atoms Optional [ List [ int ]] a list of atoms to add hydrogens only on. None add_residue_info bool whether to add residue information to the hydrogens. Useful for PDB files. False Source code in datamol/mol.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 def add_hs ( mol : Mol , explicit_only : bool = False , add_coords : bool = False , only_on_atoms : Optional [ List [ int ]] = None , add_residue_info : bool = False , ): \"\"\"Adds hydrogens to the molecule. Args: mol: a molecule. explicit_only: whether to only add explicit hydrogens. add_coords: whether to add 3D coordinates to the hydrogens. only_on_atoms: a list of atoms to add hydrogens only on. add_residue_info: whether to add residue information to the hydrogens. Useful for PDB files. \"\"\" mol = AddHs ( mol , explicitOnly = explicit_only , addCoords = add_coords , onlyOnAtoms = only_on_atoms , addResidueInfo = add_residue_info , ) return mol","title":"add_hs()"},{"location":"api/datamol.html#datamol.mol.adjust_singleton","text":"Remove all atoms that are essentially disconnected singleton nodes in the molecular graph. For example, the chlorine atom and methane fragment will be removed in Cl.[N:1]1=CC(O)=CC2CCCCC12.CC.C\", but not the ethane fragment. Parameters: Name Type Description Default mol Mol a molecule. required Source code in datamol/mol.py 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def adjust_singleton ( mol : Mol ) -> Optional [ Mol ]: \"\"\"Remove all atoms that are essentially disconnected singleton nodes in the molecular graph. For example, the chlorine atom and methane fragment will be removed in Cl.[N:1]1=CC(O)=CC2CCCCC12.CC.C\", but not the ethane fragment. Args: mol: a molecule. \"\"\" to_rem = [] em = RWMol ( mol ) for atom in mol . GetAtoms (): if atom . GetExplicitValence () == 0 : to_rem . append ( atom . GetIdx ()) to_rem . sort ( reverse = True ) for a_idx in to_rem : em . RemoveAtom ( a_idx ) return em . GetMol ()","title":"adjust_singleton()"},{"location":"api/datamol.html#datamol.mol.atom_indices_to_mol","text":"Add the molAtomMapNumber property to each atoms. Parameters: Name Type Description Default mol Mol a molecule required copy bool Whether to copy the molecule. False Source code in datamol/mol.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def atom_indices_to_mol ( mol : Mol , copy : bool = False ): \"\"\"Add the `molAtomMapNumber` property to each atoms. Args: mol: a molecule copy: Whether to copy the molecule. \"\"\" if copy is True : mol = copy_mol ( mol ) for atom in mol . GetAtoms (): atom . SetProp ( \"molAtomMapNumber\" , str ( atom . GetIdx ())) return mol","title":"atom_indices_to_mol()"},{"location":"api/datamol.html#datamol.mol.atom_list_to_bond","text":"Return a list of existing bond indices between a list of atom indices. Parameters: Name Type Description Default mol Mol A molecule. required atom_indices List [ int ] A list of atom indices. required Source code in datamol/mol.py 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 def atom_list_to_bond ( mol : Mol , atom_indices : List [ int ], bond_as_idx : bool = False , ): \"\"\"Return a list of existing bond indices between a list of atom indices. Args: mol: A molecule. atom_indices: A list of atom indices. \"\"\" # Build an atom map atom_map = {} submol = PathToSubmol ( mol , atom_indices , useQuery = True , atomMap = atom_map ) atom_map_reversed = { v : k for k , v in atom_map . items ()} bonds = [] for bond in submol . GetBonds (): a1 , a2 = bond . GetBeginAtomIdx (), bond . GetEndAtomIdx () ori_a1 = atom_map_reversed [ a1 ] ori_a2 = atom_map_reversed [ a2 ] if ori_a1 in atom_indices and ori_a2 in atom_indices : ori_bond = mol . GetBondBetweenAtoms ( ori_a1 , ori_a2 ) if bond_as_idx : bonds . append ( ori_bond . GetIdx ()) else : bonds . append ( ori_bond ) return bonds","title":"atom_list_to_bond()"},{"location":"api/datamol.html#datamol.mol.clear_mol_props","text":"Clear all properties from a molecule. Parameters: Name Type Description Default mol Mol A molecule. required copy bool Whether to copy the molecule. True Source code in datamol/mol.py 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 def clear_mol_props ( mol : Mol , copy : bool = True , include_private : bool = False , include_computed : bool = False , ): \"\"\"Clear all properties from a molecule. Args: mol: A molecule. copy: Whether to copy the molecule. \"\"\" if copy : mol = copy_mol ( mol ) props = mol . GetPropsAsDict ( includePrivate = include_private , includeComputed = include_computed ) for key in props . keys (): mol . ClearProp ( key ) return mol","title":"clear_mol_props()"},{"location":"api/datamol.html#datamol.mol.compute_ring_system","text":"Compute the list of ring system in a molecule. This is based on RDKit's cookbook: https://www.rdkit.org/docs/Cookbook.html#rings-aromaticity-and-kekulization Parameters: Name Type Description Default mol Mol input molecule required include_spiro bool whether to include spiro rings. True Returns: Name Type Description ring_system List [ Set [ int ]] list of ring system (atom indices). Source code in datamol/mol.py 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 def compute_ring_system ( mol : Mol , include_spiro : bool = True ) -> List [ Set [ int ]]: \"\"\"Compute the list of ring system in a molecule. This is based on RDKit's cookbook: https://www.rdkit.org/docs/Cookbook.html#rings-aromaticity-and-kekulization Args: mol: input molecule include_spiro: whether to include spiro rings. Returns: ring_system: list of ring system (atom indices). \"\"\" ri = mol . GetRingInfo () systems = [] for ring in ri . AtomRings (): ringAts = set ( ring ) nSystems = [] for system in systems : nInCommon = len ( ringAts . intersection ( system )) if nInCommon and ( include_spiro or nInCommon > 1 ): ringAts = ringAts . union ( system ) else : nSystems . append ( system ) nSystems . append ( ringAts ) systems = nSystems return systems","title":"compute_ring_system()"},{"location":"api/datamol.html#datamol.mol.copy_mol","text":"Copy a molecule and return a new one. Parameters: Name Type Description Default mol Mol a molecule to copy. required Source code in datamol/mol.py 57 58 59 60 61 62 63 def copy_mol ( mol : Mol ) -> Mol : \"\"\"Copy a molecule and return a new one. Args: mol: a molecule to copy. \"\"\" return copy . deepcopy ( mol )","title":"copy_mol()"},{"location":"api/datamol.html#datamol.mol.copy_mol_props","text":"Copy properties from one source molecule to another destination molecule. Parameters: Name Type Description Default source Mol a molecule to copy from. required destination Mol a molecule to copy to. required include_private bool Include private properties. False include_computed bool Include computed properties. False Source code in datamol/mol.py 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 def copy_mol_props ( source : Mol , destination : Mol , include_private : bool = False , include_computed : bool = False , ): \"\"\"Copy properties from one source molecule to another destination molecule. Args: source: a molecule to copy from. destination: a molecule to copy to. include_private: Include private properties. include_computed: Include computed properties. \"\"\" props = source . GetPropsAsDict ( includePrivate = include_private , includeComputed = include_computed ) set_mol_props ( destination , props )","title":"copy_mol_props()"},{"location":"api/datamol.html#datamol.mol.decrease_bond","text":"Remove one single bond from the input bond. Note that you should first kekulize your molecules and remove non-standard bond. Parameters: Name Type Description Default bond Chem . rdchem . Bond a bond. required Source code in datamol/mol.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def decrease_bond ( bond : Chem . rdchem . Bond ) -> Optional [ Union [ list , Chem . rdchem . Bond ]]: \"\"\"Remove one single bond from the input bond. Note that you should first kekulize your molecules and remove non-standard bond. Args: bond: a bond. \"\"\" if bond . GetBondType () == TRIPLE_BOND : return DOUBLE_BOND if bond . GetBondType () == DOUBLE_BOND : return SINGLE_BOND if bond . GetBondType () == SINGLE_BOND : return None return bond","title":"decrease_bond()"},{"location":"api/datamol.html#datamol.mol.fix_mol","text":"Fix error in molecule using a greedy approach. Parameters: Name Type Description Default mol Mol input molecule to fix required n_iter int Number of valence fix iteration to apply 1 remove_singleton bool Whether adjust_singleton should be applied False largest_only bool Whether only the largest fragment should be kept False inplace bool Whether to return a copy of the mol or perform in place operation False Returns: Type Description Optional [ Mol ] Fixed molecule. Source code in datamol/mol.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 def fix_mol ( mol : Mol , n_iter : int = 1 , remove_singleton : bool = False , largest_only : bool = False , inplace : bool = False , ) -> Optional [ Mol ]: \"\"\"Fix error in molecule using a greedy approach. Args: mol: input molecule to fix n_iter: Number of valence fix iteration to apply remove_singleton: Whether `adjust_singleton` should be applied largest_only: Whether only the largest fragment should be kept inplace: Whether to return a copy of the mol or perform in place operation Returns: Fixed molecule. \"\"\" if not inplace : mol = copy . copy ( mol ) m = sanitize_mol ( mol ) or mol # fail back to mol when the fixer fail if m is not None : m = remove_dummies ( m ) for _ in range ( n_iter ): m = fix_valence ( m ) if remove_singleton : m = adjust_singleton ( m ) if largest_only : # m = max(Chem.rdmolops.GetMolFrags(m, asMols=True, sanitizeFrags=False), key=lambda m: m.GetNumAtoms()) m = rdMolStandardize . FragmentParent ( m , skipStandardize = True ) return m","title":"fix_mol()"},{"location":"api/datamol.html#datamol.mol.fix_valence","text":"Identify and try to fix valence issues by removing any supplemental bond that should not be in the graph. Parameters: Name Type Description Default mol Mol input molecule with incorrect valence for some atoms required inplace bool Whether to modify in place or make a copy False allow_ring_break bool Whether bond removal involving ring is allowed. False Returns: Type Description Optional [ Mol ] Fixed potential valence issue in molecule or original molecule when nothing is broken Optional [ Mol ] of if failed. Source code in datamol/mol.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def fix_valence ( mol : Mol , inplace : bool = False , allow_ring_break : bool = False ) -> Optional [ Mol ]: \"\"\"Identify and try to fix valence issues by removing any supplemental bond that should not be in the graph. Args: mol: input molecule with incorrect valence for some atoms inplace: Whether to modify in place or make a copy allow_ring_break: Whether bond removal involving ring is allowed. Returns: Fixed potential valence issue in molecule or original molecule when nothing is broken of if failed. \"\"\" if not inplace : mol = copy . copy ( mol ) vm = rdMolStandardize . RDKitValidation () if len ( vm . validate ( mol )) == 0 : # don't fix something that is not broken return mol try : m = remove_hs ( mol , implicit_only = False , update_explicit_count = True , sanitize = False , ) m . UpdatePropertyCache ( False ) # first pass using explicit false count for atom in m . GetAtoms (): while incorrect_valence ( atom ) and atom . GetTotalNumHs () > 0 : cur_hydrogen = atom . GetTotalNumHs () atom . SetNumExplicitHs ( max ( 0 , cur_hydrogen - 1 )) atom . SetFormalCharge ( max ( 0 , atom . GetFormalCharge () - 1 )) # atom.SetNumRadicalElectrons(0) atom . UpdatePropertyCache ( False ) em = RWMol ( m ) bonds = em . GetBonds () bonds = [ bond for bond in bonds if any ( [ incorrect_valence ( bond . GetBeginAtom ()), incorrect_valence ( bond . GetEndAtom ()), ] ) ] for bond in bonds : a1 = bond . GetBeginAtom () a2 = bond . GetEndAtom () if incorrect_valence ( a1 ) or incorrect_valence ( a2 ): mbond = decrease_bond ( bond ) if allow_ring_break or ( mbond or not bond . IsInRing ()): em . RemoveBond ( a1 . GetIdx (), a2 . GetIdx ()) if mbond is not None : em . AddBond ( a1 . GetIdx (), a2 . GetIdx (), mbond ) a1 . UpdatePropertyCache ( False ) a2 . UpdatePropertyCache ( False ) m = em . GetMol () except Exception : return None return m","title":"fix_valence()"},{"location":"api/datamol.html#datamol.mol.fix_valence_charge","text":"Fix valence issues that are due to incorrect charges. Parameters: Name Type Description Default mol Mol Input molecule with incorrect valence for some atoms required inplace bool Whether to modify in place or make a copy. False Returns: Type Description Optional [ Mol ] Fixed molecule via charge correction or original molecule if failed. Source code in datamol/mol.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def fix_valence_charge ( mol : Mol , inplace : bool = False ) -> Optional [ Mol ]: \"\"\"Fix valence issues that are due to incorrect charges. Args: mol: Input molecule with incorrect valence for some atoms inplace: Whether to modify in place or make a copy. Returns: Fixed molecule via charge correction or original molecule if failed. \"\"\" vm = rdMolStandardize . RDKitValidation () # Don't fix something that is not broken if len ( vm . validate ( mol )) > 0 : if not inplace : mol = copy . copy ( mol ) mol . UpdatePropertyCache ( False ) for a in mol . GetAtoms (): n_electron = ( a . GetImplicitValence () + a . GetExplicitValence () - PERIODIC_TABLE . GetDefaultValence ( a . GetSymbol ()) ) a . SetFormalCharge ( n_electron ) return mol","title":"fix_valence_charge()"},{"location":"api/datamol.html#datamol.mol.incorrect_valence","text":"Check if an atom connection is not valid or all the atom of a molecule. Parameters: Name Type Description Default a Union [ Mol , Chem . rdchem . Atom ] atom or molecule to check for valence issue. required update bool Update owning molecule property cache first. False Returns: Type Description bool Whether the input atom valence is correct. Source code in datamol/mol.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def incorrect_valence ( a : Union [ Mol , Chem . rdchem . Atom ], update : bool = False ) -> bool : \"\"\"Check if an atom connection is not valid or all the atom of a molecule. Args: a: atom or molecule to check for valence issue. update: Update owning molecule property cache first. Returns: Whether the input atom valence is correct. \"\"\" if isinstance ( a , Mol ): a . UpdatePropertyCache ( False ) vm = rdMolStandardize . RDKitValidation () return len ( vm . validate ( a )) > 0 if update : m = a . GetOwningMol () m . UpdatePropertyCache ( False ) return ( a . GetImplicitValence () == 0 ) and ( a . GetExplicitValence () > max ( PERIODIC_TABLE . GetValenceList ( a . GetSymbol ())) )","title":"incorrect_valence()"},{"location":"api/datamol.html#datamol.mol.is_transition_metal","text":"Check if atom is a transition metal. Parameters: Name Type Description Default at Chem . rdchem . Atom an atom. required Source code in datamol/mol.py 685 686 687 688 689 690 691 692 def is_transition_metal ( at : Chem . rdchem . Atom ) -> bool : \"\"\"Check if atom is a transition metal. Args: at: an atom. \"\"\" n = at . GetAtomicNum () return ( n >= 22 and n <= 29 ) or ( n >= 40 and n <= 47 ) or ( n >= 72 and n <= 79 )","title":"is_transition_metal()"},{"location":"api/datamol.html#datamol.mol.keep_largest_fragment","text":"Only keep largest fragment of each molecule. Source code in datamol/mol.py 676 677 678 679 680 681 682 def keep_largest_fragment ( mol : Mol ) -> Optional [ Mol ]: \"\"\"Only keep largest fragment of each molecule.\"\"\" return max ( GetMolFrags ( mol , asMols = True ), default = mol , key = lambda m : m . GetNumAtoms (), )","title":"keep_largest_fragment()"},{"location":"api/datamol.html#datamol.mol.make_scaffold_generic","text":"Make the atom in a scaffold or molecule generic. Parameters: Name Type Description Default mol Mol A molecule or a scaffold. required include_bonds bool Whether we should also update bond order or keep as is. False Source code in datamol/mol.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 def make_scaffold_generic ( mol : Mol , include_bonds : bool = False ): \"\"\"Make the atom in a scaffold or molecule generic. Args: mol: A molecule or a scaffold. include_bonds: Whether we should also update bond order or keep as is. \"\"\" for atom in mol . GetAtoms (): if atom . GetAtomicNum () != 1 : atom . SetAtomicNum ( 0 ) atom . SetFormalCharge ( 0 ) atom . SetChiralTag ( rdchem . ChiralType . CHI_UNSPECIFIED ) atom . SetNoImplicit ( 0 ) atom . SetNumExplicitHs ( 0 ) if include_bonds : for bond in mol . GetBonds (): bond . SetBondType ( UNSPECIFIED_BOND ) mol . UpdatePropertyCache () Chem . GetSymmSSSR ( mol ) # type: ignore return mol","title":"make_scaffold_generic()"},{"location":"api/datamol.html#datamol.mol.protect_atoms","text":"Protect a list of atoms or substruct in a molecule. The _protected attributes of a molecule is used by RDKit in several functions, especially for reactions where \"protected\" atoms are disallowed from taking part in reactions. Parameters: Name Type Description Default mol Mol input molecule to protect required substruct Optional [ Mol ] optional substructure query to identify atoms to protect None atoms Optional [ Union [ List [ int ], int ]] optional list of atom indices to protect None in_place bool whether to perform the protection in place or return a copy of the molecule False Source code in datamol/mol.py 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 def protect_atoms ( mol : Mol , substruct : Optional [ Mol ] = None , atoms : Optional [ Union [ List [ int ], int ]] = None , in_place : bool = False , ) -> Mol : \"\"\"Protect a list of atoms or substruct in a molecule. The _protected attributes of a molecule is used by RDKit in several functions, especially for reactions where \"protected\" atoms are disallowed from taking part in reactions. Args: mol: input molecule to protect substruct: optional substructure query to identify atoms to protect atoms: optional list of atom indices to protect in_place: whether to perform the protection in place or return a copy of the molecule \"\"\" if atoms is None : atoms = [] elif not isinstance ( atoms , ( tuple , list )): atoms = [ atoms ] # do not perform protection in place if in_place : mol_copy = mol else : mol_copy = copy_mol ( mol ) if substruct is not None : matches = mol_copy . GetSubstructMatches ( substruct ) atoms . extend ( itertools . chain ( * matches )) for a in atoms : if a is None : continue mol_copy . GetAtomWithIdx ( a ) . SetProp ( \"_protected\" , \"1\" ) return mol_copy","title":"protect_atoms()"},{"location":"api/datamol.html#datamol.mol.randomize_atoms","text":"Randomize the position of the atoms in a mol. Parameters: Name Type Description Default mol Mol a molecule. required Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def randomize_atoms ( mol : Mol ) -> Optional [ Mol ]: \"\"\"Randomize the position of the atoms in a mol. Args: mol: a molecule. Returns: mol: a molecule. \"\"\" if mol . GetNumAtoms () == 0 : return mol atom_indices = list ( range ( mol . GetNumAtoms ())) random . shuffle ( atom_indices ) return RenumberAtoms ( mol , atom_indices )","title":"randomize_atoms()"},{"location":"api/datamol.html#datamol.mol.remove_dummies","text":"Remove dummy atoms from molecules. Source code in datamol/mol.py 599 600 601 602 603 604 605 606 607 608 609 610 def remove_dummies ( mol : Mol , dummy : str = \"*\" ) -> Optional [ Mol ]: \"\"\"Remove dummy atoms from molecules.\"\"\" du = to_mol ( dummy ) out = mol try : out = ReplaceSubstructs ( mol , du , to_mol ( \"[H]\" ), True )[ 0 ] out = remove_hs ( out ) except Exception : out = DeleteSubstructs ( mol , du ) return out","title":"remove_dummies()"},{"location":"api/datamol.html#datamol.mol.remove_hs","text":"Removes hydrogens from a molecule. Parameters: Name Type Description Default mol Mol a molecule. required implicit_only bool whether to only remove implicit hydrogens. False update_explicit_count bool whether to update the explicit hydrogen count. False sanitize bool whether to sanitize the molecule after the hydrogens are removed. True Source code in datamol/mol.py 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 def remove_hs ( mol : Mol , implicit_only : bool = False , update_explicit_count : bool = False , sanitize : bool = True , ): \"\"\"Removes hydrogens from a molecule. Args: mol: a molecule. implicit_only: whether to only remove implicit hydrogens. update_explicit_count: whether to update the explicit hydrogen count. sanitize: whether to sanitize the molecule after the hydrogens are removed. \"\"\" mol = RemoveHs ( mol , implicitOnly = implicit_only , updateExplicitCount = update_explicit_count , sanitize = sanitize , ) return mol","title":"remove_hs()"},{"location":"api/datamol.html#datamol.mol.reorder_atoms","text":"Reorder the atoms in a mol. It ensures a single atom order for the same molecule, regardless of its original representation. Parameters: Name Type Description Default mol Mol a molecule. required break_ties bool Force breaking of ranked ties. True include_chirality bool Use chiral information when computing rank. True include_isotopes bool Use isotope information when computing rank. True Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def reorder_atoms ( mol : Mol , break_ties : bool = True , include_chirality : bool = True , include_isotopes : bool = True , ) -> Optional [ Mol ]: \"\"\"Reorder the atoms in a mol. It ensures a single atom order for the same molecule, regardless of its original representation. Args: mol: a molecule. break_ties: Force breaking of ranked ties. include_chirality: Use chiral information when computing rank. include_isotopes: Use isotope information when computing rank. Returns: mol: a molecule. \"\"\" if mol . GetNumAtoms () == 0 : return mol new_order = CanonicalRankAtoms ( mol , breakTies = break_ties , includeChirality = include_chirality , includeIsotopes = include_isotopes , ) new_order = sorted ([( y , x ) for x , y in enumerate ( new_order )]) return RenumberAtoms ( mol , [ y for ( x , y ) in new_order ])","title":"reorder_atoms()"},{"location":"api/datamol.html#datamol.mol.replace_dummies_atoms","text":"Remove dummy atoms from molecules. Parameters: Name Type Description Default mol Mol molecule with dummies required atom str replacement atom, default is carbon 'C' dummy str dummy atom representation '*' replace_all bool Whether to replace all dummies True Returns: Name Type Description mol Optional [ Mol ] Molecule with dummy replaced Source code in datamol/mol.py 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 def replace_dummies_atoms ( mol : Mol , atom : str = \"C\" , dummy : str = \"*\" , replace_all : bool = True , ) -> Optional [ Mol ]: \"\"\"Remove dummy atoms from molecules. Args: mol: molecule with dummies atom: replacement atom, default is carbon dummy: dummy atom representation replace_all: Whether to replace all dummies Returns: mol: Molecule with dummy replaced \"\"\" du = to_mol ( dummy ) replacement = to_mol ( atom ) out = ReplaceSubstructs ( mol , du , replacement , replaceAll = replace_all )[ 0 ] return out","title":"replace_dummies_atoms()"},{"location":"api/datamol.html#datamol.mol.same_mol","text":"Check two molecules are the same by comparing their InChiKey. Invalid molecules (None) are always considered as not the same. Parameters: Name Type Description Default mol1 Optional [ Mol ] A molecule. required mol2 Optional [ Mol ] A molecule. required use_non_standard_inchikey bool Whether to use the standard or non-standard InChiKey. False Source code in datamol/mol.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def same_mol ( mol1 : Optional [ Mol ], mol2 : Optional [ Mol ], use_non_standard_inchikey : bool = False , ) -> bool : \"\"\"Check two molecules are the same by comparing their InChiKey. Invalid molecules (None) are always considered as not the same. Args: mol1: A molecule. mol2: A molecule. use_non_standard_inchikey: Whether to use the standard or non-standard InChiKey. \"\"\" if mol1 is None or mol2 is None : return False if use_non_standard_inchikey : return to_inchikey_non_standard ( mol1 ) == to_inchikey_non_standard ( mol2 ) else : return to_inchikey ( mol1 ) == to_inchikey ( mol2 )","title":"same_mol()"},{"location":"api/datamol.html#datamol.mol.sanitize_first","text":"Sanitize a list of molecules and return the first valid molecule seen in the list. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules. required charge_neutral bool whether charge neutralization should be applied. False sanifix bool whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. True Returns: Name Type Description mol Mol a molecule. Source code in datamol/mol.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def sanitize_first ( mols : List [ Mol ], charge_neutral : bool = False , sanifix : bool = True ) -> Mol : \"\"\"Sanitize a list of molecules and return the first valid molecule seen in the list. Args: mols: a list of molecules. charge_neutral: whether charge neutralization should be applied. sanifix: whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. Returns: mol: a molecule. \"\"\" for mol in mols : mol = sanitize_mol ( mol , charge_neutral = charge_neutral , sanifix = sanifix ) if mol : return mol return None","title":"sanitize_first()"},{"location":"api/datamol.html#datamol.mol.sanitize_mol","text":"An augmented version of RDKit sanitize=True . It uses a mol-SMILES-mol conversion to catch potential aromaticity errors and try to fix aromatic nitrogen (using the popular sanifix4 script). Optionally, it can neutralize the charge of the molecule. Note #1: Only the first conformer (if present) will be preserved and a warning will be displayed if more than one conformer is detected. Note #2: The molecule's properties will be preserved but the atom's properties will be lost. Parameters: Name Type Description Default mol Mol a molecule. required charge_neutral bool whether charge neutralization should be applied. False sanifix bool whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. True verbose bool Whether displaying a warning about multiple conformers. True add_hs bool Add hydrogens to the returned molecule. Useful when the input molecule already contains hydrogens. False Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def sanitize_mol ( mol : Mol , charge_neutral : bool = False , sanifix : bool = True , verbose : bool = True , add_hs : bool = False , ) -> Optional [ Mol ]: \"\"\"An augmented version of RDKit `sanitize=True`. It uses a mol-SMILES-mol conversion to catch potential aromaticity errors and try to fix aromatic nitrogen (using the popular sanifix4 script). Optionally, it can neutralize the charge of the molecule. Note #1: Only the first conformer (if present) will be preserved and a warning will be displayed if more than one conformer is detected. Note #2: The molecule's properties will be preserved but the atom's properties will be lost. Args: mol: a molecule. charge_neutral: whether charge neutralization should be applied. sanifix: whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens. verbose: Whether displaying a warning about multiple conformers. add_hs: Add hydrogens to the returned molecule. Useful when the input molecule already contains hydrogens. Returns: mol: a molecule. \"\"\" if mol is None : return mol # Extract properties. original_mol = copy_mol ( mol ) properties = original_mol . GetPropsAsDict () if charge_neutral : mol = to_neutral ( mol ) if sanifix : mol = _sanifix4 . sanifix ( mol ) if mol is not None : # Detect multiple conformers if verbose and mol . GetNumConformers () > 1 : logger . warning ( f \"The molecule contains multiple conformers. Only the first one will be preserved.\" ) # Try catch to avoid occasional aromaticity errors try : # `cxsmiles` is used here to preserve the first conformer. mol = to_mol ( to_smiles ( mol , cxsmiles = True ), sanitize = True , add_hs = add_hs ) except Exception : mol = None if mol is not None : # Insert back properties. mol = set_mol_props ( mol , properties ) return mol","title":"sanitize_mol()"},{"location":"api/datamol.html#datamol.mol.sanitize_smiles","text":"Takes SMILES string and returns its sanitized version. Parameters: Name Type Description Default smiles Optional [ str ] smiles to be sanitized. required isomeric bool Whether to include information about stereochemistry in the SMILES. True Returns: Type Description Optional [ str ] sanitized smiles. Source code in datamol/mol.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def sanitize_smiles ( smiles : Optional [ str ], isomeric : bool = True ) -> Optional [ str ]: \"\"\"Takes SMILES string and returns its sanitized version. Args: smiles: smiles to be sanitized. isomeric: Whether to include information about stereochemistry in the SMILES. Returns: sanitized smiles. \"\"\" mol = None try : mol = to_mol ( smiles , sanitize = False ) mol = sanitize_mol ( mol , False ) except Exception : return None if mol is None : return None try : smiles = to_smiles ( mol , isomeric = isomeric ) except : return None return smiles","title":"sanitize_smiles()"},{"location":"api/datamol.html#datamol.mol.set_dative_bonds","text":"Replaces some single bonds between metals and atoms with atomic numbers in fromAtoms with dative bonds. The replacement is only done if the atom has \"too many\" bonds. Parameters: Name Type Description Default mol Mol molecule with bond to modify required from_atoms Tuple [ int , int ] List of atoms (symbol or atomic number) to consider for bond replacement. By default, only Nitrogen (7) and Oxygen (8) are considered. (7, 8) Returns: Type Description Optional [ Mol ] The modified molecule. Source code in datamol/mol.py 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 def set_dative_bonds ( mol : Mol , from_atoms : Tuple [ int , int ] = ( 7 , 8 )) -> Optional [ Mol ]: \"\"\"Replaces some single bonds between metals and atoms with atomic numbers in fromAtoms with dative bonds. The replacement is only done if the atom has \"too many\" bonds. Arguments: mol: molecule with bond to modify from_atoms: List of atoms (symbol or atomic number) to consider for bond replacement. By default, only Nitrogen (7) and Oxygen (8) are considered. Returns: The modified molecule. \"\"\" rwmol = RWMol ( mol ) rwmol . UpdatePropertyCache ( strict = False ) metals = [ at for at in rwmol . GetAtoms () if is_transition_metal ( at )] for metal in metals : for nbr in metal . GetNeighbors (): if ( nbr . GetAtomicNum () in from_atoms or nbr . GetSymbol () in from_atoms ) and ( nbr . GetExplicitValence () > PERIODIC_TABLE . GetDefaultValence ( nbr . GetAtomicNum ()) and rwmol . GetBondBetweenAtoms ( nbr . GetIdx (), metal . GetIdx ()) . GetBondType () == SINGLE_BOND ): rwmol . RemoveBond ( nbr . GetIdx (), metal . GetIdx ()) rwmol . AddBond ( nbr . GetIdx (), metal . GetIdx (), DATIVE_BOND ) return rwmol","title":"set_dative_bonds()"},{"location":"api/datamol.html#datamol.mol.set_mol_props","text":"Set properties to a mol from a dict. Parameters: Name Type Description Default mol Mol the mol where to copy the props. required props Dict [ str , Any ] the props to copy. required copy bool whether to copy the provided mol False Source code in datamol/mol.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 def set_mol_props ( mol : Mol , props : Dict [ str , Any ], copy : bool = False , ) -> Mol : \"\"\"Set properties to a mol from a dict. Args: mol: the mol where to copy the props. props: the props to copy. copy: whether to copy the provided mol \"\"\" if copy is True : mol = copy_mol ( mol ) for k , v in props . items (): if isinstance ( v , bool ): mol . SetBoolProp ( k , v ) elif isinstance ( v , int ): # NOTE(hadim): A Python integer is 32 bits and RDKit seems # to overflow before that. Here we catch the error # and instead uses silently `SetDoubleProp` instead. try : mol . SetIntProp ( k , v ) except OverflowError : mol . SetDoubleProp ( k , v ) elif isinstance ( v , float ): mol . SetDoubleProp ( k , v ) else : mol . SetProp ( k , str ( v )) return mol","title":"set_mol_props()"},{"location":"api/datamol.html#datamol.mol.standardize_mol","text":"This function returns a standardized version the given molecule. It relies on the RDKit rdMolStandardize module which is largely inspired from MolVS . Parameters: Name Type Description Default mol Mol A molecule to standardize. required disconnect_metals bool Disconnect metals that are defined as covalently bonded to non-metal. Depending on the source of the database, some compounds may be reported in salt form or associated to metallic ions (e.g. the sodium salt of a carboxylic compound). In most cases, these counter-ions are not relevant so the use of this function is required before further utilization of the dataset. In summary the process is the following: Break covalent bonds between metals and organic atoms under certain conditions. First, disconnect N, O, F from any metal. Then disconnect other non-metals from transition metals (with exceptions). For every bond broken, adjust the charges of the begin and end atoms accordingly. False normalize bool Applies a series of standard transformations to correct functional groups and recombine charges. It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the overall proper charge of the compound. It includes: Uncharge-separate sulfones Charge-separate nitro groups Charge-separate pyridine oxide Charge-separate azide Charge-separate diazo and azo groups Charge-separate sulfoxides Hydrazine-diazonium system True reionize bool If one or more acidic functionalities are present in the molecule, this option ensures the correct neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens. For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge The algorithm works as follows: Use SMARTS to find the strongest protonated acid and the weakest ionized acid. If the ionized acid is weaker than the protonated acid, swap proton and repeat. True uncharge bool This option neutralize the molecule by reversing the protonation state of protonated and deprotonated groups, if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid). In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge to ensure a net zero charge. False stereo bool Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry ( AssignStereochemistry ). True Returns: Name Type Description mol Mol A standardized molecule. Source code in datamol/mol.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 def standardize_mol ( mol : Mol , disconnect_metals : bool = False , normalize : bool = True , reionize : bool = True , uncharge : bool = False , stereo : bool = True , ) -> Mol : r \"\"\" This function returns a standardized version the given molecule. It relies on the RDKit [`rdMolStandardize` module](https://www.rdkit.org/docs/source/rdkit.Chem.MolStandardize.rdMolStandardize.html) which is largely inspired from [MolVS](https://github.com/mcs07/MolVS). Arguments: mol: A molecule to standardize. disconnect_metals: Disconnect metals that are defined as covalently bonded to non-metal. Depending on the source of the database, some compounds may be reported in salt form or associated to metallic ions (e.g. the sodium salt of a carboxylic compound). In most cases, these counter-ions are not relevant so the use of this function is required before further utilization of the dataset. In summary the process is the following: - Break covalent bonds between metals and organic atoms under certain conditions. - First, disconnect N, O, F from any metal. Then disconnect other non-metals from transition metals (with exceptions). - For every bond broken, adjust the charges of the begin and end atoms accordingly. normalize: Applies a series of standard transformations to correct functional groups and recombine charges. It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the overall proper charge of the compound. It includes: - Uncharge-separate sulfones - Charge-separate nitro groups - Charge-separate pyridine oxide - Charge-separate azide - Charge-separate diazo and azo groups - Charge-separate sulfoxides - Hydrazine-diazonium system reionize: If one or more acidic functionalities are present in the molecule, this option ensures the correct neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens. For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge The algorithm works as follows: - Use SMARTS to find the strongest protonated acid and the weakest ionized acid. - If the ionized acid is weaker than the protonated acid, swap proton and repeat. uncharge: This option neutralize the molecule by reversing the protonation state of protonated and deprotonated groups, if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid). In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge to ensure a net zero charge. stereo: Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry (`AssignStereochemistry`). Returns: mol: A standardized molecule. \"\"\" mol = copy_mol ( mol ) if disconnect_metals : md = rdMolStandardize . MetalDisconnector () mol = md . Disconnect ( mol ) if normalize : mol = rdMolStandardize . Normalize ( mol ) if reionize : reionizer = rdMolStandardize . Reionizer () mol = reionizer . reionize ( mol ) if uncharge : uncharger = rdMolStandardize . Uncharger () mol = uncharger . uncharge ( mol ) if stereo : AssignStereochemistry ( mol , force = False , cleanIt = True ) return mol","title":"standardize_mol()"},{"location":"api/datamol.html#datamol.mol.standardize_smiles","text":"Apply smile standardization procedure. This is a convenient function wrapped arrounf RDKit smiles standardizer and tautomeric canonicalization. Parameters: Name Type Description Default smiles str Smiles to standardize required tautomer bool Whether to canonicalize tautomers False Returns: Name Type Description standard_smiles str the standardized smiles Source code in datamol/mol.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def standardize_smiles ( smiles : str , tautomer : bool = False ) -> str : r \"\"\" Apply smile standardization procedure. This is a convenient function wrapped arrounf RDKit smiles standardizer and tautomeric canonicalization. Args: smiles: Smiles to standardize tautomer: Whether to canonicalize tautomers Returns: standard_smiles: the standardized smiles \"\"\" smiles = rdMolStandardize . StandardizeSmiles ( smiles ) if tautomer : smiles = canonicalize_tautomer_smiles ( smiles ) return smiles","title":"standardize_smiles()"},{"location":"api/datamol.html#datamol.mol.strip_mol_to_core","text":"Strip a molecule to its core, i.e. remove all atoms not in the core. This method 'guess' the molecular core, by finding the ring system. Parameters: Name Type Description Default mol Mol A molecule. required bond_cutter Mol A molecule used to cut the bonds. None Source code in datamol/mol.py 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 def strip_mol_to_core ( mol : Mol , bond_cutter : Mol = None ): \"\"\"Strip a molecule to its core, i.e. remove all atoms not in the core. This method 'guess' the molecular core, by finding the ring system. Args: mol: A molecule. bond_cutter: A molecule used to cut the bonds. \"\"\" if bond_cutter is None : bond_cutter = from_smarts ( \"[R;!$(*=,#[!#6])]!@!=!#[*;$([A;!R][A;!R])]\" ) with without_rdkit_log (): scaffold = MurckoScaffold . GetScaffoldForMol ( mol ) out = mol . GetSubstructMatches ( bond_cutter ) bond_inds = [ mol . GetBondBetweenAtoms ( i , j ) . GetIdx () for i , j in out ] if len ( bond_inds ) > 0 : fragmented = rdmolops . FragmentOnBonds ( mol , bond_inds ) fragmented = remove_dummies ( fragmented ) fragmented = to_scaffold_murcko ( fragmented ) scaffold = keep_largest_fragment ( fragmented ) return scaffold","title":"strip_mol_to_core()"},{"location":"api/datamol.html#datamol.mol.substructure_matching_bonds","text":"Perform a substructure match using GetSubstructMatches but instead of returning only the atom indices also return the bond indices. Parameters: Name Type Description Default mol Mol A molecule. required query Mol A molecule used as a query to match against. required **kwargs Any Any other arguments to pass to mol.GetSubstructMatches() . {} Returns: Name Type Description atom_matches list A list of lists of atom indices. bond_matches list A list of lists of bond indices. Source code in datamol/mol.py 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 def substructure_matching_bonds ( mol : Mol , query : Mol , ** kwargs : Any ) -> Tuple [ list , list ]: \"\"\"Perform a substructure match using `GetSubstructMatches` but instead of returning only the atom indices also return the bond indices. Args: mol: A molecule. query: A molecule used as a query to match against. **kwargs: Any other arguments to pass to `mol.GetSubstructMatches()`. Returns: atom_matches: A list of lists of atom indices. bond_matches: A list of lists of bond indices. \"\"\" # NOTE(hadim): If more substructure functions are added here, consider moving it to # a dedicated `substructure` module. # Set default arguments kwargs . setdefault ( \"uniquify\" , True ) # Get the matching atom indices atom_matches = list ( mol . GetSubstructMatches ( query , ** kwargs )) # Get the bond to highligh from the query query_bond_indices = [ ( bond . GetBeginAtomIdx (), bond . GetEndAtomIdx ()) for bond in query . GetBonds () ] # Retrieve the atom indices query_atom_indices = [ atom . GetIdx () for i , atom in enumerate ( query . GetAtoms ())] bond_matches = [] for match in atom_matches : # Map the atom of the query to the atom of the mol matching the query atom_map = dict ( zip ( query_atom_indices , match )) # For this match atoms we now, we use the map to retrieve the matching bonds # in the mol. mol_bond_indices = [( atom_map [ a1 ], atom_map [ a2 ]) for a1 , a2 in query_bond_indices ] # Convert the bond atom indices to bond indices mol_bond_indices = [ mol . GetBondBetweenAtoms ( a1 , a2 ) . GetIdx () for a1 , a2 in mol_bond_indices ] bond_matches . append ( mol_bond_indices ) return atom_matches , bond_matches","title":"substructure_matching_bonds()"},{"location":"api/datamol.html#datamol.mol.to_mol","text":"Convert an input molecule (smiles representation) into a Mol . Parameters: Name Type Description Default mol Union [ str , Mol ] A SMILES or a molecule. required add_hs bool Whether hydrogens should be added the molecule. False explicit_only bool Whether to only add explicit hydrogen or both (implicit and explicit). when add_hs is set to True. False ordered bool Whether the atom should be ordered. This option is important if you want to ensure that the features returned will always maintain a single atom order for the same molecule, regardless of its original SMILES representation. False kekulize bool Whether to perform kekulization of the input molecules. False sanitize bool Whether to apply rdkit sanitization when input is a SMILES. True Returns: Name Type Description mol Optional [ Mol ] the molecule if some conversion have been made. If the conversion fails Optional [ Mol ] None is returned so make sure that you handle this case on your own. Source code in datamol/mol.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def to_mol ( mol : Union [ str , Mol ], add_hs : bool = False , explicit_only : bool = False , ordered : bool = False , kekulize : bool = False , sanitize : bool = True , ) -> Optional [ Mol ]: \"\"\"Convert an input molecule (smiles representation) into a `Mol`. Args: mol: A SMILES or a molecule. add_hs: Whether hydrogens should be added the molecule. explicit_only: Whether to only add explicit hydrogen or both (implicit and explicit). when `add_hs` is set to True. ordered: Whether the atom should be ordered. This option is important if you want to ensure that the features returned will always maintain a single atom order for the same molecule, regardless of its original SMILES representation. kekulize: Whether to perform kekulization of the input molecules. sanitize: Whether to apply rdkit sanitization when input is a SMILES. Returns: mol: the molecule if some conversion have been made. If the conversion fails None is returned so make sure that you handle this case on your own. \"\"\" if not isinstance ( mol , ( str , Mol )): raise ValueError ( f \"Input should be a Mol or a string instead of ' { type ( mol ) } '\" ) if isinstance ( mol , str ): _mol = MolFromSmiles ( mol , sanitize = sanitize ) if not sanitize and _mol is not None : _mol . UpdatePropertyCache ( False ) else : _mol = mol # Add hydrogens if _mol is not None and add_hs : _mol = AddHs ( _mol , explicitOnly = explicit_only , addCoords = True ) # Reorder atoms if _mol is not None and ordered : _mol = reorder_atoms ( _mol ) if _mol is not None and kekulize : Kekulize ( _mol , clearAromaticFlags = False ) return _mol","title":"to_mol()"},{"location":"api/datamol.html#datamol.mol.to_neutral","text":"Neutralize the charge of a molecule. Parameters: Name Type Description Default mol Optional [ Mol ] a molecule. required Returns: Name Type Description mol Optional [ Mol ] a molecule. Source code in datamol/mol.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def to_neutral ( mol : Optional [ Mol ]) -> Optional [ Mol ]: \"\"\"Neutralize the charge of a molecule. Args: mol: a molecule. Returns: mol: a molecule. \"\"\" if mol is None : return mol for a in mol . GetAtoms (): if a . GetFormalCharge () < 0 or ( a . GetExplicitValence () >= PERIODIC_TABLE . GetDefaultValence ( a . GetSymbol ()) and a . GetFormalCharge () > 0 ): a . SetFormalCharge ( 0 ) a . UpdatePropertyCache ( False ) return mol","title":"to_neutral()"},{"location":"api/datamol.html#datamol.mol.to_scaffold_murcko","text":"Extract the Murcko scaffold from a molecule. Parameters: Name Type Description Default mol Mol A molecule. required make_generic bool Whether to make the scaffold generic. False Source code in datamol/mol.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def to_scaffold_murcko ( mol : Mol , make_generic : bool = False ): \"\"\"Extract the Murcko scaffold from a molecule. Args: mol: A molecule. make_generic: Whether to make the scaffold generic. \"\"\" scf = MurckoScaffold . GetScaffoldForMol ( mol ) # NOTE(hadim): this is already done in `GetScaffoldForMol` # Note sure we need it here. scf . UpdatePropertyCache () Chem . GetSymmSSSR ( scf ) # type: ignore if make_generic : scf = make_scaffold_generic ( scf ) scf = to_mol ( scf ) return scf","title":"to_scaffold_murcko()"},{"location":"api/datamol.html#datamol.mol.unique_id","text":"A datamol unique molecule ID. The ID is an MD5 hash of the non-standard InChiKey provided by dm.to_inchikey_non_standard() . It guarantees uniqueness for different tautomeric forms of the same molecule. Parameters: Name Type Description Default mol Mol A molecule. required Source code in datamol/mol.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def unique_id ( mol : Mol ) -> Optional [ str ]: \"\"\"A datamol unique molecule ID. The ID is an MD5 hash of the non-standard InChiKey provided by `dm.to_inchikey_non_standard()`. It guarantees uniqueness for different tautomeric forms of the same molecule. Args: mol: A molecule. \"\"\" ik = to_inchikey_non_standard ( mol ) if ik is None : return None return hashlib . md5 ( ik . encode ( \"utf-8\" )) . hexdigest ()","title":"unique_id()"},{"location":"api/datamol.html#module-io","text":"","title":"Module io"},{"location":"api/datamol.html#datamol.io","text":"","title":"io"},{"location":"api/datamol.html#datamol.io.read_csv","text":"Read a CSV file. Parameters: Name Type Description Default urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required smiles_column Optional [ str ] Use this column to build a mol column. None mol_column str Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. 'mol' **kwargs Any Arguments to pass to pd.read_csv() . {} Returns: Name Type Description df pd . DataFrame a pandas.DataFrame Source code in datamol/io.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def read_csv ( urlpath : Union [ str , os . PathLike , IO ], smiles_column : Optional [ str ] = None , mol_column : str = \"mol\" , ** kwargs : Any , ) -> pd . DataFrame : \"\"\"Read a CSV file. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. smiles_column: Use this column to build a mol column. mol_column: Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. **kwargs: Arguments to pass to `pd.read_csv()`. Returns: df: a `pandas.DataFrame` \"\"\" df : pd . DataFrame = pd . read_csv ( urlpath , ** kwargs ) # type: ignore if smiles_column is not None : PandasTools . AddMoleculeColumnToFrame ( df , smiles_column , mol_column ) return df","title":"read_csv()"},{"location":"api/datamol.html#datamol.io.read_excel","text":"Read an excel file. Parameters: Name Type Description Default urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required sheet_name Optional [ Union [ str , int , list ]] see pandas.read_excel() doc. 0 mol_column str Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. 'mol' mol_column str name to give to the mol column. 'mol' **kwargs Any Arguments to pass to pd.read_excel() . {} Returns: Name Type Description df pd . DataFrame a pandas.DataFrame Source code in datamol/io.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def read_excel ( urlpath : Union [ str , os . PathLike , IO ], sheet_name : Optional [ Union [ str , int , list ]] = 0 , smiles_column : Optional [ str ] = None , mol_column : str = \"mol\" , ** kwargs : Any , ) -> pd . DataFrame : \"\"\"Read an excel file. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. sheet_name: see `pandas.read_excel()` doc. mol_column: Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file. mol_column: name to give to the mol column. **kwargs: Arguments to pass to `pd.read_excel()`. Returns: df: a `pandas.DataFrame` \"\"\" df = pd . read_excel ( urlpath , sheet_name = sheet_name , ** kwargs ) df = cast ( pd . DataFrame , df ) if smiles_column is not None : PandasTools . AddMoleculeColumnToFrame ( df , smiles_column , mol_column ) return df","title":"read_excel()"},{"location":"api/datamol.html#datamol.io.read_molblock","text":"Read a Mol block. Note that potential molecule properties are not read. Parameters: Name Type Description Default molblock str String containing the Mol block. required sanitize bool Whether to sanitize the molecules. True strict_parsing bool If set to false, the parser is more lax about correctness of the contents. True remove_hs bool Whether to remove the existing hydrogens in the SDF files. True fail_if_invalid bool If set to true, the parser will raise an exception if the molecule is invalid instead of returning None. False Source code in datamol/io.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def read_molblock ( molblock : str , sanitize : bool = True , strict_parsing : bool = True , remove_hs : bool = True , fail_if_invalid : bool = False , ) -> Optional [ dm . Mol ]: \"\"\"Read a Mol block. Note that potential molecule properties are **not** read. Args: molblock: String containing the Mol block. sanitize: Whether to sanitize the molecules. strict_parsing: If set to false, the parser is more lax about correctness of the contents. remove_hs: Whether to remove the existing hydrogens in the SDF files. fail_if_invalid: If set to true, the parser will raise an exception if the molecule is invalid instead of returning None. \"\"\" mol = rdmolfiles . MolFromMolBlock ( molblock , sanitize = sanitize , removeHs = remove_hs , strictParsing = strict_parsing , ) if mol is None and fail_if_invalid : raise ValueError ( f \"Invalid molecule: { molblock } \" ) return mol","title":"read_molblock()"},{"location":"api/datamol.html#datamol.io.read_sdf","text":"Read an SDF file. Note: This function is meant to be used with dataset that fit in-memory . For a more advanced usage we suggest you to use directly Chem.ForwardSDMolSupplier . Parameters: Name Type Description Default urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required sanitize bool Whether to sanitize the molecules. True as_df bool Whether to return a list mol or a pandas DataFrame. False smiles_column Optional [ str ] Name of the SMILES column. Only relevant if as_df is True. 'smiles' mol_column Optional [ str ] Name of the mol column. Only relevant if as_df is True. None include_private bool Include private properties in the columns. Only relevant if as_df is True. False include_computed bool Include computed properties in the columns. Only relevant if as_df is True. False strict_parsing bool If set to false, the parser is more lax about correctness of the contents. True remove_hs bool Whether to remove the existing hydrogens in the SDF files. True Source code in datamol/io.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def read_sdf ( urlpath : Union [ str , os . PathLike , IO ], sanitize : bool = True , as_df : bool = False , smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , include_private : bool = False , include_computed : bool = False , strict_parsing : bool = True , remove_hs : bool = True , ) -> Union [ List [ Mol ], pd . DataFrame ]: \"\"\"Read an SDF file. Note: This function is meant to be used with dataset that fit _in-memory_. For a more advanced usage we suggest you to use directly `Chem.ForwardSDMolSupplier`. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. sanitize: Whether to sanitize the molecules. as_df: Whether to return a list mol or a pandas DataFrame. smiles_column: Name of the SMILES column. Only relevant if `as_df` is True. mol_column: Name of the mol column. Only relevant if `as_df` is True. include_private: Include private properties in the columns. Only relevant if `as_df` is True. include_computed: Include computed properties in the columns. Only relevant if `as_df` is True. strict_parsing: If set to false, the parser is more lax about correctness of the contents. remove_hs: Whether to remove the existing hydrogens in the SDF files. \"\"\" # File-like object if isinstance ( urlpath , io . IOBase ): supplier = rdmolfiles . ForwardSDMolSupplier ( urlpath , sanitize = sanitize , strictParsing = strict_parsing , removeHs = remove_hs , ) mols = list ( supplier ) # Regular local or remote paths else : with fsspec . open ( urlpath ) as f : # Handle gzip file if needed if str ( urlpath ) . endswith ( \".gz\" ) or str ( urlpath ) . endswith ( \".gzip\" ): f = gzip . open ( f ) # type: ignore supplier = rdmolfiles . ForwardSDMolSupplier ( f , sanitize = sanitize , strictParsing = strict_parsing , removeHs = remove_hs , ) mols = list ( supplier ) # Discard None values mols = [ mol for mol in mols if mol is not None ] # Convert to dataframe if as_df : return dm . to_df ( mols , smiles_column = smiles_column , mol_column = mol_column , include_private = include_private , include_computed = include_computed , ) # type: ignore return mols","title":"read_sdf()"},{"location":"api/datamol.html#datamol.io.read_smi","text":"Read a list of smiles from am .smi file. Parameters: Name Type Description Default urlpath Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ] Path to a file or a file-like object. Path can be remote or local. Note: file-like object are not supported yet. required Source code in datamol/io.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def read_smi ( urlpath : Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ], ) -> Sequence [ Mol ]: \"\"\"Read a list of smiles from am `.smi` file. Args: urlpath: Path to a file or a file-like object. Path can be remote or local. Note: file-like object are not supported yet. \"\"\" active_path = urlpath # NOTE(hadim): the temporary local file copy # is because `SmilesMolSupplier` does not support # using file-like object, only path. # Copy to a local temporary path if the path is a remote one. if not fsspec . utils . can_be_local ( str ( urlpath )): active_path = pathlib . Path ( tempfile . mkstemp ()[ 1 ]) dm . utils . fs . copy_file ( urlpath , active_path ) # Read the molecules supplier = rdmolfiles . SmilesMolSupplier ( str ( active_path ), titleLine = 0 ) mols = [ mol for mol in supplier if mol is not None ] # Delete the local temporary path if not fsspec . utils . can_be_local ( str ( urlpath )): pathlib . Path ( str ( active_path )) . unlink () return mols","title":"read_smi()"},{"location":"api/datamol.html#datamol.io.to_molblock","text":"Convert a molecule to a mol block string. Note that any molecule properties are lost. Parameters: Name Type Description Default mol Mol A molecule. required include_stereo bool Toggles inclusion of stereochemical information in the output. True conf_id int Selects which conformation to output. -1 kekulize bool Triggers kekulization of the molecule before it's written, as suggested by the MDL spec. True force_V3000 bool Force generation a V3000 mol block (happens automatically with more than 999 atoms or bonds). False Source code in datamol/io.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def to_molblock ( mol : Mol , include_stereo : bool = True , conf_id : int = - 1 , kekulize : bool = True , force_V3000 : bool = False , ): \"\"\"Convert a molecule to a mol block string. Note that any molecule properties are lost. Args: mol: A molecule. include_stereo: Toggles inclusion of stereochemical information in the output. conf_id: Selects which conformation to output. kekulize: Triggers kekulization of the molecule before it's written, as suggested by the MDL spec. force_V3000: Force generation a V3000 mol block (happens automatically with more than 999 atoms or bonds). \"\"\" molblock = rdmolfiles . MolToMolBlock ( mol , includeStereo = include_stereo , confId = conf_id , kekulize = kekulize , forceV3000 = force_V3000 , ) return molblock","title":"to_molblock()"},{"location":"api/datamol.html#datamol.io.to_sdf","text":"Write molecules to a file. Parameters: Name Type Description Default mols Union [ Mol , Sequence [ Mol ], pd . DataFrame ] a dataframe, a molecule or a list of molecule. required urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required smiles_column Optional [ str ] Column name to extract the molecule. 'smiles' mol_column Optional [ str ] Column name to extract the molecule. It takes precedence over smiles_column . None Source code in datamol/io.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def to_sdf ( mols : Union [ Mol , Sequence [ Mol ], pd . DataFrame ], urlpath : Union [ str , os . PathLike , IO ], smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , ): \"\"\"Write molecules to a file. Args: mols: a dataframe, a molecule or a list of molecule. urlpath: Path to a file or a file-like object. Path can be remote or local. smiles_column: Column name to extract the molecule. mol_column: Column name to extract the molecule. It takes precedence over `smiles_column`. \"\"\" if isinstance ( mols , pd . DataFrame ): mols = dm . from_df ( mols , smiles_column = smiles_column , mol_column = mol_column ) elif isinstance ( mols , Mol ): mols = [ mols ] # Filter out None values mols = [ mol for mol in mols if mol is not None ] # File-like object if isinstance ( urlpath , io . IOBase ): writer = rdmolfiles . SDWriter ( urlpath ) for mol in mols : writer . write ( mol ) writer . close () # Regular local or remote paths else : with fsspec . open ( urlpath , mode = \"w\" ) as f : writer = rdmolfiles . SDWriter ( f ) for mol in mols : writer . write ( mol ) writer . close ()","title":"to_sdf()"},{"location":"api/datamol.html#datamol.io.to_smi","text":"Save a list of molecules in an .smi file. Parameters: Name Type Description Default mols Sequence [ Mol ] a list of molecules. required urlpath Union [ str , os . PathLike , IO ] Path to a file or a file-like object. Path can be remote or local. required error_if_empty bool whether to raise and error if the input list is empty. False Source code in datamol/io.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def to_smi ( mols : Sequence [ Mol ], urlpath : Union [ str , os . PathLike , IO ], error_if_empty : bool = False , ): \"\"\"Save a list of molecules in an `.smi` file. Args: mols: a list of molecules. urlpath: Path to a file or a file-like object. Path can be remote or local. error_if_empty: whether to raise and error if the input list is empty. \"\"\" if len ( mols ) == 0 and error_if_empty : raise ValueError ( \"The list of mols/smiles provided is empty.\" ) # Filter out None values mols = [ mol for mol in mols if mol is not None ] # File-like object if isinstance ( urlpath , io . IOBase ): writer = rdmolfiles . SmilesWriter ( urlpath , includeHeader = False , nameHeader = \"\" ) for mol in mols : writer . write ( mol ) writer . close () # Regular local or remote paths else : with fsspec . open ( urlpath , \"w\" ) as f : writer = rdmolfiles . SmilesWriter ( f , includeHeader = False , nameHeader = \"\" ) for mol in mols : writer . write ( mol ) writer . close ()","title":"to_smi()"},{"location":"api/datamol.html#datamol.io.to_xlsx","text":"Write molecules to an Excel file with a molecule column as an RDKit rendered image. Parameters: Name Type Description Default mols Union [ Mol , Sequence [ Mol ], pd . DataFrame ] a dataframe, a molecule or a list of molecule. required urlpath Union [ str , os . PathLike ] Path to a file or a file-like object. Path can be remote or local. required smiles_column Optional [ str ] Column name to extract the molecule. 'smiles' mol_column str Column name to extract the molecule. It takes precedence over smiles_column . Column name to write the RDKit rendered image. If none, the molecule images are not written. 'mol' Source code in datamol/io.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def to_xlsx ( mols : Union [ Mol , Sequence [ Mol ], pd . DataFrame ], urlpath : Union [ str , os . PathLike ], smiles_column : Optional [ str ] = \"smiles\" , mol_column : str = \"mol\" , mol_size : List [ int ] = [ 300 , 300 ], ): \"\"\"Write molecules to an Excel file with a molecule column as an RDKit rendered image. Args: mols: a dataframe, a molecule or a list of molecule. urlpath: Path to a file or a file-like object. Path can be remote or local. smiles_column: Column name to extract the molecule. mol_column: Column name to extract the molecule. It takes precedence over `smiles_column`. Column name to write the RDKit rendered image. If none, the molecule images are not written. \"\"\" if isinstance ( mols , Mol ): mols = [ mols ] if isinstance ( mols , Sequence ): mols = [ mol for mol in mols if mol is not None ] mols = dm . to_df ( mols , smiles_column = smiles_column , mol_column = mol_column ) if mols is None or mols . empty : # type: ignore raise ValueError ( \"No molecules to write\" ) with fsspec . open ( urlpath , mode = \"wb\" ) as f : PandasTools . SaveXlsxFromFrame ( mols , f , molCol = mol_column , size = mol_size )","title":"to_xlsx()"},{"location":"api/datamol.html#module-convert","text":"","title":"Module convert"},{"location":"api/datamol.html#datamol.convert","text":"","title":"convert"},{"location":"api/datamol.html#datamol.convert.from_df","text":"Convert a dataframe to a list of mols. For the reverse operation, you might to check dm.to_df() . Note If smiles_column is used to build the molecules, this property is removed from the molecules' properties. You can decide to conserve the SMILES column by setting conserve_smiles to True. Parameters: Name Type Description Default df pd . DataFrame a dataframe. required smiles_column Optional [ str ] Column name to extract the molecule. 'smiles' mol_column Optional [ str ] Column name to extract the molecule. It takes precedence over smiles_column . None conserve_smiles bool Whether to conserve the SMILES in the mols' props. False sanitize bool Whether to sanitize if smiles_column is not None. True Source code in datamol/convert.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def from_df ( df : pd . DataFrame , smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , conserve_smiles : bool = False , sanitize : bool = True , ) -> List [ Mol ]: \"\"\"Convert a dataframe to a list of mols. For the reverse operation, you might to check `dm.to_df()`. Note: If `smiles_column` is used to build the molecules, this property is removed from the molecules' properties. You can decide to conserve the SMILES column by setting `conserve_smiles` to True. Args: df: a dataframe. smiles_column: Column name to extract the molecule. mol_column: Column name to extract the molecule. It takes precedence over `smiles_column`. conserve_smiles: Whether to conserve the SMILES in the mols' props. sanitize: Whether to sanitize if `smiles_column` is not None. \"\"\" if smiles_column is None and mol_column is None : raise ValueError ( \"Either `smiles_column` or `mol_column` must be not None.\" ) if len ( df ) == 0 : return [] # Try to detect the mol column if `mol_column` is None. if mol_column is None : for col in df . columns : if isinstance ( df [ col ] . iloc [ 0 ], Mol ): mol_column = col def _row_to_mol ( row ): props = row . to_dict () if mol_column is not None : mol = props . pop ( mol_column ) else : if conserve_smiles : smiles = props [ smiles_column ] else : # If a SMILES column is used to create the molecule then it is removed from the # properties. smiles = props . pop ( smiles_column ) mol = dm . to_mol ( smiles , sanitize = sanitize ) if mol is None : return None dm . set_mol_props ( mol , props ) return mol return df . apply ( _row_to_mol , axis = 1 ) . tolist ()","title":"from_df()"},{"location":"api/datamol.html#datamol.convert.from_inchi","text":"Convert an InChi to a mol. Parameters: Name Type Description Default inchi Optional [ str ] an inchi string. required sanitize bool do sanitize. True remove_hs bool do remove hs. True Returns: Type Description Optional [ Mol ] mol Source code in datamol/convert.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def from_inchi ( inchi : Optional [ str ], sanitize : bool = True , remove_hs : bool = True , ) -> Optional [ Mol ]: \"\"\"Convert an InChi to a mol. Args: inchi: an inchi string. sanitize: do sanitize. remove_hs: do remove hs. Returns: mol \"\"\" if inchi is None : return None return Chem . MolFromInchi ( inchi , sanitize = sanitize , removeHs = remove_hs )","title":"from_inchi()"},{"location":"api/datamol.html#datamol.convert.from_selfies","text":"Convert a SEFLIES to a smiles or a mol. Parameters: Name Type Description Default selfies str a selfies. required as_mol str whether to return a mol or a smiles. False Returns: Type Description Optional [ Union [ str , Mol ]] smiles or mol. Source code in datamol/convert.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def from_selfies ( selfies : str , as_mol : bool = False ) -> Optional [ Union [ str , Mol ]]: \"\"\"Convert a SEFLIES to a smiles or a mol. Args: selfies: a selfies. as_mol (str, optional): whether to return a mol or a smiles. Returns: smiles or mol. \"\"\" if selfies is None : return None smiles = sf . decoder ( selfies ) if as_mol and smiles is not None : return dm . to_mol ( smiles ) return smiles","title":"from_selfies()"},{"location":"api/datamol.html#datamol.convert.from_smarts","text":"Convert a SMARTS string to a molecule Parameters: Name Type Description Default smarts Optional [ str ] a smarts string required Source code in datamol/convert.py 347 348 349 350 351 352 353 354 355 356 def from_smarts ( smarts : Optional [ str ]) -> Optional [ Mol ]: \"\"\"Convert a SMARTS string to a molecule Args: smarts: a smarts string \"\"\" if smarts is None : return None return Chem . MolFromSmarts ( smarts ) # type: ignore","title":"from_smarts()"},{"location":"api/datamol.html#datamol.convert.render_mol_df","text":"Render the molecules column in a dataframe. The rendering is performed in-place only. So nothing is returned. Parameters: Name Type Description Default df pd . DataFrame a dataframe. required Source code in datamol/convert.py 491 492 493 494 495 496 497 498 499 500 def render_mol_df ( df : pd . DataFrame ): \"\"\"Render the molecules column in a dataframe. The rendering is performed in-place only. So nothing is returned. Args: df: a dataframe. \"\"\" # NOTE(hadim): replace by `PandaTools.ChangeMoleculeRendering` once # https://github.com/rdkit/rdkit/issues/3563 is fixed. _ChangeMoleculeRendering ( df )","title":"render_mol_df()"},{"location":"api/datamol.html#datamol.convert.smiles_as_smarts","text":"Convert a smiles to a smarts if possible Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule. required keep_hs bool Whether to keep hydrogen. This will increase the count of H atoms for atoms with attached hydrogens to create a valid smarts without further substitution allowed e.g. [H]-[CH]-[ ] -> [H]-[CH2]-[ ] True Returns: Type Description Optional [ str ] smarts of the molecule Source code in datamol/convert.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def smiles_as_smarts ( mol : Union [ str , Mol ], keep_hs : bool = True ) -> Optional [ str ]: \"\"\"Convert a smiles to a smarts if possible Args: mol: a molecule. keep_hs: Whether to keep hydrogen. This will increase the count of H atoms for atoms with attached hydrogens to create a valid smarts without further substitution allowed e.g. [H]-[CH]-[*] -> [H]-[CH2]-[*] Returns: smarts of the molecule \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None # Change the isotope to 99 for atom in mol . GetAtoms (): # type: ignore if keep_hs : s = sum ( na . GetAtomicNum () == 1 for na in atom . GetNeighbors ()) if s : atom . SetNumExplicitHs ( atom . GetTotalNumHs () + s ) atom . SetIsotope ( 99 ) # Print out the smiles, all the atom attributes will be fully specified smarts = to_smiles ( mol , isomeric = True , explicit_bonds = True ) if smarts is None : return None # Remove the 99 isotope labels smarts = re . sub ( r \"\\[99\" , \"[\" , smarts ) return smarts","title":"smiles_as_smarts()"},{"location":"api/datamol.html#datamol.convert.to_df","text":"Convert a list of mols to a dataframe using each mol properties as a column. For the reverse operation, you might to check dm.from_df() . Parameters: Name Type Description Default mols List [ Mol ] a molecule. required smiles_column Optional [ str ] name of the SMILES column. 'smiles' mol_column Optional [ str ] Name of the column. If not None, rdkit.Chem.PandaTools is used to add a molecule column. None include_private bool Include private properties in the columns. False include_computed bool Include computed properties in the columns. False render_df_mol bool whether to render the molecule in the dataframe to images. If called once, it will be applied for the newly created dataframe with mol in it. True render_all_df_mol bool Whether to render all pandas dataframe mol column as images. False Source code in datamol/convert.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def to_df ( mols : List [ Mol ], smiles_column : Optional [ str ] = \"smiles\" , mol_column : Optional [ str ] = None , include_private : bool = False , include_computed : bool = False , render_df_mol : bool = True , render_all_df_mol : bool = False , ) -> Optional [ pd . DataFrame ]: \"\"\"Convert a list of mols to a dataframe using each mol properties as a column. For the reverse operation, you might to check `dm.from_df()`. Args: mols: a molecule. smiles_column: name of the SMILES column. mol_column: Name of the column. If not None, rdkit.Chem.PandaTools is used to add a molecule column. include_private: Include private properties in the columns. include_computed: Include computed properties in the columns. render_df_mol: whether to render the molecule in the dataframe to images. If called once, it will be applied for the newly created dataframe with mol in it. render_all_df_mol: Whether to render all pandas dataframe mol column as images. \"\"\" # Init a dataframe df = pd . DataFrame () # Feed it with smiles if smiles_column is not None : smiles = [ to_smiles ( mol ) for mol in mols ] df [ smiles_column ] = smiles # Add a mol column if mol_column is not None : df [ mol_column ] = mols # Add any other properties present in the molecule props = [ mol . GetPropsAsDict ( includePrivate = include_private , includeComputed = include_computed , ) for mol in mols ] props_df = pd . DataFrame ( props ) if smiles_column is not None and smiles_column in props_df . columns : logger . warning ( f \"The SMILES column name provided (' { smiles_column } ') is already present in the properties\" \" of the molecules. THe returned dataframe will two columns with the same name.\" ) # Concat the df with the properties df df = pd . concat ([ df , props_df ], axis = 1 ) # Render mol column to images if render_df_mol is True and mol_column is not None : render_mol_df ( df ) if render_all_df_mol : PandasTools . RenderImagesInAllDataFrames () return df","title":"to_df()"},{"location":"api/datamol.html#datamol.convert.to_inchi","text":"Convert a mol to a standard Inchi. Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule. required Source code in datamol/convert.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def to_inchi ( mol : Union [ str , Mol ]) -> Optional [ str ]: \"\"\"Convert a mol to a standard Inchi. Args: mol: a molecule. \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchi_val = Chem . MolToInchi ( mol ) if not inchi_val : return None return inchi_val","title":"to_inchi()"},{"location":"api/datamol.html#datamol.convert.to_inchi_non_standard","text":"Convert a mol to a non-standard Inchi. Note that turning all the flags to False will result in the standard Inchi. Warning : this function will return a non-standard Inchi. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChi. If you don't know much about non-standard InChi, we highly recommend you to use the standard InChi with dm.to_inchi() . Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule. required fixed_hydrogen_layer bool whether to include a fixed hydrogen layer ( /FixedH ). True undefined_stereocenter bool whether to include an undefined stereocenter layer ( /SUU ). True reconnected_metal_layer bool whether to include reconnected metals ( /RecMet ). True tautomerism_keto_enol bool whether to account tautomerism keto-enol ( /KET ). True tautomerism_15 bool whether to account 1,5-tautomerism ( /15T ). True options Optional [ List [ str ]] More InchI options in a form of a list of string. Example: [\"/SRel\", \"/AuxNone\"] . None Source code in datamol/convert.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def to_inchi_non_standard ( mol : Union [ str , Mol ], fixed_hydrogen_layer : bool = True , undefined_stereocenter : bool = True , reconnected_metal_layer : bool = True , tautomerism_keto_enol : bool = True , tautomerism_15 : bool = True , options : Optional [ List [ str ]] = None , ) -> Optional [ str ]: \"\"\"Convert a mol to a non-standard Inchi. Note that turning all the flags to `False` will result in the standard Inchi. **Warning**: this function will return a **non-standard** Inchi. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChi. If you don't know much about non-standard InChi, we highly recommend you to use the standard InChi with `dm.to_inchi()`. Args: mol: a molecule. fixed_hydrogen_layer: whether to include a fixed hydrogen layer (`/FixedH`). undefined_stereocenter: whether to include an undefined stereocenter layer (`/SUU`). reconnected_metal_layer: whether to include reconnected metals (`/RecMet`). tautomerism_keto_enol: whether to account tautomerism keto-enol (`/KET`). tautomerism_15: whether to account 1,5-tautomerism (`/15T`). options: More InchI options in a form of a list of string. Example: `[\"/SRel\", \"/AuxNone\"]`. \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchi_options = _process_inchi_options ( fixed_hydrogen_layer = fixed_hydrogen_layer , undefined_stereocenter = undefined_stereocenter , reconnected_metal_layer = reconnected_metal_layer , tautomerism_keto_enol = tautomerism_keto_enol , tautomerism_15 = tautomerism_15 , options = options , ) inchi_val = Chem . MolToInchi ( mol , options = inchi_options ) if not inchi_val : return None return inchi_val","title":"to_inchi_non_standard()"},{"location":"api/datamol.html#datamol.convert.to_inchikey","text":"Convert a mol to a standard InchiKey. Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule required Source code in datamol/convert.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def to_inchikey ( mol : Union [ str , Mol ]) -> Optional [ str ]: \"\"\"Convert a mol to a standard InchiKey. Args: mol: a molecule \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchikey = Chem . MolToInchiKey ( mol ) if not inchikey : return None return inchikey","title":"to_inchikey()"},{"location":"api/datamol.html#datamol.convert.to_inchikey_non_standard","text":"Convert a mol to a non-standard InchiKey. Note that turning all the flags to False will result in the standard InchiKey. Warning : this function will return a non-standard InchiKey. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChiKey. If you don't know much about non-standard InchiKey, we highly recommend you to use the standard InchiKey with dm.to_inchikey() . Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule required fixed_hydrogen_layer bool whether to include a fixed hydrogen layer ( /FixedH ). True undefined_stereocenter bool whether to include an undefined stereocenter layer ( /SUU ). True reconnected_metal_layer bool whether to include reconnected metals ( /RecMet ). True tautomerism_keto_enol bool whether to account tautomerism keto-enol ( /KET ). True tautomerism_15 bool whether to account 1,5-tautomerism ( /15T ). True options Optional [ List [ str ]] More InchI options in a form of a list of string. Example: [\"/SRel\", \"/AuxNone\"] . None Source code in datamol/convert.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def to_inchikey_non_standard ( mol : Union [ str , Mol ], fixed_hydrogen_layer : bool = True , undefined_stereocenter : bool = True , reconnected_metal_layer : bool = True , tautomerism_keto_enol : bool = True , tautomerism_15 : bool = True , options : Optional [ List [ str ]] = None , ) -> Optional [ str ]: \"\"\"Convert a mol to a non-standard InchiKey. Note that turning all the flags to `False` will result in the standard InchiKey. **Warning**: this function will return a **non-standard** InchiKey. See https://www.inchi-trust.org/technical-faq-2 for details. It's important to not mix standard and non-standard InChiKey. If you don't know much about non-standard InchiKey, we highly recommend you to use the standard InchiKey with `dm.to_inchikey()`. Args: mol: a molecule fixed_hydrogen_layer: whether to include a fixed hydrogen layer (`/FixedH`). undefined_stereocenter: whether to include an undefined stereocenter layer (`/SUU`). reconnected_metal_layer: whether to include reconnected metals (`/RecMet`). tautomerism_keto_enol: whether to account tautomerism keto-enol (`/KET`). tautomerism_15: whether to account 1,5-tautomerism (`/15T`). options: More InchI options in a form of a list of string. Example: `[\"/SRel\", \"/AuxNone\"]`. \"\"\" if isinstance ( mol , str ): mol = dm . to_mol ( mol ) if mol is None : return None inchi_options = _process_inchi_options ( fixed_hydrogen_layer = fixed_hydrogen_layer , undefined_stereocenter = undefined_stereocenter , reconnected_metal_layer = reconnected_metal_layer , tautomerism_keto_enol = tautomerism_keto_enol , tautomerism_15 = tautomerism_15 , options = options , ) inchikey = Chem . MolToInchiKey ( mol , options = inchi_options ) if not inchikey : return None return inchikey","title":"to_inchikey_non_standard()"},{"location":"api/datamol.html#datamol.convert.to_selfies","text":"Convert a mol to SELFIES. Parameters: Name Type Description Default mol Union [ str , Mol ] a molecule or a SMILES. required Returns: Name Type Description selfies Optional [ str ] SELFIES string. Source code in datamol/convert.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def to_selfies ( mol : Union [ str , Mol ]) -> Optional [ str ]: \"\"\"Convert a mol to SELFIES. Args: mol: a molecule or a SMILES. Returns: selfies: SELFIES string. \"\"\" if isinstance ( mol , Mol ): mol = to_smiles ( mol ) if mol is None : return None selfies = sf . encoder ( mol ) if selfies == - 1 : return None return selfies","title":"to_selfies()"},{"location":"api/datamol.html#datamol.convert.to_smarts","text":"Convert a mol to SMARTS format Parameters: Name Type Description Default mol Mol a molecule. required Source code in datamol/convert.py 243 244 245 246 247 248 249 250 251 252 253 def to_smarts ( mol : Mol ) -> Optional [ str ]: \"\"\"Convert a mol to SMARTS format Args: mol: a molecule. \"\"\" if mol is None : return None return Chem . MolToSmarts ( mol ) # type: ignore","title":"to_smarts()"},{"location":"api/datamol.html#datamol.convert.to_smiles","text":"Convert a mol to a SMILES. Parameters: Name Type Description Default mol Mol a molecule. required canonical bool if false no attempt will be made to canonicalize the molecule. True isomeric bool whether to include information about stereochemistry in the SMILES. True kekulize bool whether to return the kekule version of the SMILES. False ordered bool whether to force reordering of the atoms first. False explicit_bonds bool if true, all bond orders will be explicitly indicated in the output SMILES. False explicit_hs bool if true, all H counts will be explicitly indicated in the output SMILES. False randomize bool whether to randomize the generated smiles. Override canonical . False cxsmiles bool Whether to return a CXSMILES instead of a SMILES. False allow_to_fail bool Raise an error if the conversion to SMILES fails. Return None otherwise. False Source code in datamol/convert.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def to_smiles ( mol : Mol , canonical : bool = True , isomeric : bool = True , kekulize : bool = False , ordered : bool = False , explicit_bonds : bool = False , explicit_hs : bool = False , randomize : bool = False , cxsmiles : bool = False , allow_to_fail : bool = False , ) -> Optional [ str ]: \"\"\"Convert a mol to a SMILES. Args: mol: a molecule. canonical: if false no attempt will be made to canonicalize the molecule. isomeric: whether to include information about stereochemistry in the SMILES. kekulize: whether to return the kekule version of the SMILES. ordered: whether to force reordering of the atoms first. explicit_bonds: if true, all bond orders will be explicitly indicated in the output SMILES. explicit_hs: if true, all H counts will be explicitly indicated in the output SMILES. randomize: whether to randomize the generated smiles. Override `canonical`. cxsmiles: Whether to return a CXSMILES instead of a SMILES. allow_to_fail: Raise an error if the conversion to SMILES fails. Return None otherwise. \"\"\" if ordered and canonical is False : mol = dm . reorder_atoms ( mol ) if randomize : mol = dm . randomize_atoms ( mol ) canonical = False smiles = None try : if cxsmiles : smiles = rdmolfiles . MolToCXSmiles ( mol , isomericSmiles = isomeric , canonical = canonical , allBondsExplicit = explicit_bonds , allHsExplicit = explicit_hs , kekuleSmiles = kekulize , ) else : smiles = rdmolfiles . MolToSmiles ( mol , isomericSmiles = isomeric , canonical = canonical , allBondsExplicit = explicit_bonds , allHsExplicit = explicit_hs , kekuleSmiles = kekulize , ) except Exception as e : if allow_to_fail : raise e return None return smiles","title":"to_smiles()"},{"location":"api/datamol.html#module-cluster","text":"","title":"Module cluster"},{"location":"api/datamol.html#datamol.cluster","text":"","title":"cluster"},{"location":"api/datamol.html#datamol.cluster.assign_to_centroids","text":"Assign molecules to centroids. Each molecule will be assigned to the closest centroid. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules to assign to centroids required centroids List [ Mol ] list of molecules to use as centroid required feature_fn Optional [ Callable ] A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None dist_fn Optional [ Callable ] A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. None n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Returns: Name Type Description clusters_map dict dict of index mapping each centroid index to the molecule index in the cluster clusters_list list list of all molecules in each cluster. The cluster index follows the index of the centroid. Note that the centroid molecule is not added to the cluster. Source code in datamol/cluster.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def assign_to_centroids ( mols : List [ Mol ], centroids : List [ Mol ], feature_fn : Optional [ Callable ] = None , dist_fn : Optional [ Callable ] = None , n_jobs : Optional [ int ] = 1 , ) -> Tuple [ dict , list ]: r \"\"\"Assign molecules to centroids. Each molecule will be assigned to the closest centroid. Args: mols: a list of molecules to assign to centroids centroids: list of molecules to use as centroid feature_fn: A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. dist_fn: A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. Returns: clusters_map: dict of index mapping each centroid index to the molecule index in the cluster clusters_list: list of all molecules in each cluster. The cluster index follows the index of the centroid. Note that the centroid molecule is not added to the cluster. \"\"\" if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) all_mols = [ x for x in mols ] + [ c for c in centroids ] features = dm . parallelized ( feature_fn , all_mols , n_jobs = n_jobs ) def distij ( i , j , features = features ): return 1.0 - DataStructs . cDataStructs . TanimotoSimilarity ( features [ int ( i )], features [ int ( j )]) if dist_fn is None : dist_fn = distij clusters_map = ddict ( list ) clusters_list = [[] for _ in centroids ] query_inds = np . expand_dims ( np . arange ( len ( mols ), dtype = int ), axis = 1 ) centroid_inds = np . expand_dims ( np . arange ( len ( centroids ), dtype = int ), axis = 1 ) + len ( mols ) dist_mat = distance . cdist ( query_inds , centroid_inds , metric = distij ) closest = np . argmin ( dist_mat , axis = 1 ) for ind , cluster_ind in enumerate ( closest ): # type: ignore clusters_map [ cluster_ind ] . append ( ind ) clusters_list [ cluster_ind ] . append ( mols [ ind ]) return clusters_map , clusters_list","title":"assign_to_centroids()"},{"location":"api/datamol.html#datamol.cluster.cluster_mols","text":"Cluster a set of molecules using the butina clustering algorithm and a given threshold. Parameters: Name Type Description Default mols Union [ Sequence [ Mol ], pd . Series ] a list of molecules. required cutoff float Cuttoff for the clustering. Default to 0.2. 0.2 feature_fn Optional [ Callable ] A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Source code in datamol/cluster.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def cluster_mols ( mols : Union [ Sequence [ Mol ], pd . Series ], cutoff : float = 0.2 , feature_fn : Optional [ Callable ] = None , n_jobs : Optional [ int ] = 1 , ): \"\"\"Cluster a set of molecules using the butina clustering algorithm and a given threshold. Args: mols: a list of molecules. cutoff: Cuttoff for the clustering. Default to 0.2. feature_fn: A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. \"\"\" if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) features = dm . parallelized ( feature_fn , mols , n_jobs = n_jobs ) dists = [] n_mols = len ( mols ) for i in range ( 1 , n_mols ): dist = DataStructs . cDataStructs . BulkTanimotoSimilarity ( features [ i ], features [: i ], returnDistance = True ) dists . extend ([ x for x in dist ]) # now cluster the data cluster_indices = Butina . ClusterData ( dists , n_mols , cutoff , isDistData = True ) cluster_mols = [ operator . itemgetter ( * cluster )( mols ) for cluster in cluster_indices ] # Make single mol cluster a list cluster_mols = [[ c ] if isinstance ( c , Mol ) else c for c in cluster_mols ] return cluster_indices , cluster_mols","title":"cluster_mols()"},{"location":"api/datamol.html#datamol.cluster.pick_centroids","text":"Pick a set of npick centroids from a list of molecules. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules. required npick int Number of element to pick from mols, including the preselection. 0 threshold float Minimum distance between centroids for maxmin and sphere exclusion ( sphere ) methods. 0.5 initial_picks Optional [ List [ int ]] Starting list of index for molecules that should be in the set of picked molecules. Default to None. None feature_fn callable A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None dist_fn Optional [ Callable ] A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. None seed int seed for reproducibility 42 method str Picking method to use. One of sphere , maxmin or any supported rdkit hierarchical clustering method such as centroid , clink , upgma 'sphere' n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Returns: Name Type Description picked_inds int index of the molecule that have been selected as centroids mols list molecules that have been picked Source code in datamol/cluster.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def pick_centroids ( mols : List [ Mol ], npick : int = 0 , initial_picks : Optional [ List [ int ]] = None , threshold : float = 0.5 , feature_fn : Optional [ Callable ] = None , dist_fn : Optional [ Callable ] = None , seed : int = 42 , method : str = \"sphere\" , n_jobs : Optional [ int ] = 1 , ) -> Tuple [ int , list ]: r \"\"\"Pick a set of `npick` centroids from a list of molecules. Args: mols: a list of molecules. npick: Number of element to pick from mols, including the preselection. threshold: Minimum distance between centroids for `maxmin` and sphere exclusion (`sphere`) methods. initial_picks: Starting list of index for molecules that should be in the set of picked molecules. Default to None. feature_fn (callable, optional): A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. dist_fn: A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. seed: seed for reproducibility method: Picking method to use. One of `sphere`, `maxmin` or any supported rdkit hierarchical clustering method such as `centroid`, `clink`, `upgma` n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. Returns: picked_inds: index of the molecule that have been selected as centroids mols: molecules that have been picked \"\"\" n_mols = len ( mols ) if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) features = dm . parallelized ( feature_fn , mols , n_jobs = n_jobs ) def distij ( i , j , features = features ): return 1.0 - DataStructs . cDataStructs . TanimotoSimilarity ( features [ i ], features [ j ]) if dist_fn is None : dist_fn = distij initial_picks = [] if initial_picks is None else initial_picks if method == \"maxmin\" : picker = MaxMinPicker () picked_inds , _ = picker . LazyPickWithThreshold ( dist_fn , n_mols , pickSize = npick , threshold = threshold , firstPicks = initial_picks , seed = seed , ) elif method == \"sphere\" : picker = LeaderPicker () picked_inds = picker . LazyPick ( dist_fn , n_mols , threshold = threshold , pickSize = npick , firstPicks = initial_picks ) elif method . upper () in ClusterMethod . names . keys () and npick : if initial_picks : logger . warning ( \"Initial picks is not supported by hierarchical clustering. You pick has been discarded.\" ) dist_mat = dm . parallelized ( distij , list ( zip ( * np . tril_indices ( len ( mols ), k =- 1 ))), arg_type = \"args\" ) dist_mat = np . asarray ( dist_mat ) picker = HierarchicalClusterPicker ( ClusterMethod . names [ method . upper ()]) picked_inds = picker . Pick ( dist_mat , n_mols , npick ) else : raise ValueError ( f \"Picking method { method } with { npick } elements to pick is not supported.\" ) picked_inds = np . array ( picked_inds ) picked_mols = [ mols [ x ] for x in picked_inds ] return picked_inds , picked_mols","title":"pick_centroids()"},{"location":"api/datamol.html#datamol.cluster.pick_diverse","text":"Pick a set of diverse molecules based on they fingerprint. Parameters: Name Type Description Default mols List [ Mol ] a list of molecules. required npick int Number of element to pick from mols, including the preselection. required initial_picks Optional [ List [ int ]] Starting list of index for molecules that should be in the set of picked molecules. Default to None. None feature_fn Optional [ Callable ] A feature function that takes a Mol object and return molecular features. By default, the dm.to_fp() is used. Default to None. None dist_fn Optional [ Callable ] A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. None seed int seed for reproducibility 42 n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 Returns: Name Type Description picked_inds int index of the molecule that have been picked mols list molecules that have been picked Source code in datamol/cluster.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def pick_diverse ( mols : List [ Mol ], npick : int , initial_picks : Optional [ List [ int ]] = None , feature_fn : Optional [ Callable ] = None , dist_fn : Optional [ Callable ] = None , seed : int = 42 , n_jobs : Optional [ int ] = 1 , ) -> Tuple [ int , list ]: r \"\"\"Pick a set of diverse molecules based on they fingerprint. Args: mols: a list of molecules. npick: Number of element to pick from mols, including the preselection. initial_picks: Starting list of index for molecules that should be in the set of picked molecules. Default to None. feature_fn: A feature function that takes a Mol object and return molecular features. By default, the `dm.to_fp()` is used. Default to None. dist_fn: A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None. seed: seed for reproducibility n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. Returns: picked_inds: index of the molecule that have been picked mols: molecules that have been picked \"\"\" if feature_fn is None : feature_fn = functools . partial ( dm . to_fp , as_array = False ) features = dm . parallelized ( feature_fn , mols , n_jobs = n_jobs ) def distij ( i , j , features = features ): return 1.0 - DataStructs . cDataStructs . TanimotoSimilarity ( features [ i ], features [ j ]) if dist_fn is None : dist_fn = distij picker = MaxMinPicker () initial_picks = [] if initial_picks is None else initial_picks picked_inds = picker . LazyPick ( dist_fn , len ( mols ), npick , firstPicks = initial_picks , seed = seed ) picked_inds = np . array ( picked_inds ) picked_mols = [ mols [ x ] for x in picked_inds ] return picked_inds , picked_mols","title":"pick_diverse()"},{"location":"api/datamol.html#module-fp","text":"","title":"Module fp"},{"location":"api/datamol.html#datamol.fp","text":"","title":"fp"},{"location":"api/datamol.html#datamol.fp.fold_count_fp","text":"Fast folding of a count fingerprint to the specified dimension. Parameters: Name Type Description Default fp Union [ np . ndarray , SparseBitVect , ExplicitBitVect ] A fingerprint. required dim int The dimension of the folded array. 1024 binary bool Whether to fold into a binary array or take use a count vector. False Returns: Name Type Description folded np . ndarray returns folded array to the provided dimension. Source code in datamol/fp.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def fold_count_fp ( fp : Union [ np . ndarray , SparseBitVect , ExplicitBitVect ], dim : int = 1024 , binary : bool = False , ) -> np . ndarray : \"\"\"Fast folding of a count fingerprint to the specified dimension. Args: fp: A fingerprint. dim: The dimension of the folded array. binary: Whether to fold into a binary array or take use a count vector. Returns: folded: returns folded array to the provided dimension. \"\"\" if isinstance ( fp , ( UIntSparseIntVect , IntSparseIntVect , LongSparseIntVect , ULongSparseIntVect , ), ): tmp = fp . GetNonzeroElements () elif isinstance ( fp , SparseBitVect ): on_bits = fp . GetOnBits () tmp = dict ( zip ( on_bits , np . ones ( len ( on_bits )))) else : raise ValueError ( f \"The fingerprint is of wrong type: { type ( fp ) } \" ) # ON bits dict to (i, v) i = np . array ( list ( tmp . keys ())) % dim v = np . array ( list ( tmp . values ())) # Fold indices i = i % dim # Create the folded fp folded = np . zeros ( dim , dtype = \"int\" ) np . add . at ( folded , i , v ) if binary : folded = np . clip ( folded , a_min = 0 , a_max = 1 ) return folded","title":"fold_count_fp()"},{"location":"api/datamol.html#datamol.fp.fp_to_array","text":"Convert rdkit fingerprint to numpy array. Note This implementation has shown to be faster than using DataStructs.ConvertToNumpyArray by a factor of ~4. See https://github.com/rdkit/rdkit/discussions/3863 . Parameters: Name Type Description Default fp Union [ np . ndarray , SparseBitVect , ExplicitBitVect , UIntSparseIntVect ] The fingerprint. required Source code in datamol/fp.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def fp_to_array ( fp : Union [ np . ndarray , SparseBitVect , ExplicitBitVect , UIntSparseIntVect ] ) -> np . ndarray : \"\"\"Convert rdkit fingerprint to numpy array. Note: This implementation has shown to be faster than using `DataStructs.ConvertToNumpyArray` by a factor of ~4. See https://github.com/rdkit/rdkit/discussions/3863. Args: fp: The fingerprint. \"\"\" if isinstance ( fp , np . ndarray ): fp_out = fp elif isinstance ( fp , SparseBitVect ): tmp = np . zeros ( fp . GetNumBits (), dtype = int ) on_bits = np . array ( fp . GetOnBits ()) tmp [ on_bits ] = 1 fp_out = tmp elif isinstance ( fp , ExplicitBitVect ): fp_out = np . frombuffer ( fp . ToBitString () . encode (), \"u1\" ) - ord ( \"0\" ) elif isinstance ( fp , ( UIntSparseIntVect , IntSparseIntVect , LongSparseIntVect , ULongSparseIntVect , ), ): tmp = np . zeros ( fp . GetLength (), dtype = int ) bit_idx , values = np . array ( list ( fp . GetNonzeroElements () . items ())) . T tmp [ bit_idx ] = values fp_out = tmp else : raise ValueError ( f \"The fingerprint of type ' { type ( fp ) } ' is not supported. \" \"Please open a ticket at https://github.com/datamol-org/datamol/issues.\" ) return fp_out","title":"fp_to_array()"},{"location":"api/datamol.html#datamol.fp.list_supported_fingerprints","text":"Return the supported fingerprints in datamol. Source code in datamol/fp.py 294 295 296 297 def list_supported_fingerprints (): \"\"\"Return the supported fingerprints in datamol.\"\"\" return _FP_FUNCS","title":"list_supported_fingerprints()"},{"location":"api/datamol.html#datamol.fp.to_fp","text":"Compute the molecular fingerprint given a molecule or a SMILES. Parameters: Name Type Description Default mol Union [ str , Chem . rdchem . Mol ] a molecule or a SMILES. required as_array bool Whether to return a numpy array of an RDKit vec. Default to True. True fp_type str The type of the fingerprint. See dm.list_supported_fingerprints() for a complete list. 'ecfp' fold_size Optional [ int ] If set, fold the fingerprint to the fold_size . If set, returned array is always a numpy array. None **fp_args Any Arguments to build the fingerprint. Refer to the official RDKit documentation. {} Returns: Type Description Optional [ Union [ np . ndarray , SparseBitVect , ExplicitBitVect ]] A fingerprint vector or None Source code in datamol/fp.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def to_fp ( mol : Union [ str , Chem . rdchem . Mol ], as_array : bool = True , fp_type : str = \"ecfp\" , fold_size : Optional [ int ] = None , ** fp_args : Any , ) -> Optional [ Union [ np . ndarray , SparseBitVect , ExplicitBitVect ]]: \"\"\"Compute the molecular fingerprint given a molecule or a SMILES. Args: mol: a molecule or a SMILES. as_array: Whether to return a numpy array of an RDKit vec. Default to True. fp_type: The type of the fingerprint. See `dm.list_supported_fingerprints()` for a complete list. fold_size: If set, fold the fingerprint to the `fold_size`. If set, returned array is always a numpy array. **fp_args: Arguments to build the fingerprint. Refer to the official RDKit documentation. Returns: A fingerprint vector or None \"\"\" # Get fp function fp_func = _FP_FUNCS . get ( fp_type ) if fp_func is None : raise ValueError ( f \"The fingerprint ' { fp_type } ' is not available. Use `dm.list_supported_fingerprints()` to \" \"get a complete list of the available fingerprints.\" ) # Convert input to mol if needed if isinstance ( mol , str ): mol_obj = dm . to_mol ( mol ) else : mol_obj = mol if mol_obj is None : raise ValueError ( f \"It seems like the input molecule ' { mol } ' is invalid.\" ) mol = mol_obj # Insert default values. for key , value in _FP_DEFAULT_ARGS [ fp_type ] . items (): fp_args . setdefault ( key , value ) # Compute the fingerprint fp = fp_func ( mol , ** fp_args ) # Fold the fp if needed. if fold_size is not None : fp = fold_count_fp ( fp , dim = fold_size ) # Convert to a numpy array if not fold_size and as_array : fp = fp_to_array ( fp ) return fp","title":"to_fp()"},{"location":"api/datamol.html#module-similarity","text":"","title":"Module similarity"},{"location":"api/datamol.html#datamol.similarity","text":"","title":"similarity"},{"location":"api/datamol.html#datamol.similarity.cdist","text":"Compute the tanimoto distance between the fingerprints of each pair of molecules of the two collections of inputs. Parameters: Name Type Description Default mols1 List [ Union [ str , dm . Mol ]] list of molecules. required mols2 List [ Union [ str , dm . Mol ]] list of molecules. required n_jobs Optional [ int ] Number of jobs for fingerprint computation. Let to 1 for no parallelization. Set to None or -1 to use all available cores. 1 distances_chunk bool Whether to use chunked computation. False distances_chunk_memory int Memory size in MB to use for chunked computation. 1024 distances_n_jobs int Number of jobs for parallelization. -1 **fp_args Any list of args to pass to to_fp() . {} Returns: Type Description np . ndarray distmat Source code in datamol/similarity.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def cdist ( mols1 : List [ Union [ str , dm . Mol ]], mols2 : List [ Union [ str , dm . Mol ]], n_jobs : Optional [ int ] = 1 , distances_chunk : bool = False , distances_chunk_memory : int = 1024 , distances_n_jobs : int = - 1 , ** fp_args : Any , ) -> np . ndarray : \"\"\"Compute the tanimoto distance between the fingerprints of each pair of molecules of the two collections of inputs. Args: mols1: list of molecules. mols2: list of molecules. n_jobs: Number of jobs for fingerprint computation. Let to 1 for no parallelization. Set to None or -1 to use all available cores. distances_chunk: Whether to use chunked computation. distances_chunk_memory: Memory size in MB to use for chunked computation. distances_n_jobs: Number of jobs for parallelization. **fp_args: list of args to pass to `to_fp()`. Returns: distmat \"\"\" fps1 = dm . parallelized ( functools . partial ( dm . to_fp , as_array = True , ** fp_args ), mols1 , n_jobs = n_jobs , ) fps2 = dm . parallelized ( functools . partial ( dm . to_fp , as_array = True , ** fp_args ), mols2 , n_jobs = n_jobs , ) fps1 = np . array ( fps1 ) . astype ( bool ) fps2 = np . array ( fps2 ) . astype ( bool ) if distances_chunk : distances = pairwise_distances_chunked ( fps1 , fps2 , metric = \"jaccard\" , n_jobs = distances_n_jobs , working_memory = distances_chunk_memory , ) distances = [ i for i in distances ] distances = np . vstack ( distances ) else : distances = distance . cdist ( fps1 , fps2 , metric = \"jaccard\" ) return distances","title":"cdist()"},{"location":"api/datamol.html#datamol.similarity.pdist","text":"Compute the pairwise tanimoto distance between the fingerprints of all the molecules in the input set. Parameters: Name Type Description Default mols List [ Union [ str , dm . Mol ]] list of molecules required n_jobs Optional [ int ] Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. 1 squareform bool Whether to return in square form (matrix) or in a condensed form (1D vector). True **fp_args Any list of args to pass to to_fp() . {} Returns: Type Description np . ndarray dist_mat Source code in datamol/similarity.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def pdist ( mols : List [ Union [ str , dm . Mol ]], n_jobs : Optional [ int ] = 1 , squareform : bool = True , ** fp_args : Any , ) -> np . ndarray : \"\"\"Compute the pairwise tanimoto distance between the fingerprints of all the molecules in the input set. Args: mols: list of molecules n_jobs: Number of jobs for parallelization. Let to 1 for no parallelization. Set to None to use all available cores. squareform: Whether to return in square form (matrix) or in a condensed form (1D vector). **fp_args: list of args to pass to `to_fp()`. Returns: dist_mat \"\"\" fps = dm . parallelized ( functools . partial ( dm . to_fp , as_array = True , ** fp_args ), mols , n_jobs = n_jobs , ) fps = np . array ( fps ) dist_mat = distance . pdist ( fps , metric = \"jaccard\" ) if squareform : dist_mat = distance . squareform ( dist_mat , force = \"tomatrix\" ) return dist_mat","title":"pdist()"},{"location":"api/datamol.html#module-isomers","text":"","title":"Module isomers"},{"location":"api/datamol.html#datamol.isomers","text":"","title":"isomers"},{"location":"api/datamol.html#module-data","text":"","title":"Module data"},{"location":"api/datamol.html#datamol.data","text":"","title":"data"},{"location":"api/datamol.html#datamol.data.cdk2","text":"Return the RDKit CDK2 dataset from RDConfig.RDDocsDir, 'Book/data/cdk2.sdf' . Parameters: Name Type Description Default as_df bool Whether to return a list mol or a pandas DataFrame. True mol_column Optional [ str ] Name of the mol column. Only relevant if as_df is True. 'mol' Source code in datamol/data.py 30 31 32 33 34 35 36 37 38 39 40 def cdk2 ( as_df : bool = True , mol_column : Optional [ str ] = \"mol\" ): \"\"\"Return the RDKit CDK2 dataset from `RDConfig.RDDocsDir, 'Book/data/cdk2.sdf'`. Args: as_df: Whether to return a list mol or a pandas DataFrame. mol_column: Name of the mol column. Only relevant if `as_df` is True. \"\"\" with pkg_resources . resource_stream ( \"datamol\" , \"data/cdk2.sdf\" ) as f : data = read_sdf ( f , as_df = as_df , mol_column = mol_column ) return data","title":"cdk2()"},{"location":"api/datamol.html#datamol.data.freesolv","text":"Return the FreeSolv dataset as a dataframe. The dataset contains 642 molecules and the following columns: ['iupac', 'smiles', 'expt', 'calc'] . Warning This dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. It is not a dataset for benchmarking, analysis or model training. Source code in datamol/data.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def freesolv (): \"\"\"Return the FreeSolv dataset as a dataframe. The dataset contains 642 molecules and the following columns: `['iupac', 'smiles', 'expt', 'calc']`. Warning: This dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. **It is not** a dataset for benchmarking, analysis or model training. \"\"\" with pkg_resources . resource_stream ( \"datamol\" , \"data/freesolv.csv\" ) as f : data = pd . read_csv ( f ) return data","title":"freesolv()"},{"location":"api/datamol.html#datamol.data.solubility","text":"Return the RDKit solubility dataset from RDConfig.RDDocsDir, 'Book/data/solubility.{train|test}.sdf' . The dataframe or the list of molecules with contain a split column, either train or test . Parameters: Name Type Description Default as_df bool Whether to return a list mol or a pandas DataFrame. True mol_column Optional [ str ] Name of the mol column. Only relevant if as_df is True. 'mol' Source code in datamol/data.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def solubility ( as_df : bool = True , mol_column : Optional [ str ] = \"mol\" ): \"\"\"Return the RDKit solubility dataset from `RDConfig.RDDocsDir, 'Book/data/solubility.{train|test}.sdf'`. The dataframe or the list of molecules with contain a `split` column, either `train` or `test`. Args: as_df: Whether to return a list mol or a pandas DataFrame. mol_column: Name of the mol column. Only relevant if `as_df` is True. \"\"\" with pkg_resources . resource_stream ( \"datamol\" , \"data/solubility.train.sdf\" ) as f : train = read_sdf ( f , as_df = True , mol_column = \"mol\" , smiles_column = None ) with pkg_resources . resource_stream ( \"datamol\" , \"data/solubility.test.sdf\" ) as f : test = read_sdf ( f , as_df = True , mol_column = \"mol\" , smiles_column = None ) train = cast ( pd . DataFrame , train ) test = cast ( pd . DataFrame , test ) train [ \"split\" ] = \"train\" test [ \"split\" ] = \"test\" # NOTE(hadim): LMAO RDkit consistency xD test = test . rename ( columns = { \"SMILES\" : \"smiles\" }) data = pd . concat ([ train , test ], ignore_index = True ) if as_df : if mol_column is None : data = data . drop ( columns = [ \"mol\" ]) render_mol_df ( data ) return data return from_df ( data , mol_column = mol_column )","title":"solubility()"},{"location":"api/datamol.html#module-log","text":"","title":"Module log"},{"location":"api/datamol.html#datamol.log","text":"","title":"log"},{"location":"api/datamol.html#datamol.log.without_rdkit_log","text":"Context manager to disable RDKit logs. By default all logs are disabled. Example: import datamol as dm with dm . without_rdkit_log (): mol = dm . to_mol ( \"CCCCO\" ) # potential RDKit logs won't show Source code in datamol/log.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class without_rdkit_log : \"\"\"Context manager to disable RDKit logs. By default all logs are disabled. Example: ```python import datamol as dm with dm.without_rdkit_log(): mol = dm.to_mol(\"CCCCO\") # potential RDKit logs won't show ``` \"\"\" def __init__ ( self , mute_errors : bool = True , mute_warning : bool = True , mute_info : bool = True , mute_debug : bool = True , enable : bool = True , ): if enable is False : mute_errors = False mute_warning = False mute_info = False mute_debug = False # Get current log state self . previous_status = self . _get_log_status () # Init the desired log state to apply during in the context self . desired_status = {} self . desired_status [ \"rdApp.error\" ] = not mute_errors self . desired_status [ \"rdApp.warning\" ] = not mute_warning self . desired_status [ \"rdApp.debug\" ] = not mute_debug self . desired_status [ \"rdApp.info\" ] = not mute_info def _get_log_status ( self ): \"\"\"Get the current log status of RDKit logs.\"\"\" log_status = rdBase . LogStatus () log_status = { st . split ( \":\" )[ 0 ]: st . split ( \":\" )[ 1 ] for st in log_status . split ( \" \\n \" )} log_status = { k : True if v == \"enabled\" else False for k , v in log_status . items ()} return log_status def _apply_log_status ( self , log_status ): \"\"\"Apply an RDKit log status.\"\"\" for k , v in log_status . items (): if v is True : rdBase . EnableLog ( k ) else : rdBase . DisableLog ( k ) def __enter__ ( self ): self . _apply_log_status ( self . desired_status ) def __exit__ ( self , * args , ** kwargs ): self . _apply_log_status ( self . previous_status )","title":"without_rdkit_log"},{"location":"api/datamol.html#datamol.log.disable_rdkit_log","text":"Disable all rdkit logs. Source code in datamol/log.py 65 66 67 68 def disable_rdkit_log (): \"\"\"Disable all rdkit logs.\"\"\" for log_level in RDLogger . _levels : rdBase . DisableLog ( log_level )","title":"disable_rdkit_log()"},{"location":"api/datamol.html#datamol.log.enable_rdkit_log","text":"Enable all rdkit logs. Source code in datamol/log.py 71 72 73 74 def enable_rdkit_log (): \"\"\"Enable all rdkit logs.\"\"\" for log_level in RDLogger . _levels : rdBase . EnableLog ( log_level )","title":"enable_rdkit_log()"},{"location":"api/datamol.html#module-graph","text":"","title":"Module graph"},{"location":"api/datamol.html#datamol.graph","text":"","title":"graph"},{"location":"api/datamol.html#datamol.graph.get_all_path_between","text":"Get all simple path between two atoms of a molecule Parameters: Name Type Description Default mol dm . Mol a molecule required atom_idx_1 int Atom index 1. required atom_idx_2 int Atom index 2. required ignore_cycle_basis bool Whether to ignore cycle basis. Defaults to False. False Returns: Type Description list list of path between two atoms. Source code in datamol/graph.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_all_path_between ( mol : dm . Mol , atom_idx_1 : int , atom_idx_2 : int , ignore_cycle_basis : bool = False , ) -> list : \"\"\"Get all simple path between two atoms of a molecule Args: mol (dm.Mol): a molecule atom_idx_1 (int): Atom index 1. atom_idx_2 (int): Atom index 2. ignore_cycle_basis: Whether to ignore cycle basis. Defaults to False. Returns: list of path between two atoms. \"\"\" nx = _get_networkx () adj = GetAdjacencyMatrix ( mol ) G = nx . Graph ( adj ) path = nx . all_simple_paths ( G , source = atom_idx_1 , target = atom_idx_2 ) if ignore_cycle_basis : rings = [ set ( x ) for x in mol . GetRingInfo () . AtomRings ()] final_path = [] for p in path : reject_path = False for r in rings : if r . issubset ( set ( p )): reject_path = True break if not reject_path : final_path . append ( p ) path = final_path return list ( path )","title":"get_all_path_between()"},{"location":"api/datamol.html#datamol.graph.match_molecular_graphs","text":"Match the node indices of 2 molecular graphs, with optional usage of atomic number and edge type. Note The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. Note Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Parameters: Name Type Description Default mol1 dm . Mol A molecule. required mol2 dm . Mol A molecule. required match_atoms_on List [ str ] Properties on which to match the atom types. By default, it matches on the 'atomic_num' property. Empty list means that it does not consider atom features during matching. Other properties are defined by the datamol.graph.to_graph function and include: - atomic_num - formal_charge - chiral_tag - hybridization - num_explicit_hs - implicit_valence - degree - symbol - ring_atom - is_aromatic ['atomic_num'] match_bonds_on List [ str ] Properties on which to match the bond types. Empty list means that it does not consider bond features during matching. By default, it matches on the 'bond_type' property. No other properties are defined by the datamol.graph.to_graph function. ['bond_type'] Returns: Type Description List [ Dict [ int , int ]] A list of all matches dictionaries. In case of a single match, the list has len==1. List [ Dict [ int , int ]] Each dictionary contains as key the indices of mol1 and as value the corresponding List [ Dict [ int , int ]] indices of mol2 . Source code in datamol/graph.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def match_molecular_graphs ( mol1 : dm . Mol , mol2 : dm . Mol , match_atoms_on : List [ str ] = [ \"atomic_num\" ], match_bonds_on : List [ str ] = [ \"bond_type\" ], ) -> List [ Dict [ int , int ]]: \"\"\" Match the node indices of 2 molecular graphs, with optional usage of atomic number and edge type. Note: The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. Note: Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Args: mol1: A molecule. mol2: A molecule. match_atoms_on: Properties on which to match the atom types. By default, it matches on the `'atomic_num'` property. Empty list means that it does not consider atom features during matching. Other properties are defined by the `datamol.graph.to_graph` function and include: - atomic_num - formal_charge - chiral_tag - hybridization - num_explicit_hs - implicit_valence - degree - symbol - ring_atom - is_aromatic match_bonds_on: Properties on which to match the bond types. Empty list means that it does not consider bond features during matching. By default, it matches on the `'bond_type'` property. No other properties are defined by the `datamol.graph.to_graph` function. Returns: A list of all matches dictionaries. In case of a single match, the list has len==1. Each dictionary contains as key the indices of `mol1` and as value the corresponding indices of `mol2`. \"\"\" nx = _get_networkx () if isinstance ( match_atoms_on , str ): match_atoms_on = [ match_atoms_on ] if isinstance ( match_bonds_on , str ): match_bonds_on = [ match_bonds_on ] def node_match_fn ( node1 , node2 ): \"\"\"Function that matches the atomic number\"\"\" return all ([ node1 [ prop ] == node2 [ prop ] for prop in match_atoms_on ]) def edge_match_fn ( edge1 , edge2 ): \"\"\"Function that matches the bond type\"\"\" return all ([ edge1 [ prop ] == edge2 [ prop ] for prop in match_bonds_on ]) # Convert to networkx graph g1 = to_graph ( mol1 ) g2 = to_graph ( mol2 ) # Use the `match` function to find the matching indices node_match = node_match_fn if len ( match_atoms_on ) > 0 else None edge_match = edge_match_fn if len ( match_bonds_on ) > 0 else None graph_matcher = nx . algorithms . isomorphism . vf2userfunc . GraphMatcher ( g1 , g2 , node_match = node_match , edge_match = edge_match ) matches = list ( graph_matcher . match ()) return matches","title":"match_molecular_graphs()"},{"location":"api/datamol.html#datamol.graph.reorder_mol_from_template","text":"Re-order the nodes of a molecular graph from the nodes of a template molecule. Molecular graphs and atom types need to be identical, but edge types and charges are not enforced. This is particularily useful when dealing with XYZ files containing node ordering, but with missing information regarding charges and edge types. Note If you only need to match bond orders, you can check the function rdkit.Chem.AllChem.AssignBondOrdersFromTemplate . The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Parameters: Name Type Description Default mol dm . Mol The molecule to re-order required mol_template dm . Mol The molecule containing the right node order. required enforce_atomic_num bool Whether to enforce atomic number. Atomic numbers are always enforced for a first try. If no match are found and this parameter is False , the matching is tried again. False enforce_bond_type bool Whether to enforce bond types. Bond types are always enforced for a first try. If no match are found and this parameter is False , the matching is tried again. False ambiguous_match_mode str Whether to allow ambiguous matching. This means that, if there are many matches to the molecule, it will still re-order the molecule according to specific rules. Options are: - \"no\": Does not allow ambiguous matching. - \"hs-only\": Allow matching of ambiguous hydrogens. Does not work if trying to match implicit with explicit hydrogens. - \"first\": Return the first match. - \"best\": Return the match with the least errors on atom type, edges type, and edge stereo. Errors on the atoms are counted with 1 point, on the charge with 0.25 points, on the edges with 0.25 points, and on the Stereo with 0.05 points. If the option enforce_atomic_num is used, then no errors on the atoms are allowed. If the option enforce_bond_type is used, then no errors on the edges are allowed. - \"best-first\": \"best\", followed by \"first\". 'No' verbose bool Whether to warn when the matching does not work or is ambiguous. Different warnings are raised depending on the value of ambiguous_match_mode . True Returns: Type Description Optional [ dm . Mol ] None if the molecular graphs do not match (both the graph and atom types). Pring a warning. Optional [ dm . Mol ] None if multiple matche are found, which can happen for symmetric molecules such as benzene Pring a warning. Optional [ dm . Mol ] Mol The re-ordered molecule when a single match is found. Source code in datamol/graph.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def reorder_mol_from_template ( mol : dm . Mol , mol_template : dm . Mol , enforce_atomic_num : bool = False , enforce_bond_type : bool = False , ambiguous_match_mode : str = \"No\" , verbose : bool = True , ) -> Optional [ dm . Mol ]: \"\"\" Re-order the nodes of a molecular graph from the nodes of a template molecule. Molecular graphs and atom types need to be identical, but edge types and charges are not enforced. This is particularily useful when dealing with XYZ files containing node ordering, but with missing information regarding charges and edge types. !!! note * If you only need to match bond orders, you can check the function `rdkit.Chem.AllChem.AssignBondOrdersFromTemplate`. * The matching fails if the hydrogens are implicit in one molecule, but explicit in the other. * Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way. Args: mol: The molecule to re-order mol_template: The molecule containing the right node order. enforce_atomic_num: Whether to enforce atomic number. Atomic numbers are always enforced for a first try. If no match are found and this parameter is `False`, the matching is tried again. enforce_bond_type: Whether to enforce bond types. Bond types are always enforced for a first try. If no match are found and this parameter is `False`, the matching is tried again. ambiguous_match_mode: Whether to allow ambiguous matching. This means that, if there are many matches to the molecule, it will still re-order the molecule according to specific rules. Options are: - \"no\": Does not allow ambiguous matching. - \"hs-only\": Allow matching of ambiguous hydrogens. Does not work if trying to match implicit with explicit hydrogens. - \"first\": Return the first match. - \"best\": Return the match with the least errors on atom type, edges type, and edge stereo. Errors on the atoms are counted with 1 point, on the charge with 0.25 points, on the edges with 0.25 points, and on the Stereo with 0.05 points. If the option `enforce_atomic_num` is used, then no errors on the atoms are allowed. If the option `enforce_bond_type` is used, then no errors on the edges are allowed. - \"best-first\": \"best\", followed by \"first\". verbose: Whether to warn when the matching does not work or is ambiguous. Different warnings are raised depending on the value of `ambiguous_match_mode`. Returns: - `None` if the molecular graphs do not match (both the graph and atom types). Pring a warning. - `None` if multiple matche are found, which can happen for symmetric molecules such as benzene Pring a warning. - `Mol` The re-ordered molecule when a single match is found. \"\"\" ambiguous_match_mode = ambiguous_match_mode . lower () # Match the ordering of the graphs matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [ \"atomic_num\" ], match_bonds_on = [ \"bond_type\" ], ) # If no matches were found, retry without bond types if ( len ( matches ) == 0 ) and ( not enforce_bond_type ): matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [ \"atomic_num\" ], match_bonds_on = [], ) # If no matches were found, retry without atom types if ( len ( matches ) == 0 ) and ( not enforce_atomic_num ): matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [], match_bonds_on = [ \"bond_type\" ], ) # If no matches were found, retry without bond and atom types if ( len ( matches ) == 0 ) and ( not enforce_bond_type ) and ( not enforce_atomic_num ): matches = match_molecular_graphs ( mol_template , mol , match_atoms_on = [], match_bonds_on = []) # If no match were found, exit the function and return None if len ( matches ) == 0 : if verbose : logger . warning ( \"No match was found\" ) return None if len ( matches ) > 1 : # In case we want to allow ambiguous match of hydrogens if ambiguous_match_mode == \"hs-only\" : first_keys = list ( matches [ 0 ] . keys ()) all_hs_mismatch = True for this_match in matches : this_keys = list ( this_match . keys ()) keys_mismatch = [ ii for ii in range ( len ( this_keys )) if ( first_keys [ ii ] != this_keys [ ii ]) ] atoms_mismatch = [ mol . GetAtomWithIdx ( key ) . GetAtomicNum () for key in keys_mismatch ] all_hs = all ([ atom == 1 for atom in atoms_mismatch ]) if not all_hs : all_hs_mismatch = False break if all_hs_mismatch : matches = matches [ 0 : 1 ] else : if verbose : logger . warning ( f \" { len ( matches ) } matches were found, ordering is ambiguous, even when ignoring hydrogens\" ) return None # Compute the number of atoms and bonds mismatch, and select the one with the least mismatch if ( ambiguous_match_mode in [ \"best\" , \"best-first\" ]) and not ( enforce_atomic_num and enforce_bond_type ): num_mismatches = [] for this_match in matches : num_atoms_mismatch , num_charge_mismatch = 0 , 0 # Get the number of atomic mismatch for key , val in this_match . items (): atom1 = mol . GetAtomWithIdx ( val ) atom2 = mol_template . GetAtomWithIdx ( key ) num_atoms_mismatch += atom1 . GetAtomicNum () != atom2 . GetAtomicNum () num_charge_mismatch += atom1 . GetFormalCharge () != atom2 . GetFormalCharge () # Get the number of bond mismatch num_bonds_type_mismatch , num_bonds_stereo_mismatch = 0 , 0 for bond1 in mol_template . GetBonds (): begin_idx , end_idx = bond1 . GetBeginAtomIdx (), bond1 . GetEndAtomIdx () bond2 = mol . GetBondBetweenAtoms ( this_match [ begin_idx ], this_match [ end_idx ]) num_bonds_type_mismatch += bond1 . GetBondType () != bond2 . GetBondType () num_bonds_stereo_mismatch += ( bond1 . GetStereo () != bond2 . GetStereo ()) or ( bond1 . GetBondDir () != bond2 . GetBondDir () ) num_mismatches . append ( ( 1 * num_atoms_mismatch ) + ( 0.25 * num_charge_mismatch ) + ( 0.25 * num_bonds_type_mismatch ) + ( 0.05 * num_bonds_stereo_mismatch ) ) min_mismatch_idx = [ ii for ii in range ( len ( num_mismatches )) if num_mismatches [ ii ] == min ( num_mismatches ) ] matches = [ matches [ idx ] for idx in min_mismatch_idx ] # Select the first matching element if ambiguous_match_mode in [ \"first\" , \"best-first\" ]: matches = [ matches [ 0 ]] if len ( matches ) > 1 : # If many matches were found, exit the function and return None if ambiguous_match_mode == \"no\" : if verbose : logger . warning ( f \" { len ( matches ) } matches were found, ordering is ambiguous\" ) return None # Re-order the molecule from the matching indices of the template match = matches [ 0 ] match = [ match [ ii ] for ii in range ( mol . GetNumAtoms ())] reordered_mol = RenumberAtoms ( mol , match ) return reordered_mol","title":"reorder_mol_from_template()"},{"location":"api/datamol.html#datamol.graph.to_graph","text":"Convert a molecule to a network x graph. A list of properties are added to every nodes and edges. Parameters: Name Type Description Default mol dm . Mol a molecule. required Returns: Name Type Description mol_graph networkx . Graph a graph representing the molecule. Source code in datamol/graph.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def to_graph ( mol : dm . Mol ): \"\"\"Convert a molecule to a network x graph. A list of properties are added to every nodes and edges. Args: mol (dm.Mol): a molecule. Returns: mol_graph (networkx.Graph): a graph representing the molecule. \"\"\" nx = _get_networkx () mol_graph = nx . Graph () for atom in mol . GetAtoms (): mol_graph . add_node ( atom . GetIdx (), atomic_num = atom . GetAtomicNum (), formal_charge = atom . GetFormalCharge (), chiral_tag = atom . GetChiralTag (), hybridization = atom . GetHybridization (), num_explicit_hs = atom . GetNumExplicitHs (), implicit_valence = atom . GetImplicitValence (), degree = atom . GetDegree (), symbol = atom . GetSymbol (), ring_atom = atom . IsInRing (), is_aromatic = atom . GetIsAromatic (), ) for bond in mol . GetBonds (): mol_graph . add_edge ( bond . GetBeginAtomIdx (), bond . GetEndAtomIdx (), bond_type = bond . GetBondType (), ) return mol_graph","title":"to_graph()"},{"location":"api/datamol.molar.html","text":"datamol.molar \u00b6 molar \u00b6 A set of utility functions to convert between various units and formats used in drug discovery. log_to_molar ( values , unit ) \u00b6 Convert a log-scaled molar concentration (pXC50 for example) to its unscaled value (XC50). Parameters: Name Type Description Default values Union [ float , Iterable [ float ], np . ndarray ] A log-scaled molar concentration (can be a scalar, a list or an array). required unit str The unit of the input concentration. Choose from: {'M', 'fM', 'mM', 'nM', 'pM', 'uM'} . required Source code in datamol/molar.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def log_to_molar ( values : Union [ float , Iterable [ float ], np . ndarray ], unit : str , ) -> Union [ float , Iterable [ float ], np . ndarray ]: \"\"\"Convert a log-scaled molar concentration (pXC50 for example) to its unscaled value (XC50). Args: values: A log-scaled molar concentration (can be a scalar, a list or an array). unit: The unit of the input concentration. Choose from: `{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}`. \"\"\" if unit not in _MOLAR_SCALES : raise ValueError ( f \"The unit ' { unit } ' is not supported. Choose from { set ( _MOLAR_SCALES . keys ()) } .\" ) return 10 ** ( - 1 * np . array ( values , dtype = \"float\" )) / _MOLAR_SCALES [ unit ] molar_to_log ( values , unit ) \u00b6 Convert a molar concentration (XC50 for example) to its log scaled value (pXC50). Parameters: Name Type Description Default values Union [ float , Iterable [ float ], np . ndarray ] A molar concentration (can be a scalar, a list or an array). required unit str The unit of the input concentration. Choose from: {'M', 'fM', 'mM', 'nM', 'pM', 'uM'} . required Source code in datamol/molar.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def molar_to_log ( values : Union [ float , Iterable [ float ], np . ndarray ], unit : str , ) -> Union [ float , Iterable [ float ], np . ndarray ]: \"\"\"Convert a molar concentration (XC50 for example) to its log scaled value (pXC50). Args: values: A molar concentration (can be a scalar, a list or an array). unit: The unit of the input concentration. Choose from: `{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}`. \"\"\" if unit not in _MOLAR_SCALES : raise ValueError ( f \"The unit ' { unit } ' is not supported. Choose from { set ( _MOLAR_SCALES . keys ()) } .\" ) return - 1 * np . log10 ( np . array ( values ) * _MOLAR_SCALES [ unit ])","title":"datamol.molar"},{"location":"api/datamol.molar.html#datamolmolar","text":"","title":"datamol.molar"},{"location":"api/datamol.molar.html#datamol.molar","text":"A set of utility functions to convert between various units and formats used in drug discovery.","title":"molar"},{"location":"api/datamol.molar.html#datamol.molar.log_to_molar","text":"Convert a log-scaled molar concentration (pXC50 for example) to its unscaled value (XC50). Parameters: Name Type Description Default values Union [ float , Iterable [ float ], np . ndarray ] A log-scaled molar concentration (can be a scalar, a list or an array). required unit str The unit of the input concentration. Choose from: {'M', 'fM', 'mM', 'nM', 'pM', 'uM'} . required Source code in datamol/molar.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def log_to_molar ( values : Union [ float , Iterable [ float ], np . ndarray ], unit : str , ) -> Union [ float , Iterable [ float ], np . ndarray ]: \"\"\"Convert a log-scaled molar concentration (pXC50 for example) to its unscaled value (XC50). Args: values: A log-scaled molar concentration (can be a scalar, a list or an array). unit: The unit of the input concentration. Choose from: `{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}`. \"\"\" if unit not in _MOLAR_SCALES : raise ValueError ( f \"The unit ' { unit } ' is not supported. Choose from { set ( _MOLAR_SCALES . keys ()) } .\" ) return 10 ** ( - 1 * np . array ( values , dtype = \"float\" )) / _MOLAR_SCALES [ unit ]","title":"log_to_molar()"},{"location":"api/datamol.molar.html#datamol.molar.molar_to_log","text":"Convert a molar concentration (XC50 for example) to its log scaled value (pXC50). Parameters: Name Type Description Default values Union [ float , Iterable [ float ], np . ndarray ] A molar concentration (can be a scalar, a list or an array). required unit str The unit of the input concentration. Choose from: {'M', 'fM', 'mM', 'nM', 'pM', 'uM'} . required Source code in datamol/molar.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def molar_to_log ( values : Union [ float , Iterable [ float ], np . ndarray ], unit : str , ) -> Union [ float , Iterable [ float ], np . ndarray ]: \"\"\"Convert a molar concentration (XC50 for example) to its log scaled value (pXC50). Args: values: A molar concentration (can be a scalar, a list or an array). unit: The unit of the input concentration. Choose from: `{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}`. \"\"\" if unit not in _MOLAR_SCALES : raise ValueError ( f \"The unit ' { unit } ' is not supported. Choose from { set ( _MOLAR_SCALES . keys ()) } .\" ) return - 1 * np . log10 ( np . array ( values ) * _MOLAR_SCALES [ unit ])","title":"molar_to_log()"},{"location":"api/datamol.scaffold.html","text":"datamol.scaffold \u00b6 _fuzzy \u00b6 fuzzy_scaffolding ( mols , enforce_subs = None , n_atom_cuttoff = 8 , additional_templates = None , ignore_non_ring = False , mcs_params = None ) \u00b6 Generate fuzzy scaffold with enforceable group that needs to appear in the core, forcing to keep the full side chain if required Parameters: Name Type Description Default mols List [ Chem . rdchem . Mol ] List of all molecules required enforce_subs Optional [ List [ str ]] List of substructure to enforce on the scaffold. None n_atom_cuttoff int Minimum number of atom a core should have. 8 additional_templates Optional [ List [ Mol ]] Additional template to use to generate scaffolds. None ignore_non_ring bool Whether to ignore atom no in murcko ring system, even if they are in the framework. False mcs_params Optional [ Dict [ Any , Any ]] Arguments of MCS algorithm. None Returns: Type Description set set - scaffolds - All found scaffolds in the molecules as valid smiles. Dict [ str , dict ] Dict[Dict] - scaffold_infos - Infos on the scaffold mapping, ignoring any side chain that had to be enforced. Key corresponds to generic scaffold smiles Values at ['smarts'] corresponds to smarts representation of the true scaffold (from MCS) Values at ['mols'] corresponds to list of molecules matching the scaffold Dict [ str , list ] Dict[List] - scaffold_to_group - Map between each generic scaffold and the R-groups decomposition row. Source code in datamol/scaffold/_fuzzy.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def fuzzy_scaffolding ( mols : List [ Chem . rdchem . Mol ], enforce_subs : Optional [ List [ str ]] = None , n_atom_cuttoff : int = 8 , additional_templates : Optional [ List [ Mol ]] = None , ignore_non_ring : bool = False , mcs_params : Optional [ Dict [ Any , Any ]] = None , ) -> Tuple [ set , Dict [ str , dict ], Dict [ str , list ]]: \"\"\"Generate fuzzy scaffold with enforceable group that needs to appear in the core, forcing to keep the full side chain if required Args: mols: List of all molecules enforce_subs: List of substructure to enforce on the scaffold. n_atom_cuttoff: Minimum number of atom a core should have. additional_templates: Additional template to use to generate scaffolds. ignore_non_ring: Whether to ignore atom no in murcko ring system, even if they are in the framework. mcs_params: Arguments of MCS algorithm. Returns: - `set` - `scaffolds` - All found scaffolds in the molecules as valid smiles. - `Dict[Dict]` - `scaffold_infos` - Infos on the scaffold mapping, ignoring any side chain that had to be enforced. Key corresponds to generic scaffold smiles Values at ['smarts'] corresponds to smarts representation of the true scaffold (from MCS) Values at ['mols'] corresponds to list of molecules matching the scaffold - `Dict[List]` - `scaffold_to_group` - Map between each generic scaffold and the R-groups decomposition row. \"\"\" # NOTE(hadim): consider parallelize this (if possible). # NOTE(hadim): consider refactoring this function in smaller reusable functions. if enforce_subs is None : enforce_subs = [] if additional_templates is None : additional_templates = [] if mcs_params is None : mcs_params = {} rg_params = rdRGroupDecomposition . RGroupDecompositionParameters () rg_params . removeAllHydrogenRGroups = True rg_params . removeHydrogensPostMatch = True rg_params . alignment = rdRGroupDecomposition . RGroupCoreAlignment . MCS rg_params . matchingStrategy = rdRGroupDecomposition . RGroupMatching . Exhaustive rg_params . rgroupLabelling = rdRGroupDecomposition . RGroupLabelling . AtomMap rg_params . labels = rdRGroupDecomposition . RGroupLabels . AtomIndexLabels core_query_param = AdjustQueryParameters () core_query_param . makeDummiesQueries = True core_query_param . adjustDegree = False core_query_param . makeBondsGeneric = True # group molecules by they generic Murcko scaffold, allowing # side chain that contains cycle (might be a bad idea) scf2infos = collections . defaultdict ( dict ) scf2groups = {} all_scaffolds = set ([]) for m in mols : generic_m = MurckoScaffold . MakeScaffoldGeneric ( m ) scf = MurckoScaffold . GetScaffoldForMol ( m ) try : scf = MurckoScaffold . MakeScaffoldGeneric ( scf ) except : pass if ignore_non_ring : rw_scf = Chem . RWMol ( scf ) atms = [ a . GetIdx () for a in rw_scf . GetAtoms () if not a . IsInRing ()] atms . sort ( reverse = True ) for a in atms : rw_scf . RemoveAtom ( a ) scfs = list ( rdmolops . GetMolFrags ( rw_scf , asMols = False )) else : scfs = [ to_smiles ( scf )] # add templates mols if exists: for tmp in additional_templates : tmp = to_mol ( tmp ) tmp_scf = MurckoScaffold . MakeScaffoldGeneric ( tmp ) if generic_m . HasSubstructMatch ( tmp_scf ): scfs . append ( to_smiles ( tmp_scf )) for scf in scfs : if scf2infos [ scf ] . get ( \"mols\" ): scf2infos [ scf ][ \"mols\" ] . append ( m ) else : scf2infos [ scf ][ \"mols\" ] = [ m ] for scf in scf2infos : # cheat by adding murcko as last mol always popout = False mols = scf2infos [ scf ][ \"mols\" ] if len ( mols ) < 2 : mols = mols + [ MurckoScaffold . GetScaffoldForMol ( mols [ 0 ])] popout = True # compute the MCS of the cluster mcs = rdFMCS . FindMCS ( mols , atomCompare = rdFMCS . AtomCompare . CompareAny , bondCompare = rdFMCS . BondCompare . CompareAny , completeRingsOnly = True , ** mcs_params , ) mcsM = from_smarts ( mcs . smartsString ) mcsM . UpdatePropertyCache ( False ) Chem . SetHybridization ( mcsM ) if mcsM . GetNumAtoms () < n_atom_cuttoff : continue scf2infos [ scf ][ \"smarts\" ] = to_smarts ( mcsM ) if popout : mols = mols [: - 1 ] core_groups = [] # generate rgroups based on the mcs core success_mols = [] try : rg = rdRGroupDecomposition . RGroupDecomposition ( mcsM , rg_params ) for i , analog in enumerate ( mols ): analog . RemoveAllConformers () res = rg . Add ( analog ) if not ( res < 0 ): success_mols . append ( i ) rg . Process () core_groups = rg . GetRGroupsAsRows () except Exception : pass mols = [ mols [ i ] for i in success_mols ] scf2groups [ scf ] = core_groups for mol , gp in zip ( mols , core_groups ): core = gp [ \"Core\" ] acceptable_groups = [ a . GetAtomMapNum () for a in core . GetAtoms () if ( a . GetAtomMapNum () and not a . IsInRing ()) ] rgroups = [ gp [ f \"R { k } \" ] for k in acceptable_groups if f \"R { k } \" in gp . keys ()] if enforce_subs is not None : rgroups = [ rgp for rgp in rgroups if not any ([ len ( rgp . GetSubstructMatch ( frag )) > 0 for frag in enforce_subs ]) ] try : scaff = trim_side_chain ( mol , AdjustQueryProperties ( core , core_query_param ), rgroups ) except : continue all_scaffolds . add ( to_smiles ( scaff )) return all_scaffolds , scf2infos , scf2groups trim_side_chain ( mol , core , unwanted_side_chains ) \u00b6 Trim list of side chain from a molecule. Source code in datamol/scaffold/_fuzzy.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def trim_side_chain ( mol : Chem . rdchem . Mol , core , unwanted_side_chains ): \"\"\"Trim list of side chain from a molecule.\"\"\" mol = add_hs ( mol ) match = mol . GetSubstructMatch ( core ) map2idx = {} map2nei = {} unwanted2map = {} for patt in unwanted_side_chains : unwanted2map [ patt ] = [ a . GetAtomMapNum () for a in patt . GetAtoms () if a . GetAtomMapNum ()] unwanted_mapping = list ( itertools . chain . from_iterable ( unwanted2map . values ())) for atom in core . GetAtoms (): num = atom . GetAtomMapNum () if num and num in unwanted_mapping : mol_atom_idx = match [ atom . GetIdx ()] map2idx [ mol_atom_idx ] = num nei_atoms = mol . GetAtomWithIdx ( mol_atom_idx ) . GetNeighbors () map2nei [ mol_atom_idx ] = [ n . GetIdx () for n in nei_atoms if n . GetIdx () in match ] emol = Chem . EditableMol ( mol ) for atom_idx , atom_map in map2idx . items (): dummy = Chem . rdchem . Atom ( \"*\" ) dummy . SetAtomMapNum ( atom_map ) nei_idx = map2nei . get ( atom_idx , [ None ])[ 0 ] if nei_idx : bond = mol . GetBondBetweenAtoms ( atom_idx , nei_idx ) emol . RemoveBond ( atom_idx , nei_idx ) new_ind = emol . AddAtom ( dummy ) emol . AddBond ( nei_idx , new_ind , bond . GetBondType ()) mol = emol . GetMol () mol = remove_hs ( mol ) query_param = AdjustQueryParameters () query_param . makeDummiesQueries = False query_param . adjustDegree = False query_param . aromatizeIfPossible = True for patt , _ in unwanted2map . items (): cur_frag = fix_mol ( patt ) mol = Chem . DeleteSubstructs ( mol , cur_frag , onlyFrags = True ) return keep_largest_fragment ( mol )","title":"datamol.scaffold"},{"location":"api/datamol.scaffold.html#datamolscaffold","text":"","title":"datamol.scaffold"},{"location":"api/datamol.scaffold.html#datamol.scaffold._fuzzy","text":"","title":"_fuzzy"},{"location":"api/datamol.scaffold.html#datamol.scaffold._fuzzy.fuzzy_scaffolding","text":"Generate fuzzy scaffold with enforceable group that needs to appear in the core, forcing to keep the full side chain if required Parameters: Name Type Description Default mols List [ Chem . rdchem . Mol ] List of all molecules required enforce_subs Optional [ List [ str ]] List of substructure to enforce on the scaffold. None n_atom_cuttoff int Minimum number of atom a core should have. 8 additional_templates Optional [ List [ Mol ]] Additional template to use to generate scaffolds. None ignore_non_ring bool Whether to ignore atom no in murcko ring system, even if they are in the framework. False mcs_params Optional [ Dict [ Any , Any ]] Arguments of MCS algorithm. None Returns: Type Description set set - scaffolds - All found scaffolds in the molecules as valid smiles. Dict [ str , dict ] Dict[Dict] - scaffold_infos - Infos on the scaffold mapping, ignoring any side chain that had to be enforced. Key corresponds to generic scaffold smiles Values at ['smarts'] corresponds to smarts representation of the true scaffold (from MCS) Values at ['mols'] corresponds to list of molecules matching the scaffold Dict [ str , list ] Dict[List] - scaffold_to_group - Map between each generic scaffold and the R-groups decomposition row. Source code in datamol/scaffold/_fuzzy.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def fuzzy_scaffolding ( mols : List [ Chem . rdchem . Mol ], enforce_subs : Optional [ List [ str ]] = None , n_atom_cuttoff : int = 8 , additional_templates : Optional [ List [ Mol ]] = None , ignore_non_ring : bool = False , mcs_params : Optional [ Dict [ Any , Any ]] = None , ) -> Tuple [ set , Dict [ str , dict ], Dict [ str , list ]]: \"\"\"Generate fuzzy scaffold with enforceable group that needs to appear in the core, forcing to keep the full side chain if required Args: mols: List of all molecules enforce_subs: List of substructure to enforce on the scaffold. n_atom_cuttoff: Minimum number of atom a core should have. additional_templates: Additional template to use to generate scaffolds. ignore_non_ring: Whether to ignore atom no in murcko ring system, even if they are in the framework. mcs_params: Arguments of MCS algorithm. Returns: - `set` - `scaffolds` - All found scaffolds in the molecules as valid smiles. - `Dict[Dict]` - `scaffold_infos` - Infos on the scaffold mapping, ignoring any side chain that had to be enforced. Key corresponds to generic scaffold smiles Values at ['smarts'] corresponds to smarts representation of the true scaffold (from MCS) Values at ['mols'] corresponds to list of molecules matching the scaffold - `Dict[List]` - `scaffold_to_group` - Map between each generic scaffold and the R-groups decomposition row. \"\"\" # NOTE(hadim): consider parallelize this (if possible). # NOTE(hadim): consider refactoring this function in smaller reusable functions. if enforce_subs is None : enforce_subs = [] if additional_templates is None : additional_templates = [] if mcs_params is None : mcs_params = {} rg_params = rdRGroupDecomposition . RGroupDecompositionParameters () rg_params . removeAllHydrogenRGroups = True rg_params . removeHydrogensPostMatch = True rg_params . alignment = rdRGroupDecomposition . RGroupCoreAlignment . MCS rg_params . matchingStrategy = rdRGroupDecomposition . RGroupMatching . Exhaustive rg_params . rgroupLabelling = rdRGroupDecomposition . RGroupLabelling . AtomMap rg_params . labels = rdRGroupDecomposition . RGroupLabels . AtomIndexLabels core_query_param = AdjustQueryParameters () core_query_param . makeDummiesQueries = True core_query_param . adjustDegree = False core_query_param . makeBondsGeneric = True # group molecules by they generic Murcko scaffold, allowing # side chain that contains cycle (might be a bad idea) scf2infos = collections . defaultdict ( dict ) scf2groups = {} all_scaffolds = set ([]) for m in mols : generic_m = MurckoScaffold . MakeScaffoldGeneric ( m ) scf = MurckoScaffold . GetScaffoldForMol ( m ) try : scf = MurckoScaffold . MakeScaffoldGeneric ( scf ) except : pass if ignore_non_ring : rw_scf = Chem . RWMol ( scf ) atms = [ a . GetIdx () for a in rw_scf . GetAtoms () if not a . IsInRing ()] atms . sort ( reverse = True ) for a in atms : rw_scf . RemoveAtom ( a ) scfs = list ( rdmolops . GetMolFrags ( rw_scf , asMols = False )) else : scfs = [ to_smiles ( scf )] # add templates mols if exists: for tmp in additional_templates : tmp = to_mol ( tmp ) tmp_scf = MurckoScaffold . MakeScaffoldGeneric ( tmp ) if generic_m . HasSubstructMatch ( tmp_scf ): scfs . append ( to_smiles ( tmp_scf )) for scf in scfs : if scf2infos [ scf ] . get ( \"mols\" ): scf2infos [ scf ][ \"mols\" ] . append ( m ) else : scf2infos [ scf ][ \"mols\" ] = [ m ] for scf in scf2infos : # cheat by adding murcko as last mol always popout = False mols = scf2infos [ scf ][ \"mols\" ] if len ( mols ) < 2 : mols = mols + [ MurckoScaffold . GetScaffoldForMol ( mols [ 0 ])] popout = True # compute the MCS of the cluster mcs = rdFMCS . FindMCS ( mols , atomCompare = rdFMCS . AtomCompare . CompareAny , bondCompare = rdFMCS . BondCompare . CompareAny , completeRingsOnly = True , ** mcs_params , ) mcsM = from_smarts ( mcs . smartsString ) mcsM . UpdatePropertyCache ( False ) Chem . SetHybridization ( mcsM ) if mcsM . GetNumAtoms () < n_atom_cuttoff : continue scf2infos [ scf ][ \"smarts\" ] = to_smarts ( mcsM ) if popout : mols = mols [: - 1 ] core_groups = [] # generate rgroups based on the mcs core success_mols = [] try : rg = rdRGroupDecomposition . RGroupDecomposition ( mcsM , rg_params ) for i , analog in enumerate ( mols ): analog . RemoveAllConformers () res = rg . Add ( analog ) if not ( res < 0 ): success_mols . append ( i ) rg . Process () core_groups = rg . GetRGroupsAsRows () except Exception : pass mols = [ mols [ i ] for i in success_mols ] scf2groups [ scf ] = core_groups for mol , gp in zip ( mols , core_groups ): core = gp [ \"Core\" ] acceptable_groups = [ a . GetAtomMapNum () for a in core . GetAtoms () if ( a . GetAtomMapNum () and not a . IsInRing ()) ] rgroups = [ gp [ f \"R { k } \" ] for k in acceptable_groups if f \"R { k } \" in gp . keys ()] if enforce_subs is not None : rgroups = [ rgp for rgp in rgroups if not any ([ len ( rgp . GetSubstructMatch ( frag )) > 0 for frag in enforce_subs ]) ] try : scaff = trim_side_chain ( mol , AdjustQueryProperties ( core , core_query_param ), rgroups ) except : continue all_scaffolds . add ( to_smiles ( scaff )) return all_scaffolds , scf2infos , scf2groups","title":"fuzzy_scaffolding()"},{"location":"api/datamol.scaffold.html#datamol.scaffold._fuzzy.trim_side_chain","text":"Trim list of side chain from a molecule. Source code in datamol/scaffold/_fuzzy.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def trim_side_chain ( mol : Chem . rdchem . Mol , core , unwanted_side_chains ): \"\"\"Trim list of side chain from a molecule.\"\"\" mol = add_hs ( mol ) match = mol . GetSubstructMatch ( core ) map2idx = {} map2nei = {} unwanted2map = {} for patt in unwanted_side_chains : unwanted2map [ patt ] = [ a . GetAtomMapNum () for a in patt . GetAtoms () if a . GetAtomMapNum ()] unwanted_mapping = list ( itertools . chain . from_iterable ( unwanted2map . values ())) for atom in core . GetAtoms (): num = atom . GetAtomMapNum () if num and num in unwanted_mapping : mol_atom_idx = match [ atom . GetIdx ()] map2idx [ mol_atom_idx ] = num nei_atoms = mol . GetAtomWithIdx ( mol_atom_idx ) . GetNeighbors () map2nei [ mol_atom_idx ] = [ n . GetIdx () for n in nei_atoms if n . GetIdx () in match ] emol = Chem . EditableMol ( mol ) for atom_idx , atom_map in map2idx . items (): dummy = Chem . rdchem . Atom ( \"*\" ) dummy . SetAtomMapNum ( atom_map ) nei_idx = map2nei . get ( atom_idx , [ None ])[ 0 ] if nei_idx : bond = mol . GetBondBetweenAtoms ( atom_idx , nei_idx ) emol . RemoveBond ( atom_idx , nei_idx ) new_ind = emol . AddAtom ( dummy ) emol . AddBond ( nei_idx , new_ind , bond . GetBondType ()) mol = emol . GetMol () mol = remove_hs ( mol ) query_param = AdjustQueryParameters () query_param . makeDummiesQueries = False query_param . adjustDegree = False query_param . aromatizeIfPossible = True for patt , _ in unwanted2map . items (): cur_frag = fix_mol ( patt ) mol = Chem . DeleteSubstructs ( mol , cur_frag , onlyFrags = True ) return keep_largest_fragment ( mol )","title":"trim_side_chain()"},{"location":"api/datamol.utils.html","text":"datamol.utils \u00b6 decorators \u00b6 disable_on_os ( os_names ) \u00b6 A decorator to disable a function raising an error if the OS detected is not supported. Parameters: Name Type Description Default os_names Union [ str , List [ str ]] OS names to disable this function. Valid OS names are: [\"linux\", \"osx\", \"win\"] . required Source code in datamol/utils/decorators.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def disable_on_os ( os_names : Union [ str , List [ str ]]): \"\"\"A decorator to disable a function raising an error if the OS detected is not supported. Args: os_names: OS names to disable this function. Valid OS names are: `[\"linux\", \"osx\", \"win\"]`. \"\"\" if isinstance ( os_names , str ): os_names = [ os_names ] valid_os_names = [] for os_name in os_names : if os_name == \"linux\" : valid_os_names . append ( \"Linux\" ) elif os_name == \"win\" : valid_os_names . append ( \"Windows\" ) elif os_name == \"osx\" : valid_os_names . append ( \"Darwin\" ) else : valid_os_names . append ( os_name ) def real_decorator ( function : Callable ): @wraps ( function ) def wrapper ( * args , ** kwargs ): if platform . system () not in valid_os_names : retval = function ( * args , ** kwargs ) return retval else : raise NotImplementedError ( f \"The function { function . __name__ } is not supported\" f \" for the platform ' { platform . system () } '.\" ) return wrapper return real_decorator fs \u00b6 The fs module makes it easier to work with all type of path (the ones supported by fsspec ). copy_dir ( source , destination , force = False , progress = False , leave_progress = True , file_progress = False , file_leave_progress = False , chunk_size = None ) \u00b6 Copy one directory to another location across different filesystem (local, S3, GCS, etc). Parameters: Name Type Description Default source Union [ str , pathlib . Path ] Path to the source directory. required destination Union [ str , pathlib . Path ] Path to the destination directory. required chunk_size Optional [ int ] the chunk size to use. If progress is enabled the chunk size is None , it is set to 2048. None force bool whether to overwrite the destination directory if it exists. False progress bool Whether to display a progress bar. False leave_progress bool Whether to hide the progress bar once the copy is done. True file_progress bool Whether to display a progress bar for each file. False file_leave_progress bool Whether to hide the progress bar once a file copy is done. False chunk_size Optional [ int ] See dm.utils.fs.copy_file . None Source code in datamol/utils/fs.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def copy_dir ( source : Union [ str , pathlib . Path ], destination : Union [ str , pathlib . Path ], force : bool = False , progress : bool = False , leave_progress : bool = True , file_progress : bool = False , file_leave_progress : bool = False , chunk_size : Optional [ int ] = None , ): \"\"\"Copy one directory to another location across different filesystem (local, S3, GCS, etc). Args: source: Path to the source directory. destination: Path to the destination directory. chunk_size: the chunk size to use. If progress is enabled the chunk size is `None`, it is set to 2048. force: whether to overwrite the destination directory if it exists. progress: Whether to display a progress bar. leave_progress: Whether to hide the progress bar once the copy is done. file_progress: Whether to display a progress bar for each file. file_leave_progress: Whether to hide the progress bar once a file copy is done. chunk_size: See `dm.utils.fs.copy_file`. \"\"\" source = str ( source ) destination = str ( destination ) source_fs = get_mapper ( source ) . fs destination_fs = get_mapper ( destination ) . fs # Sanity check if not is_dir ( source ): raise ValueError ( f \"The directory being copied does not exist or is not a directory: { source } \" ) if not force and is_dir ( destination ): raise ValueError ( f \"The destination folder to copy already exists: { destination } \" ) # Get all input paths with details # NOTE(hadim): we could have use `.glob(..., detail=True)` here but that API is inconsistent # between the backends resulting in different object types being returned (dict, list, etc). detailed_paths = source_fs . find ( source , withdirs = True , detail = True ) detailed_paths = list ( detailed_paths . values ()) # Get list of input types input_types = [ d [ \"type\" ] for d in detailed_paths ] # Get list of input path + add protocol if needed input_paths = [ d [ \"name\" ] for d in detailed_paths ] input_paths = [ fsspec . utils . _unstrip_protocol ( p , source_fs ) for p in input_paths ] # Build all the output paths output_paths : List [ str ] = fsspec . utils . other_paths ( input_paths , destination ) # type: ignore def _copy_source_to_destination ( input_path , input_type , output_path ): # A directory if input_type == \"directory\" : destination_fs . mkdir ( output_path ) # A file else : copy_file ( input_path , output_path , force = force , progress = file_progress , leave_progress = file_leave_progress , chunk_size = chunk_size , ) # Copy source files/directories to destination in parallel parallelized ( _copy_source_to_destination , inputs_list = list ( zip ( input_paths , input_types , output_paths )), arg_type = \"args\" , progress = progress , tqdm_kwargs = dict ( leave = leave_progress ), scheduler = \"threads\" , ) copy_file ( source , destination , chunk_size = None , force = False , progress = False , leave_progress = True ) \u00b6 Copy one file to another location across different filesystem (local, S3, GCS, etc). Parameters: Name Type Description Default source Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ] path or file-like object to copy from. required destination Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ] path or file-like object to copy to. required chunk_size Optional [ int ] the chunk size to use. If progress is enabled the chunk size is None , it is set to 1MB (1024 * 1024). None force bool whether to overwrite the destination file if it exists. False progress bool whether to display a progress bar. False leave_progress bool whether to hide the progress bar once the copy is done. True Source code in datamol/utils/fs.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def copy_file ( source : Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ], destination : Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ], chunk_size : Optional [ int ] = None , force : bool = False , progress : bool = False , leave_progress : bool = True , ): \"\"\"Copy one file to another location across different filesystem (local, S3, GCS, etc). Args: source: path or file-like object to copy from. destination: path or file-like object to copy to. chunk_size: the chunk size to use. If progress is enabled the chunk size is `None`, it is set to 1MB (1024 * 1024). force: whether to overwrite the destination file if it exists. progress: whether to display a progress bar. leave_progress: whether to hide the progress bar once the copy is done. \"\"\" if progress and chunk_size is None : chunk_size = 1024 * 1024 if isinstance ( source , ( str , pathlib . Path )): source_file = fsspec . open ( str ( source ), \"rb\" ) else : source_file = source if isinstance ( destination , ( str , pathlib . Path )): # adapt the file mode of the destination depending on the source file. destination_mode = \"wb\" if hasattr ( source_file , \"mode\" ): destination_mode = \"wb\" if \"b\" in getattr ( source_file , \"mode\" ) else \"w\" elif isinstance ( source_file , io . BytesIO ): destination_mode = \"wb\" elif isinstance ( source_file , io . StringIO ): destination_mode = \"w\" destination_file = fsspec . open ( str ( destination ), destination_mode ) else : destination_file = destination if not is_file ( source_file ): # type: ignore raise ValueError ( f \"The file being copied does not exist or is not a file: { source } \" ) if not force and is_file ( destination_file ): # type: ignore raise ValueError ( f \"The destination file to copy already exists: { destination } \" ) with source_file as source_stream : with destination_file as destination_stream : if chunk_size is None : # copy without chunks destination_stream . write ( source_stream . read ()) # type: ignore else : # copy with chunks # determine the size of the source file source_size = None if progress : source_size = get_size ( source ) pbar = None if progress : tqdm = _import_tqdm () if tqdm is None : raise ImportError ( \"If the progress bar is enabled, you must have `tqdm` \" \"installed: `conda install tqdm`.\" ) else : # init progress bar pbar = tqdm ( total = source_size , leave = leave_progress , disable = not progress , unit = \"B\" , unit_divisor = 1024 , unit_scale = True , ) # start the loop while True : data = source_stream . read ( chunk_size ) # type: ignore if not data : break destination_stream . write ( data ) # type: ignore if pbar is not None : pbar . update ( chunk_size ) if pbar is not None : pbar . close () exists ( path ) \u00b6 Check whether a file or a directory exists. Important: File-like object always exists. Parameters: Name Type Description Default path Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 96 97 98 99 100 101 102 103 104 def exists ( path : Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ]): \"\"\"Check whether a file or a directory exists. Important: File-like object always exists. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" return is_file ( path ) or is_dir ( path ) get_basename ( path ) \u00b6 Get the basename of a file or a folder. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 74 75 76 77 78 79 80 81 82 83 def get_basename ( path : Union [ str , os . PathLike ]): \"\"\"Get the basename of a file or a folder. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" path = str ( path ) mapper = get_mapper ( path ) clean_path = path . rstrip ( mapper . fs . sep ) return str ( clean_path ) . split ( mapper . fs . sep )[ - 1 ] get_cache_dir ( app_name , suffix = None , create = True ) \u00b6 Get a local cache directory for a given application name. Parameters: Name Type Description Default app_name str The name of the application. required suffix Optional [ str ] A subdirectory appended to the cache dir. None create bool Whether to create the directory and its parents if it does not already exist. True Source code in datamol/utils/fs.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def get_cache_dir ( app_name : str , suffix : Optional [ str ] = None , create : bool = True ): \"\"\"Get a local cache directory for a given application name. Args: app_name: The name of the application. suffix: A subdirectory appended to the cache dir. create: Whether to create the directory and its parents if it does not already exist. \"\"\" appdirs = _import_appdirs () if appdirs is None : raise ImportError ( \"To use `dm.utils.fs.get_cache_dir()`, you must have `appdirs` \" \"installed: `conda install appdirs`.\" ) cache_dir = pathlib . Path ( appdirs . user_cache_dir ( appname = app_name )) if suffix is not None : cache_dir /= suffix if create : cache_dir . mkdir ( exist_ok = True , parents = True ) return cache_dir get_extension ( path ) \u00b6 Get the extension of a file. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 86 87 88 89 90 91 92 93 def get_extension ( path : Union [ str , os . PathLike ]): \"\"\"Get the extension of a file. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" basename = get_basename ( path ) return basename . split ( \".\" )[ - 1 ] get_mapper ( path ) \u00b6 Get the fsspec mapper. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 65 66 67 68 69 70 71 def get_mapper ( path : Union [ str , os . PathLike ]): \"\"\"Get the fsspec mapper. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" return fsspec . get_mapper ( str ( path )) get_protocol ( path , fs = None ) \u00b6 Return the name of the path protocol. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def get_protocol ( path : Union [ str , os . PathLike ], fs : Optional [ fsspec . AbstractFileSystem ] = None ): \"\"\"Return the name of the path protocol. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" if fs is None : fs = get_mapper ( path ) . fs protocol = fs . protocol # type: ignore if \"s3\" in protocol : return \"s3\" elif \"gs\" in protocol : return \"gs\" elif isinstance ( protocol , ( tuple , list )): return protocol [ 0 ] return protocol get_size ( file ) \u00b6 Get the size of a file given its path. Return None if the size can't be retrieved. Source code in datamol/utils/fs.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def get_size ( file : Union [ str , os . PathLike , io . IOBase , fsspec . core . OpenFile ]) -> Optional [ int ]: \"\"\"Get the size of a file given its path. Return None if the size can't be retrieved. \"\"\" if isinstance ( file , io . IOBase ) and hasattr ( file , \"name\" ): fs_local = fsspec . filesystem ( \"file\" ) file_size = fs_local . size ( getattr ( file , \"name\" )) elif isinstance ( file , ( str , pathlib . Path )): fs = get_mapper ( str ( file )) . fs file_size = fs . size ( str ( file )) elif isinstance ( file , fsspec . core . OpenFile ): file_size = file . fs . size ( file . path ) else : file_size = None return file_size glob ( path , detail = False , ** kwargs ) \u00b6 Find files by glob-matching. Parameters: Name Type Description Default path str A glob-style path. required Source code in datamol/utils/fs.py 330 331 332 333 334 335 336 337 338 339 340 def glob ( path : str , detail : bool = False , ** kwargs ) -> List [ str ]: \"\"\"Find files by glob-matching. Args: path: A glob-style path. \"\"\" # Get the list of paths fs = get_mapper ( path ) . fs paths = fs . glob ( path , detail = detail , ** kwargs ) paths = [ fsspec . utils . _unstrip_protocol ( d , fs ) for d in paths ] return paths is_dir ( path ) \u00b6 Check whether a file exists. Important: File-like object always exists. Parameters: Name Type Description Default path Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def is_dir ( path : Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ]): \"\"\"Check whether a file exists. Important: File-like object always exists. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" if isinstance ( path , fsspec . core . OpenFile ): return path . fs . isdir ( path . path ) elif isinstance ( path , ( str , pathlib . Path )): mapper = get_mapper ( str ( path )) return mapper . fs . isdir ( path ) else : return False is_file ( path ) \u00b6 Check whether a file exists. Important: File-like object always exists. Parameters: Name Type Description Default path Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def is_file ( path : Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ]): \"\"\"Check whether a file exists. Important: File-like object always exists. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" if isinstance ( path , fsspec . core . OpenFile ): return path . fs . isfile ( path . path ) elif isinstance ( path , ( str , pathlib . Path )): mapper = get_mapper ( str ( path )) return mapper . fs . isfile ( path ) else : return True is_local_path ( path ) \u00b6 Check whether a path is local. Source code in datamol/utils/fs.py 166 167 168 def is_local_path ( path : Union [ str , os . PathLike ]): \"\"\"Check whether a path is local.\"\"\" return get_protocol ( str ( path )) == \"file\" join ( * paths ) \u00b6 Join paths together. The first element determine the filesystem to use (and so the separator. Parameters: Name Type Description Default *paths str a list of paths supported by fsspec such as local, s3, gcs, etc. () Source code in datamol/utils/fs.py 171 172 173 174 175 176 177 178 179 180 181 182 def join ( * paths : str ): \"\"\"Join paths together. The first element determine the filesystem to use (and so the separator. Args: *paths: a list of paths supported by `fsspec` such as local, s3, gcs, etc. \"\"\" paths = [ str ( path ) . rstrip ( \"/\" ) for path in paths ] source_path = paths [ 0 ] fs = get_mapper ( source_path ) . fs full_path = fs . sep . join ( paths ) return full_path md5 ( filepath ) \u00b6 Return the md5 hash of a file. Parameters: Name Type Description Default filepath Union [ str , os . PathLike ] The path to the file to compute the MD5 hash on. required Source code in datamol/utils/fs.py 317 318 319 320 321 322 323 324 325 326 327 def md5 ( filepath : Union [ str , os . PathLike ]): \"\"\"Return the md5 hash of a file. Args: filepath: The path to the file to compute the MD5 hash on. \"\"\" with fsspec . open ( filepath ) as f : file_hash = hashlib . md5 () file_hash . update ( f . read ()) # type: ignore file_hash = file_hash . hexdigest () return file_hash mkdir ( dir_path , exist_ok = False ) \u00b6 Create a directory. Parameters: Name Type Description Default dir_path Union [ str , os . PathLike ] The path of the directory to create. required exist_ok bool Whether to ignore the error if the directory already exists. False Source code in datamol/utils/fs.py 305 306 307 308 309 310 311 312 313 314 def mkdir ( dir_path : Union [ str , os . PathLike ], exist_ok : bool = False ): \"\"\"Create a directory. Args: dir_path: The path of the directory to create. exist_ok: Whether to ignore the error if the directory already exists. \"\"\" fs = get_mapper ( str ( dir_path )) . fs fs . mkdirs ( str ( dir_path ), exist_ok = exist_ok ) jobs \u00b6 JobRunner \u00b6 Source code in datamol/utils/jobs.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class JobRunner : def __init__ ( self , n_jobs : Optional [ int ] = - 1 , batch_size : Union [ int , str ] = \"auto\" , prefer : Optional [ str ] = None , progress : bool = False , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , ** job_kwargs : Any , ): \"\"\" JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which allows taking advantage of its features, while the progress bar use tqdm Args: n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation batch_size: Whether to batch `inputs_list`. You can specify batch_size when the length of `inputs_list` is very large (>100k elements). By default, the auto batching of joblib is used. prefer: Choose from ['processes', 'threads'] or None. Default to None. Soft hint to choose the default backend if no specific backend was selected with the parallel_backend context manager. The default process-based backend is 'loky' and the default thread-based backend is 'threading'. Ignored if the ``backend`` parameter is specified. progress: whether to display progress bar total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Example: ```python import datamol as dm runner = dm.JobRunner(n_jobs=4, progress=True, prefer=\"threads\") results = runner(lambda x: x**2, [1, 2, 3, 4]) ``` \"\"\" self . n_jobs = n_jobs self . batch_size = batch_size self . prefer = prefer self . job_kwargs = job_kwargs self . job_kwargs . update ( n_jobs = self . n_jobs , prefer = self . prefer , batch_size = self . batch_size ) self . no_progress = not progress self . total = total self . tqdm_kwargs = tqdm_kwargs or {} @property def is_sequential ( self ): \"\"\"Check whether the job is sequential or parallel\"\"\" return ( self . n_jobs is None ) or ( self . n_jobs in [ 0 , 1 ]) @staticmethod def wrap_fn ( fn : Callable , arg_type : Optional [ str ] = None , ** fn_kwargs ): \"\"\"Small wrapper around a callable to properly format it's argument\"\"\" def _run ( args : Any ): if arg_type == \"kwargs\" : fn_kwargs . update ( ** args ) return fn ( ** fn_kwargs ) elif arg_type == \"args\" : return fn ( * args , ** fn_kwargs ) return fn ( args , ** fn_kwargs ) return _run def sequential ( self , callable_fn : Callable , data : Iterable [ Any ], arg_type : Optional [ str ] = None , ** fn_kwargs , ): \"\"\" Run job in sequential version Args: callable_fn (callable): function to call data (iterable): input data arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs') **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton \"\"\" total_length = JobRunner . get_iterator_length ( data ) if self . total is not None : self . tqdm_kwargs [ \"total\" ] = self . total elif \"total\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"total\" ] = total_length if \"disable\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"disable\" ] = self . no_progress results = [ JobRunner . wrap_fn ( callable_fn , arg_type , ** fn_kwargs )( dt ) for dt in tqdm ( data , ** self . tqdm_kwargs ) ] return results def parallel ( self , callable_fn : Callable , data : Iterable [ Any ], arg_type : Optional [ str ] = None , ** fn_kwargs , ): \"\"\" Run job in parallel Args: callable_fn (callable): function to call data (iterable): input data arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs') **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton \"\"\" total_length = JobRunner . get_iterator_length ( data ) if self . total is not None : self . tqdm_kwargs [ \"total\" ] = self . total elif \"total\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"total\" ] = total_length if \"disable\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"disable\" ] = self . no_progress runner = JobRunner . _parallel_helper ( ** self . job_kwargs ) results = runner ( ** self . tqdm_kwargs )( delayed ( JobRunner . wrap_fn ( callable_fn , arg_type , ** fn_kwargs ))( dt ) for dt in data ) return results def __call__ ( self , * args , ** kwargs ): \"\"\" Run job using the n_jobs attribute to determine regime \"\"\" if self . is_sequential : return self . sequential ( * args , ** kwargs ) return self . parallel ( * args , ** kwargs ) @staticmethod def _parallel_helper ( ** joblib_args ): r \"\"\" Parallel helper function for joblib with tqdm support \"\"\" def run ( ** tq_args ): def tmp ( op_iter ): with _tqdm_callback ( tqdm ( ** tq_args )): return Parallel ( ** joblib_args )( op_iter ) return tmp return run @staticmethod def get_iterator_length ( data ): \"\"\"Attempt to get the length of an iterator\"\"\" total_length = None try : total_length = len ( data ) except TypeError : # most likely a generator, ignore pass return total_length __call__ ( * args , ** kwargs ) \u00b6 Run job using the n_jobs attribute to determine regime Source code in datamol/utils/jobs.py 153 154 155 156 157 158 159 def __call__ ( self , * args , ** kwargs ): \"\"\" Run job using the n_jobs attribute to determine regime \"\"\" if self . is_sequential : return self . sequential ( * args , ** kwargs ) return self . parallel ( * args , ** kwargs ) __init__ ( n_jobs =- 1 , batch_size = 'auto' , prefer = None , progress = False , total = None , tqdm_kwargs = None , ** job_kwargs ) \u00b6 JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which allows taking advantage of its features, while the progress bar use tqdm Parameters: Name Type Description Default n_jobs Optional [ int ] Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation -1 batch_size Union [ int , str ] Whether to batch inputs_list . You can specify batch_size when the length of inputs_list is very large (>100k elements). By default, the auto batching of joblib is used. 'auto' prefer Optional [ str ] Choose from ['processes', 'threads'] or None. Default to None. Soft hint to choose the default backend if no specific backend was selected with the parallel_backend context manager. The default process-based backend is 'loky' and the default thread-based backend is 'threading'. Ignored if the backend parameter is specified. None progress bool whether to display progress bar False total Optional [ int ] The number of elements in the iterator. Only used when progress is True. None tqdm_kwargs Optional [ dict ] Any additional arguments supported by the tqdm progress bar. None **job_kwargs Any Any additional arguments supported by joblib.Parallel . {} Example: import datamol as dm runner = dm . JobRunner ( n_jobs = 4 , progress = True , prefer = \"threads\" ) results = runner ( lambda x : x ** 2 , [ 1 , 2 , 3 , 4 ]) Source code in datamol/utils/jobs.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , n_jobs : Optional [ int ] = - 1 , batch_size : Union [ int , str ] = \"auto\" , prefer : Optional [ str ] = None , progress : bool = False , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , ** job_kwargs : Any , ): \"\"\" JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which allows taking advantage of its features, while the progress bar use tqdm Args: n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation batch_size: Whether to batch `inputs_list`. You can specify batch_size when the length of `inputs_list` is very large (>100k elements). By default, the auto batching of joblib is used. prefer: Choose from ['processes', 'threads'] or None. Default to None. Soft hint to choose the default backend if no specific backend was selected with the parallel_backend context manager. The default process-based backend is 'loky' and the default thread-based backend is 'threading'. Ignored if the ``backend`` parameter is specified. progress: whether to display progress bar total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Example: ```python import datamol as dm runner = dm.JobRunner(n_jobs=4, progress=True, prefer=\"threads\") results = runner(lambda x: x**2, [1, 2, 3, 4]) ``` \"\"\" self . n_jobs = n_jobs self . batch_size = batch_size self . prefer = prefer self . job_kwargs = job_kwargs self . job_kwargs . update ( n_jobs = self . n_jobs , prefer = self . prefer , batch_size = self . batch_size ) self . no_progress = not progress self . total = total self . tqdm_kwargs = tqdm_kwargs or {} get_iterator_length ( data ) staticmethod \u00b6 Attempt to get the length of an iterator Source code in datamol/utils/jobs.py 176 177 178 179 180 181 182 183 184 185 @staticmethod def get_iterator_length ( data ): \"\"\"Attempt to get the length of an iterator\"\"\" total_length = None try : total_length = len ( data ) except TypeError : # most likely a generator, ignore pass return total_length is_sequential () property \u00b6 Check whether the job is sequential or parallel Source code in datamol/utils/jobs.py 68 69 70 71 @property def is_sequential ( self ): \"\"\"Check whether the job is sequential or parallel\"\"\" return ( self . n_jobs is None ) or ( self . n_jobs in [ 0 , 1 ]) parallel ( callable_fn , data , arg_type = None , ** fn_kwargs ) \u00b6 Run job in parallel Parameters: Name Type Description Default callable_fn callable function to call required data iterable input data required arg_type str function argument type ('arg'/None or 'args' or 'kwargs') None **fn_kwargs dict optional keyword argument to pass to the callable funciton {} Source code in datamol/utils/jobs.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def parallel ( self , callable_fn : Callable , data : Iterable [ Any ], arg_type : Optional [ str ] = None , ** fn_kwargs , ): \"\"\" Run job in parallel Args: callable_fn (callable): function to call data (iterable): input data arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs') **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton \"\"\" total_length = JobRunner . get_iterator_length ( data ) if self . total is not None : self . tqdm_kwargs [ \"total\" ] = self . total elif \"total\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"total\" ] = total_length if \"disable\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"disable\" ] = self . no_progress runner = JobRunner . _parallel_helper ( ** self . job_kwargs ) results = runner ( ** self . tqdm_kwargs )( delayed ( JobRunner . wrap_fn ( callable_fn , arg_type , ** fn_kwargs ))( dt ) for dt in data ) return results sequential ( callable_fn , data , arg_type = None , ** fn_kwargs ) \u00b6 Run job in sequential version Parameters: Name Type Description Default callable_fn callable function to call required data iterable input data required arg_type str function argument type ('arg'/None or 'args' or 'kwargs') None **fn_kwargs dict optional keyword argument to pass to the callable funciton {} Source code in datamol/utils/jobs.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def sequential ( self , callable_fn : Callable , data : Iterable [ Any ], arg_type : Optional [ str ] = None , ** fn_kwargs , ): \"\"\" Run job in sequential version Args: callable_fn (callable): function to call data (iterable): input data arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs') **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton \"\"\" total_length = JobRunner . get_iterator_length ( data ) if self . total is not None : self . tqdm_kwargs [ \"total\" ] = self . total elif \"total\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"total\" ] = total_length if \"disable\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"disable\" ] = self . no_progress results = [ JobRunner . wrap_fn ( callable_fn , arg_type , ** fn_kwargs )( dt ) for dt in tqdm ( data , ** self . tqdm_kwargs ) ] return results wrap_fn ( fn , arg_type = None , ** fn_kwargs ) staticmethod \u00b6 Small wrapper around a callable to properly format it's argument Source code in datamol/utils/jobs.py 73 74 75 76 77 78 79 80 81 82 83 84 85 @staticmethod def wrap_fn ( fn : Callable , arg_type : Optional [ str ] = None , ** fn_kwargs ): \"\"\"Small wrapper around a callable to properly format it's argument\"\"\" def _run ( args : Any ): if arg_type == \"kwargs\" : fn_kwargs . update ( ** args ) return fn ( ** fn_kwargs ) elif arg_type == \"args\" : return fn ( * args , ** fn_kwargs ) return fn ( args , ** fn_kwargs ) return _run parallelized ( fn , inputs_list , scheduler = 'processes' , n_jobs =- 1 , batch_size = 'auto' , progress = False , arg_type = 'arg' , total = None , tqdm_kwargs = None , ** job_kwargs ) \u00b6 Run a function in parallel. Parameters: Name Type Description Default fn Callable The function to run in parallel. required inputs_list Iterable [ Any ] List of inputs to pass to fn . required scheduler str Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. 'processes' n_jobs Optional [ int ] Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation -1 batch_size Union [ int , str ] Whether to automatically batch inputs_list . You should only use it when the length of inputs_list is very large (>100k elements). The length of inputs_list must also be defined. 'auto' progress bool Display a progress bar. Defaults to False. False arg_type str One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: fn(arg) (default). - \"args\": the input is passed as a list: fn(*args) . - \"kwargs\": the input is passed as a map: fn(**kwargs) . 'arg' total Optional [ int ] The number of elements in the iterator. Only used when progress is True. None tqdm_kwargs Optional [ dict ] Any additional arguments supported by the tqdm progress bar. None **job_kwargs Any Any additional arguments supported by joblib.Parallel . {} Returns: Type Description Sequence [ Optional [ Any ]] The results of the execution as a list. Source code in datamol/utils/jobs.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def parallelized ( fn : Callable , inputs_list : Iterable [ Any ], scheduler : str = \"processes\" , n_jobs : Optional [ int ] = - 1 , batch_size : Union [ int , str ] = \"auto\" , progress : bool = False , arg_type : str = \"arg\" , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , ** job_kwargs : Any , ) -> Sequence [ Optional [ Any ]]: \"\"\"Run a function in parallel. Args: fn: The function to run in parallel. inputs_list: List of inputs to pass to `fn`. scheduler: Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation batch_size: Whether to automatically batch `inputs_list`. You should only use it when the length of `inputs_list` is very large (>100k elements). The length of `inputs_list` must also be defined. progress: Display a progress bar. Defaults to False. arg_type: One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: `fn(arg)` (default). - \"args\": the input is passed as a list: `fn(*args)`. - \"kwargs\": the input is passed as a map: `fn(**kwargs)`. total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Returns: The results of the execution as a list. \"\"\" runner = JobRunner ( n_jobs = n_jobs , batch_size = batch_size , progress = progress , prefer = scheduler , total = total , tqdm_kwargs = tqdm_kwargs , ** job_kwargs , ) return runner ( fn , inputs_list , arg_type = arg_type ) parallelized_with_batches ( fn , inputs_list , batch_size , scheduler = 'processes' , n_jobs =- 1 , progress = False , arg_type = 'arg' , total = None , tqdm_kwargs = None , flatten_results = True , joblib_batch_size = 'auto' , ** job_kwargs ) \u00b6 Run a function in parallel using batches. Parameters: Name Type Description Default fn Callable The function to run in parallel. It must accept a batch of inputs_list . required inputs_list Iterable [ Any ] List of inputs to pass to fn . required batch_size int Batch size on which to run fn . required scheduler str Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. 'processes' n_jobs Optional [ int ] Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation -1 progress bool Display a progress bar. Defaults to False. False arg_type str One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: fn(arg) (default). - \"args\": the input is passed as a list: fn(*args) . - \"kwargs\": the input is passed as a map: fn(**kwargs) . 'arg' total Optional [ int ] The number of elements in the iterator. Only used when progress is True. None tqdm_kwargs Optional [ dict ] Any additional arguments supported by the tqdm progress bar. None flatten_results bool Whether to flatten the results. True joblib_batch_size Union [ int , str ] It corresponds to the batch_size argument of dm.parallelized that is forwarded to joblib.Parallel under the hood. 'auto' **job_kwargs Any Any additional arguments supported by joblib.Parallel . {} Returns: Type Description Sequence [ Optional [ Any ]] The results of the execution as a list. Source code in datamol/utils/jobs.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def parallelized_with_batches ( fn : Callable , inputs_list : Iterable [ Any ], batch_size : int , scheduler : str = \"processes\" , n_jobs : Optional [ int ] = - 1 , progress : bool = False , arg_type : str = \"arg\" , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , flatten_results : bool = True , joblib_batch_size : Union [ int , str ] = \"auto\" , ** job_kwargs : Any , ) -> Sequence [ Optional [ Any ]]: \"\"\"Run a function in parallel using batches. Args: fn: The function to run in parallel. It must accept a batch of `inputs_list`. inputs_list: List of inputs to pass to `fn`. batch_size: Batch size on which to run `fn`. scheduler: Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation progress: Display a progress bar. Defaults to False. arg_type: One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: `fn(arg)` (default). - \"args\": the input is passed as a list: `fn(*args)`. - \"kwargs\": the input is passed as a map: `fn(**kwargs)`. total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. flatten_results: Whether to flatten the results. joblib_batch_size: It corresponds to the `batch_size` argument of `dm.parallelized` that is forwarded to `joblib.Parallel` under the hood. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Returns: The results of the execution as a list. \"\"\" def _batch_iterator ( n : int , iterable : Iterable ): it = iter ( iterable ) while True : chunk_it = itertools . islice ( it , n ) try : first_el = next ( chunk_it ) except StopIteration : return yield list ( itertools . chain (( first_el ,), chunk_it )) # Compute the total number of batches of possible if total is not None : n_batches = total // batch_size n_batches = max ( n_batches , 1 ) elif isinstance ( inputs_list , collections . abc . Sized ): n_batches = len ( inputs_list ) // batch_size n_batches = max ( n_batches , 1 ) else : n_batches = None # Make an iterator over batches so it works even with Iterator without a defined length input_chunks = _batch_iterator ( batch_size , inputs_list ) runner = JobRunner ( n_jobs = n_jobs , batch_size = joblib_batch_size , progress = progress , prefer = scheduler , total = n_batches , tqdm_kwargs = tqdm_kwargs , ** job_kwargs , ) results = runner ( fn , input_chunks , arg_type = arg_type ) # Flatten the results if flatten_results : results = [ item for sublist in results for item in sublist ] return results perf \u00b6 watch_duration \u00b6 A Python decorator to measure execution time with logging capability. Parameters: Name Type Description Default log bool Whether to log the measured duration. True log_human_duration bool Whether to log duration in a human way depending on the amount. True Example: def fn ( n ): for i in range ( n ): print ( i ) time . sleep ( 0.2 ) with dm . utils . perf . watch_duration ( log = True ) as w : fn ( 5 ) print ( w . duration ) Source code in datamol/utils/perf.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class watch_duration : \"\"\"A Python decorator to measure execution time with logging capability. Args: log: Whether to log the measured duration. log_human_duration: Whether to log duration in a human way depending on the amount. Example: ```python def fn(n): for i in range(n): print(i) time.sleep(0.2) with dm.utils.perf.watch_duration(log=True) as w: fn(5) print(w.duration) ``` \"\"\" def __init__ ( self , log : bool = True , log_human_duration : bool = True ): self . log = log self . log_human_duration = log_human_duration self . start = None self . end = None self . duration = None self . duration_minutes = None def __enter__ ( self ): self . start = time . time () return self def __exit__ ( self , * _ ): assert self . start is not None self . end = time . time () self . duration = self . end - self . start self . duration_minutes = self . duration / 60 if self . log : if self . log_human_duration : logger . info ( f \"Duration { human_duration ( self . duration ) } .\" ) else : logger . info ( f \"Duration { self . duration_minutes : .2f } minutes\" )","title":"datamol.utils"},{"location":"api/datamol.utils.html#datamolutils","text":"","title":"datamol.utils"},{"location":"api/datamol.utils.html#datamol.utils.decorators","text":"","title":"decorators"},{"location":"api/datamol.utils.html#datamol.utils.decorators.disable_on_os","text":"A decorator to disable a function raising an error if the OS detected is not supported. Parameters: Name Type Description Default os_names Union [ str , List [ str ]] OS names to disable this function. Valid OS names are: [\"linux\", \"osx\", \"win\"] . required Source code in datamol/utils/decorators.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def disable_on_os ( os_names : Union [ str , List [ str ]]): \"\"\"A decorator to disable a function raising an error if the OS detected is not supported. Args: os_names: OS names to disable this function. Valid OS names are: `[\"linux\", \"osx\", \"win\"]`. \"\"\" if isinstance ( os_names , str ): os_names = [ os_names ] valid_os_names = [] for os_name in os_names : if os_name == \"linux\" : valid_os_names . append ( \"Linux\" ) elif os_name == \"win\" : valid_os_names . append ( \"Windows\" ) elif os_name == \"osx\" : valid_os_names . append ( \"Darwin\" ) else : valid_os_names . append ( os_name ) def real_decorator ( function : Callable ): @wraps ( function ) def wrapper ( * args , ** kwargs ): if platform . system () not in valid_os_names : retval = function ( * args , ** kwargs ) return retval else : raise NotImplementedError ( f \"The function { function . __name__ } is not supported\" f \" for the platform ' { platform . system () } '.\" ) return wrapper return real_decorator","title":"disable_on_os()"},{"location":"api/datamol.utils.html#datamol.utils.fs","text":"The fs module makes it easier to work with all type of path (the ones supported by fsspec ).","title":"fs"},{"location":"api/datamol.utils.html#datamol.utils.fs.copy_dir","text":"Copy one directory to another location across different filesystem (local, S3, GCS, etc). Parameters: Name Type Description Default source Union [ str , pathlib . Path ] Path to the source directory. required destination Union [ str , pathlib . Path ] Path to the destination directory. required chunk_size Optional [ int ] the chunk size to use. If progress is enabled the chunk size is None , it is set to 2048. None force bool whether to overwrite the destination directory if it exists. False progress bool Whether to display a progress bar. False leave_progress bool Whether to hide the progress bar once the copy is done. True file_progress bool Whether to display a progress bar for each file. False file_leave_progress bool Whether to hide the progress bar once a file copy is done. False chunk_size Optional [ int ] See dm.utils.fs.copy_file . None Source code in datamol/utils/fs.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def copy_dir ( source : Union [ str , pathlib . Path ], destination : Union [ str , pathlib . Path ], force : bool = False , progress : bool = False , leave_progress : bool = True , file_progress : bool = False , file_leave_progress : bool = False , chunk_size : Optional [ int ] = None , ): \"\"\"Copy one directory to another location across different filesystem (local, S3, GCS, etc). Args: source: Path to the source directory. destination: Path to the destination directory. chunk_size: the chunk size to use. If progress is enabled the chunk size is `None`, it is set to 2048. force: whether to overwrite the destination directory if it exists. progress: Whether to display a progress bar. leave_progress: Whether to hide the progress bar once the copy is done. file_progress: Whether to display a progress bar for each file. file_leave_progress: Whether to hide the progress bar once a file copy is done. chunk_size: See `dm.utils.fs.copy_file`. \"\"\" source = str ( source ) destination = str ( destination ) source_fs = get_mapper ( source ) . fs destination_fs = get_mapper ( destination ) . fs # Sanity check if not is_dir ( source ): raise ValueError ( f \"The directory being copied does not exist or is not a directory: { source } \" ) if not force and is_dir ( destination ): raise ValueError ( f \"The destination folder to copy already exists: { destination } \" ) # Get all input paths with details # NOTE(hadim): we could have use `.glob(..., detail=True)` here but that API is inconsistent # between the backends resulting in different object types being returned (dict, list, etc). detailed_paths = source_fs . find ( source , withdirs = True , detail = True ) detailed_paths = list ( detailed_paths . values ()) # Get list of input types input_types = [ d [ \"type\" ] for d in detailed_paths ] # Get list of input path + add protocol if needed input_paths = [ d [ \"name\" ] for d in detailed_paths ] input_paths = [ fsspec . utils . _unstrip_protocol ( p , source_fs ) for p in input_paths ] # Build all the output paths output_paths : List [ str ] = fsspec . utils . other_paths ( input_paths , destination ) # type: ignore def _copy_source_to_destination ( input_path , input_type , output_path ): # A directory if input_type == \"directory\" : destination_fs . mkdir ( output_path ) # A file else : copy_file ( input_path , output_path , force = force , progress = file_progress , leave_progress = file_leave_progress , chunk_size = chunk_size , ) # Copy source files/directories to destination in parallel parallelized ( _copy_source_to_destination , inputs_list = list ( zip ( input_paths , input_types , output_paths )), arg_type = \"args\" , progress = progress , tqdm_kwargs = dict ( leave = leave_progress ), scheduler = \"threads\" , )","title":"copy_dir()"},{"location":"api/datamol.utils.html#datamol.utils.fs.copy_file","text":"Copy one file to another location across different filesystem (local, S3, GCS, etc). Parameters: Name Type Description Default source Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ] path or file-like object to copy from. required destination Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ] path or file-like object to copy to. required chunk_size Optional [ int ] the chunk size to use. If progress is enabled the chunk size is None , it is set to 1MB (1024 * 1024). None force bool whether to overwrite the destination file if it exists. False progress bool whether to display a progress bar. False leave_progress bool whether to hide the progress bar once the copy is done. True Source code in datamol/utils/fs.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def copy_file ( source : Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ], destination : Union [ str , pathlib . Path , io . IOBase , fsspec . core . OpenFile ], chunk_size : Optional [ int ] = None , force : bool = False , progress : bool = False , leave_progress : bool = True , ): \"\"\"Copy one file to another location across different filesystem (local, S3, GCS, etc). Args: source: path or file-like object to copy from. destination: path or file-like object to copy to. chunk_size: the chunk size to use. If progress is enabled the chunk size is `None`, it is set to 1MB (1024 * 1024). force: whether to overwrite the destination file if it exists. progress: whether to display a progress bar. leave_progress: whether to hide the progress bar once the copy is done. \"\"\" if progress and chunk_size is None : chunk_size = 1024 * 1024 if isinstance ( source , ( str , pathlib . Path )): source_file = fsspec . open ( str ( source ), \"rb\" ) else : source_file = source if isinstance ( destination , ( str , pathlib . Path )): # adapt the file mode of the destination depending on the source file. destination_mode = \"wb\" if hasattr ( source_file , \"mode\" ): destination_mode = \"wb\" if \"b\" in getattr ( source_file , \"mode\" ) else \"w\" elif isinstance ( source_file , io . BytesIO ): destination_mode = \"wb\" elif isinstance ( source_file , io . StringIO ): destination_mode = \"w\" destination_file = fsspec . open ( str ( destination ), destination_mode ) else : destination_file = destination if not is_file ( source_file ): # type: ignore raise ValueError ( f \"The file being copied does not exist or is not a file: { source } \" ) if not force and is_file ( destination_file ): # type: ignore raise ValueError ( f \"The destination file to copy already exists: { destination } \" ) with source_file as source_stream : with destination_file as destination_stream : if chunk_size is None : # copy without chunks destination_stream . write ( source_stream . read ()) # type: ignore else : # copy with chunks # determine the size of the source file source_size = None if progress : source_size = get_size ( source ) pbar = None if progress : tqdm = _import_tqdm () if tqdm is None : raise ImportError ( \"If the progress bar is enabled, you must have `tqdm` \" \"installed: `conda install tqdm`.\" ) else : # init progress bar pbar = tqdm ( total = source_size , leave = leave_progress , disable = not progress , unit = \"B\" , unit_divisor = 1024 , unit_scale = True , ) # start the loop while True : data = source_stream . read ( chunk_size ) # type: ignore if not data : break destination_stream . write ( data ) # type: ignore if pbar is not None : pbar . update ( chunk_size ) if pbar is not None : pbar . close ()","title":"copy_file()"},{"location":"api/datamol.utils.html#datamol.utils.fs.exists","text":"Check whether a file or a directory exists. Important: File-like object always exists. Parameters: Name Type Description Default path Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 96 97 98 99 100 101 102 103 104 def exists ( path : Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ]): \"\"\"Check whether a file or a directory exists. Important: File-like object always exists. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" return is_file ( path ) or is_dir ( path )","title":"exists()"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_basename","text":"Get the basename of a file or a folder. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 74 75 76 77 78 79 80 81 82 83 def get_basename ( path : Union [ str , os . PathLike ]): \"\"\"Get the basename of a file or a folder. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" path = str ( path ) mapper = get_mapper ( path ) clean_path = path . rstrip ( mapper . fs . sep ) return str ( clean_path ) . split ( mapper . fs . sep )[ - 1 ]","title":"get_basename()"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_cache_dir","text":"Get a local cache directory for a given application name. Parameters: Name Type Description Default app_name str The name of the application. required suffix Optional [ str ] A subdirectory appended to the cache dir. None create bool Whether to create the directory and its parents if it does not already exist. True Source code in datamol/utils/fs.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def get_cache_dir ( app_name : str , suffix : Optional [ str ] = None , create : bool = True ): \"\"\"Get a local cache directory for a given application name. Args: app_name: The name of the application. suffix: A subdirectory appended to the cache dir. create: Whether to create the directory and its parents if it does not already exist. \"\"\" appdirs = _import_appdirs () if appdirs is None : raise ImportError ( \"To use `dm.utils.fs.get_cache_dir()`, you must have `appdirs` \" \"installed: `conda install appdirs`.\" ) cache_dir = pathlib . Path ( appdirs . user_cache_dir ( appname = app_name )) if suffix is not None : cache_dir /= suffix if create : cache_dir . mkdir ( exist_ok = True , parents = True ) return cache_dir","title":"get_cache_dir()"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_extension","text":"Get the extension of a file. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 86 87 88 89 90 91 92 93 def get_extension ( path : Union [ str , os . PathLike ]): \"\"\"Get the extension of a file. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" basename = get_basename ( path ) return basename . split ( \".\" )[ - 1 ]","title":"get_extension()"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_mapper","text":"Get the fsspec mapper. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 65 66 67 68 69 70 71 def get_mapper ( path : Union [ str , os . PathLike ]): \"\"\"Get the fsspec mapper. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" return fsspec . get_mapper ( str ( path ))","title":"get_mapper()"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_protocol","text":"Return the name of the path protocol. Parameters: Name Type Description Default path Union [ str , os . PathLike ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def get_protocol ( path : Union [ str , os . PathLike ], fs : Optional [ fsspec . AbstractFileSystem ] = None ): \"\"\"Return the name of the path protocol. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" if fs is None : fs = get_mapper ( path ) . fs protocol = fs . protocol # type: ignore if \"s3\" in protocol : return \"s3\" elif \"gs\" in protocol : return \"gs\" elif isinstance ( protocol , ( tuple , list )): return protocol [ 0 ] return protocol","title":"get_protocol()"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_size","text":"Get the size of a file given its path. Return None if the size can't be retrieved. Source code in datamol/utils/fs.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def get_size ( file : Union [ str , os . PathLike , io . IOBase , fsspec . core . OpenFile ]) -> Optional [ int ]: \"\"\"Get the size of a file given its path. Return None if the size can't be retrieved. \"\"\" if isinstance ( file , io . IOBase ) and hasattr ( file , \"name\" ): fs_local = fsspec . filesystem ( \"file\" ) file_size = fs_local . size ( getattr ( file , \"name\" )) elif isinstance ( file , ( str , pathlib . Path )): fs = get_mapper ( str ( file )) . fs file_size = fs . size ( str ( file )) elif isinstance ( file , fsspec . core . OpenFile ): file_size = file . fs . size ( file . path ) else : file_size = None return file_size","title":"get_size()"},{"location":"api/datamol.utils.html#datamol.utils.fs.glob","text":"Find files by glob-matching. Parameters: Name Type Description Default path str A glob-style path. required Source code in datamol/utils/fs.py 330 331 332 333 334 335 336 337 338 339 340 def glob ( path : str , detail : bool = False , ** kwargs ) -> List [ str ]: \"\"\"Find files by glob-matching. Args: path: A glob-style path. \"\"\" # Get the list of paths fs = get_mapper ( path ) . fs paths = fs . glob ( path , detail = detail , ** kwargs ) paths = [ fsspec . utils . _unstrip_protocol ( d , fs ) for d in paths ] return paths","title":"glob()"},{"location":"api/datamol.utils.html#datamol.utils.fs.is_dir","text":"Check whether a file exists. Important: File-like object always exists. Parameters: Name Type Description Default path Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def is_dir ( path : Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ]): \"\"\"Check whether a file exists. Important: File-like object always exists. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" if isinstance ( path , fsspec . core . OpenFile ): return path . fs . isdir ( path . path ) elif isinstance ( path , ( str , pathlib . Path )): mapper = get_mapper ( str ( path )) return mapper . fs . isdir ( path ) else : return False","title":"is_dir()"},{"location":"api/datamol.utils.html#datamol.utils.fs.is_file","text":"Check whether a file exists. Important: File-like object always exists. Parameters: Name Type Description Default path Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ] a path supported by fsspec such as local, s3, gcs, etc. required Source code in datamol/utils/fs.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def is_file ( path : Union [ str , os . PathLike , fsspec . core . OpenFile , io . IOBase ]): \"\"\"Check whether a file exists. Important: File-like object always exists. Args: path: a path supported by `fsspec` such as local, s3, gcs, etc. \"\"\" if isinstance ( path , fsspec . core . OpenFile ): return path . fs . isfile ( path . path ) elif isinstance ( path , ( str , pathlib . Path )): mapper = get_mapper ( str ( path )) return mapper . fs . isfile ( path ) else : return True","title":"is_file()"},{"location":"api/datamol.utils.html#datamol.utils.fs.is_local_path","text":"Check whether a path is local. Source code in datamol/utils/fs.py 166 167 168 def is_local_path ( path : Union [ str , os . PathLike ]): \"\"\"Check whether a path is local.\"\"\" return get_protocol ( str ( path )) == \"file\"","title":"is_local_path()"},{"location":"api/datamol.utils.html#datamol.utils.fs.join","text":"Join paths together. The first element determine the filesystem to use (and so the separator. Parameters: Name Type Description Default *paths str a list of paths supported by fsspec such as local, s3, gcs, etc. () Source code in datamol/utils/fs.py 171 172 173 174 175 176 177 178 179 180 181 182 def join ( * paths : str ): \"\"\"Join paths together. The first element determine the filesystem to use (and so the separator. Args: *paths: a list of paths supported by `fsspec` such as local, s3, gcs, etc. \"\"\" paths = [ str ( path ) . rstrip ( \"/\" ) for path in paths ] source_path = paths [ 0 ] fs = get_mapper ( source_path ) . fs full_path = fs . sep . join ( paths ) return full_path","title":"join()"},{"location":"api/datamol.utils.html#datamol.utils.fs.md5","text":"Return the md5 hash of a file. Parameters: Name Type Description Default filepath Union [ str , os . PathLike ] The path to the file to compute the MD5 hash on. required Source code in datamol/utils/fs.py 317 318 319 320 321 322 323 324 325 326 327 def md5 ( filepath : Union [ str , os . PathLike ]): \"\"\"Return the md5 hash of a file. Args: filepath: The path to the file to compute the MD5 hash on. \"\"\" with fsspec . open ( filepath ) as f : file_hash = hashlib . md5 () file_hash . update ( f . read ()) # type: ignore file_hash = file_hash . hexdigest () return file_hash","title":"md5()"},{"location":"api/datamol.utils.html#datamol.utils.fs.mkdir","text":"Create a directory. Parameters: Name Type Description Default dir_path Union [ str , os . PathLike ] The path of the directory to create. required exist_ok bool Whether to ignore the error if the directory already exists. False Source code in datamol/utils/fs.py 305 306 307 308 309 310 311 312 313 314 def mkdir ( dir_path : Union [ str , os . PathLike ], exist_ok : bool = False ): \"\"\"Create a directory. Args: dir_path: The path of the directory to create. exist_ok: Whether to ignore the error if the directory already exists. \"\"\" fs = get_mapper ( str ( dir_path )) . fs fs . mkdirs ( str ( dir_path ), exist_ok = exist_ok )","title":"mkdir()"},{"location":"api/datamol.utils.html#datamol.utils.jobs","text":"","title":"jobs"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner","text":"Source code in datamol/utils/jobs.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class JobRunner : def __init__ ( self , n_jobs : Optional [ int ] = - 1 , batch_size : Union [ int , str ] = \"auto\" , prefer : Optional [ str ] = None , progress : bool = False , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , ** job_kwargs : Any , ): \"\"\" JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which allows taking advantage of its features, while the progress bar use tqdm Args: n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation batch_size: Whether to batch `inputs_list`. You can specify batch_size when the length of `inputs_list` is very large (>100k elements). By default, the auto batching of joblib is used. prefer: Choose from ['processes', 'threads'] or None. Default to None. Soft hint to choose the default backend if no specific backend was selected with the parallel_backend context manager. The default process-based backend is 'loky' and the default thread-based backend is 'threading'. Ignored if the ``backend`` parameter is specified. progress: whether to display progress bar total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Example: ```python import datamol as dm runner = dm.JobRunner(n_jobs=4, progress=True, prefer=\"threads\") results = runner(lambda x: x**2, [1, 2, 3, 4]) ``` \"\"\" self . n_jobs = n_jobs self . batch_size = batch_size self . prefer = prefer self . job_kwargs = job_kwargs self . job_kwargs . update ( n_jobs = self . n_jobs , prefer = self . prefer , batch_size = self . batch_size ) self . no_progress = not progress self . total = total self . tqdm_kwargs = tqdm_kwargs or {} @property def is_sequential ( self ): \"\"\"Check whether the job is sequential or parallel\"\"\" return ( self . n_jobs is None ) or ( self . n_jobs in [ 0 , 1 ]) @staticmethod def wrap_fn ( fn : Callable , arg_type : Optional [ str ] = None , ** fn_kwargs ): \"\"\"Small wrapper around a callable to properly format it's argument\"\"\" def _run ( args : Any ): if arg_type == \"kwargs\" : fn_kwargs . update ( ** args ) return fn ( ** fn_kwargs ) elif arg_type == \"args\" : return fn ( * args , ** fn_kwargs ) return fn ( args , ** fn_kwargs ) return _run def sequential ( self , callable_fn : Callable , data : Iterable [ Any ], arg_type : Optional [ str ] = None , ** fn_kwargs , ): \"\"\" Run job in sequential version Args: callable_fn (callable): function to call data (iterable): input data arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs') **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton \"\"\" total_length = JobRunner . get_iterator_length ( data ) if self . total is not None : self . tqdm_kwargs [ \"total\" ] = self . total elif \"total\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"total\" ] = total_length if \"disable\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"disable\" ] = self . no_progress results = [ JobRunner . wrap_fn ( callable_fn , arg_type , ** fn_kwargs )( dt ) for dt in tqdm ( data , ** self . tqdm_kwargs ) ] return results def parallel ( self , callable_fn : Callable , data : Iterable [ Any ], arg_type : Optional [ str ] = None , ** fn_kwargs , ): \"\"\" Run job in parallel Args: callable_fn (callable): function to call data (iterable): input data arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs') **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton \"\"\" total_length = JobRunner . get_iterator_length ( data ) if self . total is not None : self . tqdm_kwargs [ \"total\" ] = self . total elif \"total\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"total\" ] = total_length if \"disable\" not in self . tqdm_kwargs : self . tqdm_kwargs [ \"disable\" ] = self . no_progress runner = JobRunner . _parallel_helper ( ** self . job_kwargs ) results = runner ( ** self . tqdm_kwargs )( delayed ( JobRunner . wrap_fn ( callable_fn , arg_type , ** fn_kwargs ))( dt ) for dt in data ) return results def __call__ ( self , * args , ** kwargs ): \"\"\" Run job using the n_jobs attribute to determine regime \"\"\" if self . is_sequential : return self . sequential ( * args , ** kwargs ) return self . parallel ( * args , ** kwargs ) @staticmethod def _parallel_helper ( ** joblib_args ): r \"\"\" Parallel helper function for joblib with tqdm support \"\"\" def run ( ** tq_args ): def tmp ( op_iter ): with _tqdm_callback ( tqdm ( ** tq_args )): return Parallel ( ** joblib_args )( op_iter ) return tmp return run @staticmethod def get_iterator_length ( data ): \"\"\"Attempt to get the length of an iterator\"\"\" total_length = None try : total_length = len ( data ) except TypeError : # most likely a generator, ignore pass return total_length","title":"JobRunner"},{"location":"api/datamol.utils.html#datamol.utils.jobs.parallelized","text":"Run a function in parallel. Parameters: Name Type Description Default fn Callable The function to run in parallel. required inputs_list Iterable [ Any ] List of inputs to pass to fn . required scheduler str Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. 'processes' n_jobs Optional [ int ] Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation -1 batch_size Union [ int , str ] Whether to automatically batch inputs_list . You should only use it when the length of inputs_list is very large (>100k elements). The length of inputs_list must also be defined. 'auto' progress bool Display a progress bar. Defaults to False. False arg_type str One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: fn(arg) (default). - \"args\": the input is passed as a list: fn(*args) . - \"kwargs\": the input is passed as a map: fn(**kwargs) . 'arg' total Optional [ int ] The number of elements in the iterator. Only used when progress is True. None tqdm_kwargs Optional [ dict ] Any additional arguments supported by the tqdm progress bar. None **job_kwargs Any Any additional arguments supported by joblib.Parallel . {} Returns: Type Description Sequence [ Optional [ Any ]] The results of the execution as a list. Source code in datamol/utils/jobs.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def parallelized ( fn : Callable , inputs_list : Iterable [ Any ], scheduler : str = \"processes\" , n_jobs : Optional [ int ] = - 1 , batch_size : Union [ int , str ] = \"auto\" , progress : bool = False , arg_type : str = \"arg\" , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , ** job_kwargs : Any , ) -> Sequence [ Optional [ Any ]]: \"\"\"Run a function in parallel. Args: fn: The function to run in parallel. inputs_list: List of inputs to pass to `fn`. scheduler: Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation batch_size: Whether to automatically batch `inputs_list`. You should only use it when the length of `inputs_list` is very large (>100k elements). The length of `inputs_list` must also be defined. progress: Display a progress bar. Defaults to False. arg_type: One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: `fn(arg)` (default). - \"args\": the input is passed as a list: `fn(*args)`. - \"kwargs\": the input is passed as a map: `fn(**kwargs)`. total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Returns: The results of the execution as a list. \"\"\" runner = JobRunner ( n_jobs = n_jobs , batch_size = batch_size , progress = progress , prefer = scheduler , total = total , tqdm_kwargs = tqdm_kwargs , ** job_kwargs , ) return runner ( fn , inputs_list , arg_type = arg_type )","title":"parallelized()"},{"location":"api/datamol.utils.html#datamol.utils.jobs.parallelized_with_batches","text":"Run a function in parallel using batches. Parameters: Name Type Description Default fn Callable The function to run in parallel. It must accept a batch of inputs_list . required inputs_list Iterable [ Any ] List of inputs to pass to fn . required batch_size int Batch size on which to run fn . required scheduler str Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. 'processes' n_jobs Optional [ int ] Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation -1 progress bool Display a progress bar. Defaults to False. False arg_type str One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: fn(arg) (default). - \"args\": the input is passed as a list: fn(*args) . - \"kwargs\": the input is passed as a map: fn(**kwargs) . 'arg' total Optional [ int ] The number of elements in the iterator. Only used when progress is True. None tqdm_kwargs Optional [ dict ] Any additional arguments supported by the tqdm progress bar. None flatten_results bool Whether to flatten the results. True joblib_batch_size Union [ int , str ] It corresponds to the batch_size argument of dm.parallelized that is forwarded to joblib.Parallel under the hood. 'auto' **job_kwargs Any Any additional arguments supported by joblib.Parallel . {} Returns: Type Description Sequence [ Optional [ Any ]] The results of the execution as a list. Source code in datamol/utils/jobs.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def parallelized_with_batches ( fn : Callable , inputs_list : Iterable [ Any ], batch_size : int , scheduler : str = \"processes\" , n_jobs : Optional [ int ] = - 1 , progress : bool = False , arg_type : str = \"arg\" , total : Optional [ int ] = None , tqdm_kwargs : Optional [ dict ] = None , flatten_results : bool = True , joblib_batch_size : Union [ int , str ] = \"auto\" , ** job_kwargs : Any , ) -> Sequence [ Optional [ Any ]]: \"\"\"Run a function in parallel using batches. Args: fn: The function to run in parallel. It must accept a batch of `inputs_list`. inputs_list: List of inputs to pass to `fn`. batch_size: Batch size on which to run `fn`. scheduler: Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler. n_jobs: Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation progress: Display a progress bar. Defaults to False. arg_type: One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: `fn(arg)` (default). - \"args\": the input is passed as a list: `fn(*args)`. - \"kwargs\": the input is passed as a map: `fn(**kwargs)`. total: The number of elements in the iterator. Only used when `progress` is True. tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar. flatten_results: Whether to flatten the results. joblib_batch_size: It corresponds to the `batch_size` argument of `dm.parallelized` that is forwarded to `joblib.Parallel` under the hood. **job_kwargs: Any additional arguments supported by `joblib.Parallel`. Returns: The results of the execution as a list. \"\"\" def _batch_iterator ( n : int , iterable : Iterable ): it = iter ( iterable ) while True : chunk_it = itertools . islice ( it , n ) try : first_el = next ( chunk_it ) except StopIteration : return yield list ( itertools . chain (( first_el ,), chunk_it )) # Compute the total number of batches of possible if total is not None : n_batches = total // batch_size n_batches = max ( n_batches , 1 ) elif isinstance ( inputs_list , collections . abc . Sized ): n_batches = len ( inputs_list ) // batch_size n_batches = max ( n_batches , 1 ) else : n_batches = None # Make an iterator over batches so it works even with Iterator without a defined length input_chunks = _batch_iterator ( batch_size , inputs_list ) runner = JobRunner ( n_jobs = n_jobs , batch_size = joblib_batch_size , progress = progress , prefer = scheduler , total = n_batches , tqdm_kwargs = tqdm_kwargs , ** job_kwargs , ) results = runner ( fn , input_chunks , arg_type = arg_type ) # Flatten the results if flatten_results : results = [ item for sublist in results for item in sublist ] return results","title":"parallelized_with_batches()"},{"location":"api/datamol.utils.html#datamol.utils.perf","text":"","title":"perf"},{"location":"api/datamol.utils.html#datamol.utils.perf.watch_duration","text":"A Python decorator to measure execution time with logging capability. Parameters: Name Type Description Default log bool Whether to log the measured duration. True log_human_duration bool Whether to log duration in a human way depending on the amount. True Example: def fn ( n ): for i in range ( n ): print ( i ) time . sleep ( 0.2 ) with dm . utils . perf . watch_duration ( log = True ) as w : fn ( 5 ) print ( w . duration ) Source code in datamol/utils/perf.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class watch_duration : \"\"\"A Python decorator to measure execution time with logging capability. Args: log: Whether to log the measured duration. log_human_duration: Whether to log duration in a human way depending on the amount. Example: ```python def fn(n): for i in range(n): print(i) time.sleep(0.2) with dm.utils.perf.watch_duration(log=True) as w: fn(5) print(w.duration) ``` \"\"\" def __init__ ( self , log : bool = True , log_human_duration : bool = True ): self . log = log self . log_human_duration = log_human_duration self . start = None self . end = None self . duration = None self . duration_minutes = None def __enter__ ( self ): self . start = time . time () return self def __exit__ ( self , * _ ): assert self . start is not None self . end = time . time () self . duration = self . end - self . start self . duration_minutes = self . duration / 60 if self . log : if self . log_human_duration : logger . info ( f \"Duration { human_duration ( self . duration ) } .\" ) else : logger . info ( f \"Duration { self . duration_minutes : .2f } minutes\" )","title":"watch_duration"},{"location":"api/datamol.viz.html","text":"datamol.viz \u00b6 Vizualize molecule in 2D or 3D \u00b6 to_image ( mols , legends = None , n_cols = 4 , use_svg = True , mol_size = ( 300 , 300 ), highlight_atom = None , highlight_bond = None , outfile = None , max_mols = 32 , copy = True , indices = False , bond_indices = False , bond_line_width = 2 , stereo_annotations = True , legend_fontsize = 16 , kekulize = True , align = False , ** kwargs ) \u00b6 Generate an image out of a molecule or a list of molecules. Parameters: Name Type Description Default mols Union [ List [ dm . Mol ], dm . Mol ] One or a list of molecules. required legends Union [ List [ Union [ str , None]], str , None] A string or a list of string as legend for every molecules. None n_cols int Number of molecules per column. 4 use_svg bool Whether to ouput an SVG (or a PNG). True mol_size Union [ Tuple [ int , int ], int ] A int or a tuple of int defining the size per molecule. (300, 300) highlight_atom Optional [ List [ List [ int ]]] the atoms to highlight. None highlight_bond Optional [ List [ List [ int ]]] The bonds to highlight. None outfile Optional [ str ] Path where to save the image (local or remote path). None max_mols int The maximum number of molecules to display. 32 copy bool Whether to copy the molecules or not. True indices bool Whether to draw the atom indices. False bond_indices bool Whether to draw the bond indices. False bond_line_width int The width of the bond lines. 2 legend_fontsize int Font size for the legend. 16 kekulize bool Run kekulization routine on molecules. Skipped if fails. True align Union [ dm . Mol , str , bool ] Whether to align the 2D coordinates of the molecules. - If set to True, align all molecules with dm.align.auto_align_many() . - If set to a molecule, it is used as a template for alignment with dm.align.template_align() . - If set to False, no alignment is performed. For a more custom alignment, we suggest using directly the module dm.align instead. False **kwargs Any Additional arguments to pass to the drawing function. See RDKit documentation related to MolDrawOptions for more details at https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html . {} Source code in datamol/viz/_viz.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def to_image ( mols : Union [ List [ dm . Mol ], dm . Mol ], legends : Union [ List [ Union [ str , None ]], str , None ] = None , n_cols : int = 4 , use_svg : bool = True , mol_size : Union [ Tuple [ int , int ], int ] = ( 300 , 300 ), highlight_atom : Optional [ List [ List [ int ]]] = None , highlight_bond : Optional [ List [ List [ int ]]] = None , outfile : Optional [ str ] = None , max_mols : int = 32 , copy : bool = True , indices : bool = False , bond_indices : bool = False , bond_line_width : int = 2 , stereo_annotations : bool = True , legend_fontsize : int = 16 , kekulize : bool = True , align : Union [ dm . Mol , str , bool ] = False , ** kwargs : Any , ): \"\"\"Generate an image out of a molecule or a list of molecules. Args: mols: One or a list of molecules. legends: A string or a list of string as legend for every molecules. n_cols: Number of molecules per column. use_svg: Whether to ouput an SVG (or a PNG). mol_size: A int or a tuple of int defining the size per molecule. highlight_atom: the atoms to highlight. highlight_bond: The bonds to highlight. outfile: Path where to save the image (local or remote path). max_mols: The maximum number of molecules to display. copy: Whether to copy the molecules or not. indices: Whether to draw the atom indices. bond_indices: Whether to draw the bond indices. bond_line_width: The width of the bond lines. legend_fontsize: Font size for the legend. kekulize: Run kekulization routine on molecules. Skipped if fails. align: Whether to align the 2D coordinates of the molecules. - If set to True, align all molecules with `dm.align.auto_align_many()`. - If set to a molecule, it is used as a template for alignment with `dm.align.template_align()`. - If set to False, no alignment is performed. For a more custom alignment, we suggest using directly the module `dm.align` instead. **kwargs: Additional arguments to pass to the drawing function. See RDKit documentation related to `MolDrawOptions` for more details at https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html. \"\"\" if isinstance ( mol_size , int ): mol_size = ( mol_size , mol_size ) if isinstance ( mols , dm . Mol ): mols = [ mols ] if isinstance ( legends , str ): legends = [ legends ] if copy : mols = [ dm . copy_mol ( mol ) for mol in mols ] if max_mols is not None : mols = mols [: max_mols ] if legends is not None : legends = legends [: max_mols ] # Whether to align the molecules if isinstance ( align , ( dm . Mol , str )): mols = [ dm . align . template_align ( mol , template = align ) for mol in mols ] elif align is True : mols = dm . align . auto_align_many ( mols ) # Prepare molecules before drawing mols = [ prepare_mol_for_drawing ( mol , kekulize = kekulize ) for mol in mols ] _highlight_atom = highlight_atom if highlight_atom is not None and isinstance ( highlight_atom [ 0 ], int ): _highlight_atom = [ highlight_atom ] _highlight_bond = highlight_bond if highlight_bond is not None and isinstance ( highlight_bond [ 0 ], int ): _highlight_bond = [ highlight_bond ] # Don't make the image bigger than it if len ( mols ) < n_cols : n_cols = len ( mols ) draw_options = Draw . rdMolDraw2D . MolDrawOptions () draw_options . legendFontSize = legend_fontsize draw_options . addAtomIndices = indices draw_options . addBondIndices = bond_indices draw_options . addStereoAnnotation = stereo_annotations draw_options . bondLineWidth = bond_line_width # Add the custom drawing options. _kwargs = {} for k , v in kwargs . items (): if hasattr ( draw_options , k ): setattr ( draw_options , k , v ) else : _kwargs [ k ] = v image = Draw . MolsToGridImage ( mols , legends = legends , molsPerRow = n_cols , useSVG = use_svg , subImgSize = mol_size , highlightAtomLists = _highlight_atom , highlightBondLists = _highlight_bond , drawOptions = draw_options , ** _kwargs , ) if outfile is not None : with fsspec . open ( outfile , \"wb\" ) as f : if use_svg : if isinstance ( image , str ): # in a terminal process f . write ( image . encode ()) # type: ignore else : # in a jupyter kernel process f . write ( image . data . encode ()) # type: ignore else : if isinstance ( image , PIL . PngImagePlugin . PngImageFile ): # type: ignore # in a terminal process image . save ( f ) else : # in a jupyter kernel process f . write ( image . data ) # type: ignore return image conformers ( mol , conf_id =- 1 , n_confs = None , align_conf = True , n_cols = 3 , sync_views = True , remove_hs = True , width = 'auto' ) \u00b6 Visualize the conformer(s) of a molecule. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required conf_id int The ID of the conformer to show. -1 shows the first conformer. Only works if n_confs is None. -1 n_confs Union [ int , List [ int ]] Can be a number of conformers to shows or a list of conformer indices. When None, only the first conformer is displayed. When -1, show all conformers. None align_conf bool Whether to align conformers together. True n_cols int Number of columns. Defaults to 3. 3 sync_views bool Wether to sync the multiple views. True remove_hs bool Wether to remove the hydrogens of the conformers. True width str The width of the returned view. Defaults to \"auto\". 'auto' Source code in datamol/viz/_conformers.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def conformers ( mol : Chem . rdchem . Mol , conf_id : int = - 1 , n_confs : Union [ int , List [ int ]] = None , align_conf : bool = True , n_cols : int = 3 , sync_views : bool = True , remove_hs : bool = True , width : str = \"auto\" , ): \"\"\"Visualize the conformer(s) of a molecule. Args: mol: a molecule. conf_id: The ID of the conformer to show. -1 shows the first conformer. Only works if `n_confs` is None. n_confs: Can be a number of conformers to shows or a list of conformer indices. When None, only the first conformer is displayed. When -1, show all conformers. align_conf: Whether to align conformers together. n_cols: Number of columns. Defaults to 3. sync_views: Wether to sync the multiple views. remove_hs: Wether to remove the hydrogens of the conformers. width: The width of the returned view. Defaults to \"auto\". \"\"\" widgets = _get_ipywidgets () nv = _get_nglview () if mol . GetNumConformers () == 0 : raise ValueError ( \"The molecule has 0 conformers. You can generate conformers with `dm.conformers.generate(mol)`.\" ) # Clone the molecule mol = copy . deepcopy ( mol ) if remove_hs : mol = Chem . RemoveHs ( mol ) # type: ignore else : mol = Chem . AddHs ( mol ) # type: ignore if n_confs is None : return nv . show_rdkit ( mol , conf_id = conf_id ) # If n_confs is int, convert to list of conformer IDs if n_confs == - 1 : n_confs = [ conf . GetId () for conf in mol . GetConformers ()] elif isinstance ( n_confs , int ): if n_confs > mol . GetNumConformers (): n_confs = mol . GetNumConformers () n_confs = list ( range ( n_confs )) # type: ignore if align_conf : rdMolAlign . AlignMolConformers ( mol , confIds = n_confs ) # Get number of rows n_rows = len ( n_confs ) // n_cols n_rows += 1 if ( len ( n_confs ) % n_cols ) > 0 else 0 # Create a grid grid = widgets . GridspecLayout ( n_rows , n_cols ) # type: ignore # Create and add views to the grid. widget_coords = itertools . product ( range ( n_rows ), range ( n_cols )) views = [] for i , ( conf_id , ( x , y )) in enumerate ( zip ( n_confs , widget_coords )): view = nv . show_rdkit ( mol , conf_id = conf_id ) view . layout . width = width view . layout . align_self = \"stretch\" grid [ x , y ] = view views . append ( view ) # Sync views if sync_views : for view in views : view . _set_sync_camera ( views ) return grid Specific plotting functions \u00b6 MolsCircleGrid \u00b6 Source code in datamol/viz/_circle_grid.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class MolsCircleGrid : def __init__ ( self , center_mol : Chem . rdchem . Mol , circle_mols : List [ List [ Chem . rdchem . Mol ]], legend : Optional [ str ] = None , mol_size : Tuple [ int , int ] = ( 200 , 200 ), circle_margin : int = 50 , act_mapper : Optional [ dict ] = None , ): \"\"\"Show molecules in concentric rings, with one molecule at the center Args: center_mol: Molecule at center circle_mols: List of molecule for each concentric circle around the center mol mol_size: Tuple of width and height for each molecule circle_margin: Margin between the circle layers act_mapper: Map each molecule to a dictionary of activity \"\"\" self . circle_mols = circle_mols self . circle_count = len ( self . circle_mols ) self . legend = legend or \"\" self . margin = circle_margin self . center_mol = center_mol self . mol_size = mol_size size = ( max ( mol_size ) + self . margin ) * ( self . circle_count + 1 ) self . size = size self . image = Image . new ( mode = \"RGBA\" , size = ( size , size ), color = ( 255 , 255 , 255 , 0 )) self . midpoint = size // 2 self . draw = None self . act_mapper = act_mapper or {} self . _draw () def show ( self , crop = False ): if crop : crop_img = ImageOps . crop ( self . image , border = 1 ) else : crop_img = self . image return crop_img . show () def save ( self , filename ): self . image . save ( filename ) def _draw ( self ): \"\"\"Create circles and slices in-memory\"\"\" draw = ImageDraw . Draw ( self . image ) self . draw = draw all_radius = self . _draw_circles ( draw ) self . _draw_center_mol () self . _draw_ring_mols ( all_radius ) font = None w , h = draw . textsize ( self . legend ) try : fn = FontManager () fontpath = fn . findfont ( \"Droid sans\" ) font = ImageFont . truetype ( fontpath , 12 * self . size // 800 ) w , h = font . getsize ( self . legend ) except : pass draw . text ( (( self . size // 2 - w ) - 2 , self . size - 2 * h ), self . legend , fill = \"black\" , font = font , ) del draw self . draw = None def _repr_png_ ( self ): bio = io . BytesIO () self . image . save ( bio , format = \"PNG\" ) return bio . getvalue () def _draw_circles ( self , draw ): if self . circle_count <= 0 : return [] radius_step = int ( self . midpoint / ( self . circle_count + 1 )) radius_list = [] full_range = range ( 0 , self . size // 2 , radius_step ) for i , radius in enumerate ( full_range ): radius += self . margin // 2 bounding_box = [ ( self . midpoint - radius , self . midpoint - radius ), ( self . midpoint + radius , self . midpoint + radius ), ] if radius > self . margin : transp = int ( 255 - ( 200 * ( i - 1 ) / len ( full_range ))) draw . arc ( bounding_box , 0 , 360 , fill = ( 190 , 190 , 190 , transp )) radius_list . append ( radius + radius_step ) return radius_list def _draw_mol_at ( self , mol , center_x , center_y , mol_size = None , act_dict = {}, center = False , ** kwargs : Any , ): img = mol if mol_size is None : mol_size = self . mol_size if isinstance ( mol , Chem . Mol ): img = Draw . MolToImage ( mol , mol_size , kekulize = True , fitImage = True , ** kwargs ) width , height = img . size self . image . paste ( img , ( int ( center_x - width / 2 ), int ( center_y - height / 2 ))) txt = [] for prop , propval in act_dict . items (): if not isinstance ( propval , str ): propval = \" {:.2f} \" . format ( propval ) txt . append ( f \" { prop } : { propval } \" ) if txt and self . draw is not None : txt = \" \\n \" . join ( txt ) font = None w , h = self . draw . multiline_textsize ( txt ) try : fn = FontManager () fontpath = fn . findfont ( \"Droid sans\" ) font = ImageFont . truetype ( fontpath , 18 + center * 8 ) w , h = self . draw . multiline_textsize ( txt , font = font ) except : pass def _draw_center_mol ( self ): self . _draw_mol_at ( self . center_mol , self . midpoint , self . midpoint , mol_size = [ x + self . margin for x in self . mol_size ], act_dict = self . act_mapper . get ( self . center_mol , {}), center = True , ) def _draw_ring_mols ( self , radius_list ): for i , mols in enumerate ( self . circle_mols ): radius = radius_list [ i ] ni = len ( mols ) rand_unit = random . random () * 2 * math . pi for k , mol in enumerate ( mols ): center_x = radius * math . cos ( 2 * k * math . pi / ni + rand_unit ) + self . midpoint center_y = radius * math . sin ( 2 * k * math . pi / ni + rand_unit ) + self . midpoint self . _draw_mol_at ( mol , center_x , center_y , act_dict = self . act_mapper . get ( mol , {})) __init__ ( center_mol , circle_mols , legend = None , mol_size = ( 200 , 200 ), circle_margin = 50 , act_mapper = None ) \u00b6 Show molecules in concentric rings, with one molecule at the center Parameters: Name Type Description Default center_mol Chem . rdchem . Mol Molecule at center required circle_mols List [ List [ Chem . rdchem . Mol ]] List of molecule for each concentric circle around the center mol required mol_size Tuple [ int , int ] Tuple of width and height for each molecule (200, 200) circle_margin int Margin between the circle layers 50 act_mapper Optional [ dict ] Map each molecule to a dictionary of activity None Source code in datamol/viz/_circle_grid.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , center_mol : Chem . rdchem . Mol , circle_mols : List [ List [ Chem . rdchem . Mol ]], legend : Optional [ str ] = None , mol_size : Tuple [ int , int ] = ( 200 , 200 ), circle_margin : int = 50 , act_mapper : Optional [ dict ] = None , ): \"\"\"Show molecules in concentric rings, with one molecule at the center Args: center_mol: Molecule at center circle_mols: List of molecule for each concentric circle around the center mol mol_size: Tuple of width and height for each molecule circle_margin: Margin between the circle layers act_mapper: Map each molecule to a dictionary of activity \"\"\" self . circle_mols = circle_mols self . circle_count = len ( self . circle_mols ) self . legend = legend or \"\" self . margin = circle_margin self . center_mol = center_mol self . mol_size = mol_size size = ( max ( mol_size ) + self . margin ) * ( self . circle_count + 1 ) self . size = size self . image = Image . new ( mode = \"RGBA\" , size = ( size , size ), color = ( 255 , 255 , 255 , 0 )) self . midpoint = size // 2 self . draw = None self . act_mapper = act_mapper or {} self . _draw () circle_grid ( center_mol , circle_mols , legend = None , mol_size = ( 200 , 200 ), circle_margin = 50 , act_mapper = None ) \u00b6 Show molecules in concentric rings, with one molecule at the center Parameters: Name Type Description Default center_mol Chem . Mol Molecule at center required circle_mols list of list of <Chem.Mol> List of molecule for each concentric circle around the center mol required mol_size tuple Tuple of width and height for each molecule (200, 200) circle_margin int Margin between the circle layers 50 act_mapper dict Map each molecule to a dictionary of activity None Source code in datamol/viz/_circle_grid.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def circle_grid ( center_mol : Chem . rdchem . Mol , circle_mols : List [ List [ Chem . rdchem . Mol ]], legend : Optional [ str ] = None , mol_size : Tuple [ int , int ] = ( 200 , 200 ), circle_margin : int = 50 , act_mapper : Optional [ dict ] = None , ): \"\"\"Show molecules in concentric rings, with one molecule at the center Args: center_mol (Chem.Mol): Molecule at center circle_mols (list of list of <Chem.Mol>): List of molecule for each concentric circle around the center mol mol_size (tuple, optional): Tuple of width and height for each molecule circle_margin (int, optional): Margin between the circle layers act_mapper (dict): Map each molecule to a dictionary of activity \"\"\" return MolsCircleGrid ( center_mol , circle_mols , legend , mol_size , circle_margin , act_mapper )","title":"datamol.viz"},{"location":"api/datamol.viz.html#datamolviz","text":"","title":"datamol.viz"},{"location":"api/datamol.viz.html#vizualize-molecule-in-2d-or-3d","text":"","title":"Vizualize molecule in 2D or 3D"},{"location":"api/datamol.viz.html#datamol.viz.to_image","text":"Generate an image out of a molecule or a list of molecules. Parameters: Name Type Description Default mols Union [ List [ dm . Mol ], dm . Mol ] One or a list of molecules. required legends Union [ List [ Union [ str , None]], str , None] A string or a list of string as legend for every molecules. None n_cols int Number of molecules per column. 4 use_svg bool Whether to ouput an SVG (or a PNG). True mol_size Union [ Tuple [ int , int ], int ] A int or a tuple of int defining the size per molecule. (300, 300) highlight_atom Optional [ List [ List [ int ]]] the atoms to highlight. None highlight_bond Optional [ List [ List [ int ]]] The bonds to highlight. None outfile Optional [ str ] Path where to save the image (local or remote path). None max_mols int The maximum number of molecules to display. 32 copy bool Whether to copy the molecules or not. True indices bool Whether to draw the atom indices. False bond_indices bool Whether to draw the bond indices. False bond_line_width int The width of the bond lines. 2 legend_fontsize int Font size for the legend. 16 kekulize bool Run kekulization routine on molecules. Skipped if fails. True align Union [ dm . Mol , str , bool ] Whether to align the 2D coordinates of the molecules. - If set to True, align all molecules with dm.align.auto_align_many() . - If set to a molecule, it is used as a template for alignment with dm.align.template_align() . - If set to False, no alignment is performed. For a more custom alignment, we suggest using directly the module dm.align instead. False **kwargs Any Additional arguments to pass to the drawing function. See RDKit documentation related to MolDrawOptions for more details at https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html . {} Source code in datamol/viz/_viz.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def to_image ( mols : Union [ List [ dm . Mol ], dm . Mol ], legends : Union [ List [ Union [ str , None ]], str , None ] = None , n_cols : int = 4 , use_svg : bool = True , mol_size : Union [ Tuple [ int , int ], int ] = ( 300 , 300 ), highlight_atom : Optional [ List [ List [ int ]]] = None , highlight_bond : Optional [ List [ List [ int ]]] = None , outfile : Optional [ str ] = None , max_mols : int = 32 , copy : bool = True , indices : bool = False , bond_indices : bool = False , bond_line_width : int = 2 , stereo_annotations : bool = True , legend_fontsize : int = 16 , kekulize : bool = True , align : Union [ dm . Mol , str , bool ] = False , ** kwargs : Any , ): \"\"\"Generate an image out of a molecule or a list of molecules. Args: mols: One or a list of molecules. legends: A string or a list of string as legend for every molecules. n_cols: Number of molecules per column. use_svg: Whether to ouput an SVG (or a PNG). mol_size: A int or a tuple of int defining the size per molecule. highlight_atom: the atoms to highlight. highlight_bond: The bonds to highlight. outfile: Path where to save the image (local or remote path). max_mols: The maximum number of molecules to display. copy: Whether to copy the molecules or not. indices: Whether to draw the atom indices. bond_indices: Whether to draw the bond indices. bond_line_width: The width of the bond lines. legend_fontsize: Font size for the legend. kekulize: Run kekulization routine on molecules. Skipped if fails. align: Whether to align the 2D coordinates of the molecules. - If set to True, align all molecules with `dm.align.auto_align_many()`. - If set to a molecule, it is used as a template for alignment with `dm.align.template_align()`. - If set to False, no alignment is performed. For a more custom alignment, we suggest using directly the module `dm.align` instead. **kwargs: Additional arguments to pass to the drawing function. See RDKit documentation related to `MolDrawOptions` for more details at https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html. \"\"\" if isinstance ( mol_size , int ): mol_size = ( mol_size , mol_size ) if isinstance ( mols , dm . Mol ): mols = [ mols ] if isinstance ( legends , str ): legends = [ legends ] if copy : mols = [ dm . copy_mol ( mol ) for mol in mols ] if max_mols is not None : mols = mols [: max_mols ] if legends is not None : legends = legends [: max_mols ] # Whether to align the molecules if isinstance ( align , ( dm . Mol , str )): mols = [ dm . align . template_align ( mol , template = align ) for mol in mols ] elif align is True : mols = dm . align . auto_align_many ( mols ) # Prepare molecules before drawing mols = [ prepare_mol_for_drawing ( mol , kekulize = kekulize ) for mol in mols ] _highlight_atom = highlight_atom if highlight_atom is not None and isinstance ( highlight_atom [ 0 ], int ): _highlight_atom = [ highlight_atom ] _highlight_bond = highlight_bond if highlight_bond is not None and isinstance ( highlight_bond [ 0 ], int ): _highlight_bond = [ highlight_bond ] # Don't make the image bigger than it if len ( mols ) < n_cols : n_cols = len ( mols ) draw_options = Draw . rdMolDraw2D . MolDrawOptions () draw_options . legendFontSize = legend_fontsize draw_options . addAtomIndices = indices draw_options . addBondIndices = bond_indices draw_options . addStereoAnnotation = stereo_annotations draw_options . bondLineWidth = bond_line_width # Add the custom drawing options. _kwargs = {} for k , v in kwargs . items (): if hasattr ( draw_options , k ): setattr ( draw_options , k , v ) else : _kwargs [ k ] = v image = Draw . MolsToGridImage ( mols , legends = legends , molsPerRow = n_cols , useSVG = use_svg , subImgSize = mol_size , highlightAtomLists = _highlight_atom , highlightBondLists = _highlight_bond , drawOptions = draw_options , ** _kwargs , ) if outfile is not None : with fsspec . open ( outfile , \"wb\" ) as f : if use_svg : if isinstance ( image , str ): # in a terminal process f . write ( image . encode ()) # type: ignore else : # in a jupyter kernel process f . write ( image . data . encode ()) # type: ignore else : if isinstance ( image , PIL . PngImagePlugin . PngImageFile ): # type: ignore # in a terminal process image . save ( f ) else : # in a jupyter kernel process f . write ( image . data ) # type: ignore return image","title":"to_image()"},{"location":"api/datamol.viz.html#datamol.viz.conformers","text":"Visualize the conformer(s) of a molecule. Parameters: Name Type Description Default mol Chem . rdchem . Mol a molecule. required conf_id int The ID of the conformer to show. -1 shows the first conformer. Only works if n_confs is None. -1 n_confs Union [ int , List [ int ]] Can be a number of conformers to shows or a list of conformer indices. When None, only the first conformer is displayed. When -1, show all conformers. None align_conf bool Whether to align conformers together. True n_cols int Number of columns. Defaults to 3. 3 sync_views bool Wether to sync the multiple views. True remove_hs bool Wether to remove the hydrogens of the conformers. True width str The width of the returned view. Defaults to \"auto\". 'auto' Source code in datamol/viz/_conformers.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def conformers ( mol : Chem . rdchem . Mol , conf_id : int = - 1 , n_confs : Union [ int , List [ int ]] = None , align_conf : bool = True , n_cols : int = 3 , sync_views : bool = True , remove_hs : bool = True , width : str = \"auto\" , ): \"\"\"Visualize the conformer(s) of a molecule. Args: mol: a molecule. conf_id: The ID of the conformer to show. -1 shows the first conformer. Only works if `n_confs` is None. n_confs: Can be a number of conformers to shows or a list of conformer indices. When None, only the first conformer is displayed. When -1, show all conformers. align_conf: Whether to align conformers together. n_cols: Number of columns. Defaults to 3. sync_views: Wether to sync the multiple views. remove_hs: Wether to remove the hydrogens of the conformers. width: The width of the returned view. Defaults to \"auto\". \"\"\" widgets = _get_ipywidgets () nv = _get_nglview () if mol . GetNumConformers () == 0 : raise ValueError ( \"The molecule has 0 conformers. You can generate conformers with `dm.conformers.generate(mol)`.\" ) # Clone the molecule mol = copy . deepcopy ( mol ) if remove_hs : mol = Chem . RemoveHs ( mol ) # type: ignore else : mol = Chem . AddHs ( mol ) # type: ignore if n_confs is None : return nv . show_rdkit ( mol , conf_id = conf_id ) # If n_confs is int, convert to list of conformer IDs if n_confs == - 1 : n_confs = [ conf . GetId () for conf in mol . GetConformers ()] elif isinstance ( n_confs , int ): if n_confs > mol . GetNumConformers (): n_confs = mol . GetNumConformers () n_confs = list ( range ( n_confs )) # type: ignore if align_conf : rdMolAlign . AlignMolConformers ( mol , confIds = n_confs ) # Get number of rows n_rows = len ( n_confs ) // n_cols n_rows += 1 if ( len ( n_confs ) % n_cols ) > 0 else 0 # Create a grid grid = widgets . GridspecLayout ( n_rows , n_cols ) # type: ignore # Create and add views to the grid. widget_coords = itertools . product ( range ( n_rows ), range ( n_cols )) views = [] for i , ( conf_id , ( x , y )) in enumerate ( zip ( n_confs , widget_coords )): view = nv . show_rdkit ( mol , conf_id = conf_id ) view . layout . width = width view . layout . align_self = \"stretch\" grid [ x , y ] = view views . append ( view ) # Sync views if sync_views : for view in views : view . _set_sync_camera ( views ) return grid","title":"conformers()"},{"location":"api/datamol.viz.html#specific-plotting-functions","text":"","title":"Specific plotting functions"},{"location":"api/datamol.viz.html#datamol.viz.MolsCircleGrid","text":"Source code in datamol/viz/_circle_grid.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class MolsCircleGrid : def __init__ ( self , center_mol : Chem . rdchem . Mol , circle_mols : List [ List [ Chem . rdchem . Mol ]], legend : Optional [ str ] = None , mol_size : Tuple [ int , int ] = ( 200 , 200 ), circle_margin : int = 50 , act_mapper : Optional [ dict ] = None , ): \"\"\"Show molecules in concentric rings, with one molecule at the center Args: center_mol: Molecule at center circle_mols: List of molecule for each concentric circle around the center mol mol_size: Tuple of width and height for each molecule circle_margin: Margin between the circle layers act_mapper: Map each molecule to a dictionary of activity \"\"\" self . circle_mols = circle_mols self . circle_count = len ( self . circle_mols ) self . legend = legend or \"\" self . margin = circle_margin self . center_mol = center_mol self . mol_size = mol_size size = ( max ( mol_size ) + self . margin ) * ( self . circle_count + 1 ) self . size = size self . image = Image . new ( mode = \"RGBA\" , size = ( size , size ), color = ( 255 , 255 , 255 , 0 )) self . midpoint = size // 2 self . draw = None self . act_mapper = act_mapper or {} self . _draw () def show ( self , crop = False ): if crop : crop_img = ImageOps . crop ( self . image , border = 1 ) else : crop_img = self . image return crop_img . show () def save ( self , filename ): self . image . save ( filename ) def _draw ( self ): \"\"\"Create circles and slices in-memory\"\"\" draw = ImageDraw . Draw ( self . image ) self . draw = draw all_radius = self . _draw_circles ( draw ) self . _draw_center_mol () self . _draw_ring_mols ( all_radius ) font = None w , h = draw . textsize ( self . legend ) try : fn = FontManager () fontpath = fn . findfont ( \"Droid sans\" ) font = ImageFont . truetype ( fontpath , 12 * self . size // 800 ) w , h = font . getsize ( self . legend ) except : pass draw . text ( (( self . size // 2 - w ) - 2 , self . size - 2 * h ), self . legend , fill = \"black\" , font = font , ) del draw self . draw = None def _repr_png_ ( self ): bio = io . BytesIO () self . image . save ( bio , format = \"PNG\" ) return bio . getvalue () def _draw_circles ( self , draw ): if self . circle_count <= 0 : return [] radius_step = int ( self . midpoint / ( self . circle_count + 1 )) radius_list = [] full_range = range ( 0 , self . size // 2 , radius_step ) for i , radius in enumerate ( full_range ): radius += self . margin // 2 bounding_box = [ ( self . midpoint - radius , self . midpoint - radius ), ( self . midpoint + radius , self . midpoint + radius ), ] if radius > self . margin : transp = int ( 255 - ( 200 * ( i - 1 ) / len ( full_range ))) draw . arc ( bounding_box , 0 , 360 , fill = ( 190 , 190 , 190 , transp )) radius_list . append ( radius + radius_step ) return radius_list def _draw_mol_at ( self , mol , center_x , center_y , mol_size = None , act_dict = {}, center = False , ** kwargs : Any , ): img = mol if mol_size is None : mol_size = self . mol_size if isinstance ( mol , Chem . Mol ): img = Draw . MolToImage ( mol , mol_size , kekulize = True , fitImage = True , ** kwargs ) width , height = img . size self . image . paste ( img , ( int ( center_x - width / 2 ), int ( center_y - height / 2 ))) txt = [] for prop , propval in act_dict . items (): if not isinstance ( propval , str ): propval = \" {:.2f} \" . format ( propval ) txt . append ( f \" { prop } : { propval } \" ) if txt and self . draw is not None : txt = \" \\n \" . join ( txt ) font = None w , h = self . draw . multiline_textsize ( txt ) try : fn = FontManager () fontpath = fn . findfont ( \"Droid sans\" ) font = ImageFont . truetype ( fontpath , 18 + center * 8 ) w , h = self . draw . multiline_textsize ( txt , font = font ) except : pass def _draw_center_mol ( self ): self . _draw_mol_at ( self . center_mol , self . midpoint , self . midpoint , mol_size = [ x + self . margin for x in self . mol_size ], act_dict = self . act_mapper . get ( self . center_mol , {}), center = True , ) def _draw_ring_mols ( self , radius_list ): for i , mols in enumerate ( self . circle_mols ): radius = radius_list [ i ] ni = len ( mols ) rand_unit = random . random () * 2 * math . pi for k , mol in enumerate ( mols ): center_x = radius * math . cos ( 2 * k * math . pi / ni + rand_unit ) + self . midpoint center_y = radius * math . sin ( 2 * k * math . pi / ni + rand_unit ) + self . midpoint self . _draw_mol_at ( mol , center_x , center_y , act_dict = self . act_mapper . get ( mol , {}))","title":"MolsCircleGrid"},{"location":"api/datamol.viz.html#datamol.viz._circle_grid.MolsCircleGrid.__init__","text":"Show molecules in concentric rings, with one molecule at the center Parameters: Name Type Description Default center_mol Chem . rdchem . Mol Molecule at center required circle_mols List [ List [ Chem . rdchem . Mol ]] List of molecule for each concentric circle around the center mol required mol_size Tuple [ int , int ] Tuple of width and height for each molecule (200, 200) circle_margin int Margin between the circle layers 50 act_mapper Optional [ dict ] Map each molecule to a dictionary of activity None Source code in datamol/viz/_circle_grid.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , center_mol : Chem . rdchem . Mol , circle_mols : List [ List [ Chem . rdchem . Mol ]], legend : Optional [ str ] = None , mol_size : Tuple [ int , int ] = ( 200 , 200 ), circle_margin : int = 50 , act_mapper : Optional [ dict ] = None , ): \"\"\"Show molecules in concentric rings, with one molecule at the center Args: center_mol: Molecule at center circle_mols: List of molecule for each concentric circle around the center mol mol_size: Tuple of width and height for each molecule circle_margin: Margin between the circle layers act_mapper: Map each molecule to a dictionary of activity \"\"\" self . circle_mols = circle_mols self . circle_count = len ( self . circle_mols ) self . legend = legend or \"\" self . margin = circle_margin self . center_mol = center_mol self . mol_size = mol_size size = ( max ( mol_size ) + self . margin ) * ( self . circle_count + 1 ) self . size = size self . image = Image . new ( mode = \"RGBA\" , size = ( size , size ), color = ( 255 , 255 , 255 , 0 )) self . midpoint = size // 2 self . draw = None self . act_mapper = act_mapper or {} self . _draw ()","title":"__init__()"},{"location":"api/datamol.viz.html#datamol.viz.circle_grid","text":"Show molecules in concentric rings, with one molecule at the center Parameters: Name Type Description Default center_mol Chem . Mol Molecule at center required circle_mols list of list of <Chem.Mol> List of molecule for each concentric circle around the center mol required mol_size tuple Tuple of width and height for each molecule (200, 200) circle_margin int Margin between the circle layers 50 act_mapper dict Map each molecule to a dictionary of activity None Source code in datamol/viz/_circle_grid.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def circle_grid ( center_mol : Chem . rdchem . Mol , circle_mols : List [ List [ Chem . rdchem . Mol ]], legend : Optional [ str ] = None , mol_size : Tuple [ int , int ] = ( 200 , 200 ), circle_margin : int = 50 , act_mapper : Optional [ dict ] = None , ): \"\"\"Show molecules in concentric rings, with one molecule at the center Args: center_mol (Chem.Mol): Molecule at center circle_mols (list of list of <Chem.Mol>): List of molecule for each concentric circle around the center mol mol_size (tuple, optional): Tuple of width and height for each molecule circle_margin (int, optional): Margin between the circle layers act_mapper (dict): Map each molecule to a dictionary of activity \"\"\" return MolsCircleGrid ( center_mol , circle_mols , legend , mol_size , circle_margin , act_mapper )","title":"circle_grid()"}]}